Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    ALIGNOF
    IGNORE
    NEWLINE
    UNSAFE
    EXCLUSIVEOREQUAL
    MOD
    WILDCARD
    TYPEOF
    PUB
    IMPL
    RIGHTSHIFT
    USE
    IN
    AS
    FOR
    USIZE
    UNSIZED
    EXTERN
    MOVE
    DOLLAR
    TRAIT
    OFFSETOF
    ISIZE
    FINAL
    CRATE
    EXCLUSIVEOR
    POUND
    THREEDOTS
    TYPE
    PURE
    DO
    OVERRIDE
    MACRO
    BREAK
    WHERE
    LEFTSHIFT
    VIRTUAL
    SIZEOF
    ERROR
    CONST
    SELF
    POUNDEXCLAMATION
    APOSTRAPHE
    CONTINUE
    SUPER
    PRIV
    RIGHTSHIFTEQUAL
    BE
    ABSTRACT
    YIELD
    MACRO_RULES
    STATIC
    LEFTSHIFTEQUAL

Grammar

Rule 0     S' -> crate
Rule 1     crate -> items
Rule 2     items -> item items
Rule 3     items -> item
Rule 4     items -> <empty>
Rule 5     item -> function
Rule 6     item -> struct
Rule 7     item -> enum
Rule 8     stmts -> stmt SEMICOLON stmts
Rule 9     stmts -> stmt
Rule 10    stmts -> <empty>
Rule 11    stmt -> return
Rule 12    stmt -> exp
Rule 13    stmt -> let
Rule 14    stmt -> function
Rule 15    exps -> exps
Rule 16    exps -> <empty>
Rule 17    exps -> exp COMMA exps
Rule 18    exps -> exp
Rule 19    exp -> LPAREN exp RPAREN
Rule 20    exp -> arith1
Rule 21    exp -> loop
Rule 22    exp -> while
Rule 23    exp -> box_new
Rule 24    exp -> if
Rule 25    exp -> match
Rule 26    exp -> arg_struct
Rule 27    exp -> assign
Rule 28    exp -> arr
Rule 29    exp -> arr_index
Rule 30    exp -> unit
Rule 31    exp -> <empty>
Rule 32    arith1 -> add
Rule 33    arith1 -> sub
Rule 34    arith1 -> arith2
Rule 35    arith2 -> mul
Rule 36    arith2 -> div
Rule 37    arith2 -> mod
Rule 38    arith2 -> neg
Rule 39    arith2 -> arith3
Rule 40    arith3 -> LPAREN arith1 RPAREN
Rule 41    arith3 -> fn_call
Rule 42    arith3 -> comp
Rule 43    arith3 -> field_lookup
Rule 44    arith3 -> arith4
Rule 45    arith4 -> id
Rule 46    arith4 -> ptr
Rule 47    arith4 -> lit
Rule 48    add -> arith1 ADD arith1
Rule 49    sub -> arith1 SUB arith1
Rule 50    mul -> arith1 MUL arith1
Rule 51    div -> arith1 DIV arith1
Rule 52    mod -> arith1 MODOP arith1
Rule 53    neg -> SUB arith4
Rule 54    comp -> lt
Rule 55    comp -> leq
Rule 56    comp -> gt
Rule 57    comp -> geq
Rule 58    comp -> eq
Rule 59    comp -> neq
Rule 60    comp -> or
Rule 61    comp -> and
Rule 62    comp -> not
Rule 63    lt -> arith1 LESSTHAN arith1
Rule 64    leq -> arith1 LESSTHANOREQUAL arith1
Rule 65    gt -> arith1 GREATERTHAN arith1
Rule 66    geq -> arith1 GREATERTHANOREQUAL arith1
Rule 67    eq -> arith1 EQUALTO arith1
Rule 68    neq -> arith1 NOTEQUAL arith1
Rule 69    or -> arith1 LOGICALOR arith1
Rule 70    and -> arith1 LOGICALAND arith1
Rule 71    not -> NOT arith1
Rule 72    ptr -> addr
Rule 73    ptr -> deref
Rule 74    ptr -> addr_of_mut
Rule 75    addr -> AND arith4
Rule 76    addr -> AND neg
Rule 77    deref -> MUL arith4
Rule 78    deref -> MUL neg
Rule 79    addr_of_mut -> AND MUT arith4
Rule 80    addr_of_mut -> AND MUT neg
Rule 81    unit -> LPAREN RPAREN
Rule 82    assign -> exp EQU exp
Rule 83    assign -> exp PLUSEQUAL exp
Rule 84    assign -> exp SUBEQUAL exp
Rule 85    assign -> exp DIVEQUAL exp
Rule 86    assign -> exp TIMESEQUAL exp
Rule 87    assign -> exp MODEQUAL exp
Rule 88    assign -> exp ANDEQUAL exp
Rule 89    assign -> exp OREQUAL exp
Rule 90    let -> LET pat COLON type EQU exp
Rule 91    let -> LET pat COLON type
Rule 92    let -> LET pat EQU exp
Rule 93    let -> LET pat
Rule 94    field_lookup -> exp PERIOD id
Rule 95    while -> WHILE LPAREN exp RPAREN block
Rule 96    loop -> LOOP block
Rule 97    if -> IF LPAREN exp RPAREN block
Rule 98    if -> if ELSE block
Rule 99    match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
Rule 100   match_arms -> match_arm COMMA match_arms
Rule 101   match_arms -> match_arm
Rule 102   match_arm -> match_pats PIPE block
Rule 103   match_pats -> pat OR match_pats
Rule 104   match_pats -> pat
Rule 105   pats -> pat COMMA pats
Rule 106   pats -> pat
Rule 107   pat -> p_lit
Rule 108   pat -> LPAREN RPAREN
Rule 109   pat -> WC
Rule 110   pat -> SUB p_lit
Rule 111   pat -> id
Rule 112   pat -> REF id
Rule 113   pat -> REF MUT id
Rule 114   pat -> MUT id
Rule 115   pat -> AND pat
Rule 116   pat -> pat_arr
Rule 117   pat -> pat_enum
Rule 118   pat -> pat_struct
Rule 119   pat_arr -> LBRACKET pats RBRACKET
Rule 120   pat_struct -> id LSQUIGBRACKET pat_fields RSQUIGBRACKET
Rule 121   pat_fields -> pat_field COMMA pat_fields
Rule 122   pat_fields -> pat_field
Rule 123   pat_field -> id COLON pat
Rule 124   arr -> LBRACKET exps RBRACKET
Rule 125   arr_index -> exp LBRACKET exp RBRACKET
Rule 126   function -> FN id LPAREN fn_params_seq RPAREN block
Rule 127   function -> FN id LPAREN fn_params_seq RPAREN OBJECTACCESS type block
Rule 128   fn_call -> id LPAREN fn_args RPAREN
Rule 129   fn_args -> fn_arg fn_args
Rule 130   fn_args -> <empty>
Rule 131   fn_arg -> fn_arg COMMA
Rule 132   fn_arg -> lit
Rule 133   fn_arg -> id
Rule 134   fn_arg -> box_new
Rule 135   fn_arg -> fn_call
Rule 136   fn_arg -> arg_struct
Rule 137   lit -> p_lit
Rule 138   lit -> enum_con
Rule 139   p_lit -> LITDEC
Rule 140   p_lit -> LITCHAR
Rule 141   p_lit -> LITBOOL
Rule 142   p_lit -> LITSTRING
Rule 143   id -> ID
Rule 144   fn_params_seq -> fn_params
Rule 145   fn_params_seq -> <empty>
Rule 146   fn_params -> fn_param COMMA fn_params
Rule 147   fn_params -> fn_param
Rule 148   fn_param -> pat COLON type
Rule 149   fn_param -> pat COLON id
Rule 150   types -> type COMMA types
Rule 151   types -> type
Rule 152   type -> BOOL
Rule 153   type -> UEIGHT
Rule 154   type -> USIXTEEN
Rule 155   type -> UTHREETWO
Rule 156   type -> USIXFOUR
Rule 157   type -> IEIGHT
Rule 158   type -> ISIXTEEN
Rule 159   type -> ITHREETWO
Rule 160   type -> ISIXFOUR
Rule 161   type -> FTHREETWO
Rule 162   type -> FSIXFOUR
Rule 163   type -> CHAR
Rule 164   type -> STR
Rule 165   type -> box
Rule 166   type -> NOT
Rule 167   type -> type_ref
Rule 168   type -> id
Rule 169   type -> AND MUT type
Rule 170   type -> type_arr
Rule 171   type -> LPAREN RPAREN
Rule 172   type -> <empty>
Rule 173   type_arr -> LBRACKET type RBRACKET
Rule 174   type_arr -> LBRACKET type SEMICOLON p_lit RBRACKET
Rule 175   type_ref -> AND type
Rule 176   box -> BOX LESSTHAN type GREATERTHAN
Rule 177   box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN
Rule 178   struct -> STRUCT id LSQUIGBRACKET field_defs RSQUIGBRACKET
Rule 179   field_defs -> field_def field_defs
Rule 180   field_defs -> field_def
Rule 181   field_def -> field_def COMMA
Rule 182   field_def -> id COLON type
Rule 183   block -> LSQUIGBRACKET stmts RSQUIGBRACKET
Rule 184   return -> RETURN
Rule 185   return -> return exp
Rule 186   arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET
Rule 187   body -> param_arg body
Rule 188   body -> param_arg
Rule 189   param_arg -> param_arg COMMA
Rule 190   param_arg -> id COLON exp
Rule 191   enum_con -> enum_con LPAREN exps RPAREN
Rule 192   enum_con -> id CLASSACCESS id
Rule 193   pat_enum -> pat_enum LPAREN pats RPAREN
Rule 194   pat_enum -> id CLASSACCESS id
Rule 195   enum -> ENUM id LSQUIGBRACKET enum_params RSQUIGBRACKET
Rule 196   enum_params -> enum_param enum_params
Rule 197   enum_params -> <empty>
Rule 198   enum_param -> enum_param COMMA
Rule 199   enum_param -> id LPAREN types RPAREN
Rule 200   enum_param -> id

Terminals, with rules where they appear

ABSTRACT             : 
ADD                  : 48
ALIGNOF              : 
AND                  : 75 76 79 80 115 169 175
ANDEQUAL             : 88
APOSTRAPHE           : 
AS                   : 
BE                   : 
BOOL                 : 152
BOX                  : 176 177
BREAK                : 
CHAR                 : 163
CLASSACCESS          : 177 192 194
COLON                : 90 91 123 148 149 182 190
COMMA                : 17 100 105 121 131 146 150 181 189 198
CONST                : 
CONTINUE             : 
CRATE                : 
DIV                  : 51
DIVEQUAL             : 85
DO                   : 
DOLLAR               : 
ELSE                 : 98
ENUM                 : 195
EQU                  : 82 90 92
EQUALTO              : 67
ERROR                : 
EXCLUSIVEOR          : 
EXCLUSIVEOREQUAL     : 
EXTERN               : 
FINAL                : 
FN                   : 126 127
FOR                  : 
FSIXFOUR             : 162
FTHREETWO            : 161
GREATERTHAN          : 65 176
GREATERTHANOREQUAL   : 66
ID                   : 143
IEIGHT               : 157
IF                   : 97
IGNORE               : 
IMPL                 : 
IN                   : 
ISIXFOUR             : 160
ISIXTEEN             : 158
ISIZE                : 
ITHREETWO            : 159
LBRACKET             : 119 124 125 173 174
LEFTSHIFT            : 
LEFTSHIFTEQUAL       : 
LESSTHAN             : 63 176
LESSTHANOREQUAL      : 64
LET                  : 90 91 92 93
LITBOOL              : 141
LITCHAR              : 140
LITDEC               : 139
LITSTRING            : 142
LOGICALAND           : 70
LOGICALOR            : 69
LOOP                 : 96
LPAREN               : 19 40 81 95 97 99 108 126 127 128 171 177 191 193 199
LSQUIGBRACKET        : 99 120 178 183 186 195
MACRO                : 
MACRO_RULES          : 
MATCH                : 99
MOD                  : 
MODEQUAL             : 87
MODOP                : 52
MOVE                 : 
MUL                  : 50 77 78
MUT                  : 79 80 113 114 169
NEW                  : 177
NEWLINE              : 
NOT                  : 71 166
NOTEQUAL             : 68
OBJECTACCESS         : 127
OFFSETOF             : 
OR                   : 103
OREQUAL              : 89
OVERRIDE             : 
PERIOD               : 94
PIPE                 : 102
PLUSEQUAL            : 83
POUND                : 
POUNDEXCLAMATION     : 
PRIV                 : 
PUB                  : 
PURE                 : 
RBRACKET             : 119 124 125 173 174
REF                  : 112 113
RETURN               : 184
RIGHTSHIFT           : 
RIGHTSHIFTEQUAL      : 
RPAREN               : 19 40 81 95 97 99 108 126 127 128 171 177 191 193 199
RSQUIGBRACKET        : 99 120 178 183 186 195
SELF                 : 
SEMICOLON            : 8 174
SIZEOF               : 
STATIC               : 
STR                  : 164
STRUCT               : 178
SUB                  : 49 53 110
SUBEQUAL             : 84
SUPER                : 
THREEDOTS            : 
TIMESEQUAL           : 86
TRAIT                : 
TYPE                 : 
TYPEOF               : 
UEIGHT               : 153
UNSAFE               : 
UNSIZED              : 
USE                  : 
USIXFOUR             : 156
USIXTEEN             : 154
USIZE                : 
UTHREETWO            : 155
VIRTUAL              : 
WC                   : 109
WHERE                : 
WHILE                : 95
WILDCARD             : 
YIELD                : 
error                : 

Nonterminals, with rules where they appear

add                  : 32
addr                 : 72
addr_of_mut          : 74
and                  : 61
arg_struct           : 26 136
arith1               : 20 40 48 48 49 49 50 50 51 51 52 52 63 63 64 64 65 65 66 66 67 67 68 68 69 69 70 70 71
arith2               : 34
arith3               : 39
arith4               : 44 53 75 77 79
arr                  : 28
arr_index            : 29
assign               : 27
block                : 95 96 97 98 102 126 127
body                 : 186 187
box                  : 165
box_new              : 23 134
comp                 : 42
crate                : 0
deref                : 73
div                  : 36
enum                 : 7
enum_con             : 138 191
enum_param           : 196 198
enum_params          : 195 196
eq                   : 58
exp                  : 12 17 18 19 82 82 83 83 84 84 85 85 86 86 87 87 88 88 89 89 90 92 94 95 97 99 125 125 177 185 190
exps                 : 15 17 124 191
field_def            : 179 180 181
field_defs           : 178 179
field_lookup         : 43
fn_arg               : 129 131
fn_args              : 128 129
fn_call              : 41 135
fn_param             : 146 147
fn_params            : 144 146
fn_params_seq        : 126 127
function             : 5 14
geq                  : 57
gt                   : 56
id                   : 45 94 111 112 113 114 120 123 126 127 128 133 149 168 178 182 186 190 192 192 194 194 195 199 200
if                   : 24 98
item                 : 2 3
items                : 1 2
leq                  : 55
let                  : 13
lit                  : 47 132
loop                 : 21
lt                   : 54
match                : 25
match_arm            : 100 101
match_arms           : 99 100
match_pats           : 102 103
mod                  : 37
mul                  : 35
neg                  : 38 76 78 80
neq                  : 59
not                  : 62
or                   : 60
p_lit                : 107 110 137 174
param_arg            : 187 188 189
pat                  : 90 91 92 93 103 104 105 106 115 123 148 149
pat_arr              : 116
pat_enum             : 117 193
pat_field            : 121 122
pat_fields           : 120 121
pat_struct           : 118
pats                 : 105 119 193
ptr                  : 46
return               : 11 185
stmt                 : 8 9
stmts                : 8 183
struct               : 6
sub                  : 33
type                 : 90 91 127 148 150 151 169 173 174 175 176 182
type_arr             : 170
type_ref             : 167
types                : 150 199
unit                 : 30
while                : 22

Parsing method: LALR

state 0

    (0) S' -> . crate
    (1) crate -> . items
    (2) items -> . item items
    (3) items -> . item
    (4) items -> .
    (5) item -> . function
    (6) item -> . struct
    (7) item -> . enum
    (126) function -> . FN id LPAREN fn_params_seq RPAREN block
    (127) function -> . FN id LPAREN fn_params_seq RPAREN OBJECTACCESS type block
    (178) struct -> . STRUCT id LSQUIGBRACKET field_defs RSQUIGBRACKET
    (195) enum -> . ENUM id LSQUIGBRACKET enum_params RSQUIGBRACKET

    $end            reduce using rule 4 (items -> .)
    FN              shift and go to state 4
    STRUCT          shift and go to state 2
    ENUM            shift and go to state 3

    function                       shift and go to state 1
    enum                           shift and go to state 5
    crate                          shift and go to state 6
    items                          shift and go to state 7
    struct                         shift and go to state 8
    item                           shift and go to state 9

state 1

    (5) item -> function .

    FN              reduce using rule 5 (item -> function .)
    STRUCT          reduce using rule 5 (item -> function .)
    ENUM            reduce using rule 5 (item -> function .)
    $end            reduce using rule 5 (item -> function .)


state 2

    (178) struct -> STRUCT . id LSQUIGBRACKET field_defs RSQUIGBRACKET
    (143) id -> . ID

    ID              shift and go to state 10

    id                             shift and go to state 11

state 3

    (195) enum -> ENUM . id LSQUIGBRACKET enum_params RSQUIGBRACKET
    (143) id -> . ID

    ID              shift and go to state 10

    id                             shift and go to state 12

state 4

    (126) function -> FN . id LPAREN fn_params_seq RPAREN block
    (127) function -> FN . id LPAREN fn_params_seq RPAREN OBJECTACCESS type block
    (143) id -> . ID

    ID              shift and go to state 10

    id                             shift and go to state 13

state 5

    (7) item -> enum .

    FN              reduce using rule 7 (item -> enum .)
    STRUCT          reduce using rule 7 (item -> enum .)
    ENUM            reduce using rule 7 (item -> enum .)
    $end            reduce using rule 7 (item -> enum .)


state 6

    (0) S' -> crate .



state 7

    (1) crate -> items .

    $end            reduce using rule 1 (crate -> items .)


state 8

    (6) item -> struct .

    FN              reduce using rule 6 (item -> struct .)
    STRUCT          reduce using rule 6 (item -> struct .)
    ENUM            reduce using rule 6 (item -> struct .)
    $end            reduce using rule 6 (item -> struct .)


state 9

    (2) items -> item . items
    (3) items -> item .
    (2) items -> . item items
    (3) items -> . item
    (4) items -> .
    (5) item -> . function
    (6) item -> . struct
    (7) item -> . enum
    (126) function -> . FN id LPAREN fn_params_seq RPAREN block
    (127) function -> . FN id LPAREN fn_params_seq RPAREN OBJECTACCESS type block
    (178) struct -> . STRUCT id LSQUIGBRACKET field_defs RSQUIGBRACKET
    (195) enum -> . ENUM id LSQUIGBRACKET enum_params RSQUIGBRACKET

  ! reduce/reduce conflict for $end resolved using rule 3 (items -> item .)
    $end            reduce using rule 3 (items -> item .)
    FN              shift and go to state 4
    STRUCT          shift and go to state 2
    ENUM            shift and go to state 3

  ! $end            [ reduce using rule 4 (items -> .) ]

    function                       shift and go to state 1
    items                          shift and go to state 14
    struct                         shift and go to state 8
    enum                           shift and go to state 5
    item                           shift and go to state 9

state 10

    (143) id -> ID .

    COMMA           reduce using rule 143 (id -> ID .)
    ID              reduce using rule 143 (id -> ID .)
    RSQUIGBRACKET   reduce using rule 143 (id -> ID .)
    RPAREN          reduce using rule 143 (id -> ID .)
    RBRACKET        reduce using rule 143 (id -> ID .)
    SEMICOLON       reduce using rule 143 (id -> ID .)
    LSQUIGBRACKET   reduce using rule 143 (id -> ID .)
    GREATERTHAN     reduce using rule 143 (id -> ID .)
    EQU             reduce using rule 143 (id -> ID .)
    LPAREN          reduce using rule 143 (id -> ID .)
    CLASSACCESS     reduce using rule 143 (id -> ID .)
    ADD             reduce using rule 143 (id -> ID .)
    SUB             reduce using rule 143 (id -> ID .)
    MUL             reduce using rule 143 (id -> ID .)
    DIV             reduce using rule 143 (id -> ID .)
    MODOP           reduce using rule 143 (id -> ID .)
    LESSTHAN        reduce using rule 143 (id -> ID .)
    LESSTHANOREQUAL reduce using rule 143 (id -> ID .)
    GREATERTHANOREQUAL reduce using rule 143 (id -> ID .)
    EQUALTO         reduce using rule 143 (id -> ID .)
    NOTEQUAL        reduce using rule 143 (id -> ID .)
    LOGICALOR       reduce using rule 143 (id -> ID .)
    LOGICALAND      reduce using rule 143 (id -> ID .)
    PLUSEQUAL       reduce using rule 143 (id -> ID .)
    SUBEQUAL        reduce using rule 143 (id -> ID .)
    DIVEQUAL        reduce using rule 143 (id -> ID .)
    TIMESEQUAL      reduce using rule 143 (id -> ID .)
    MODEQUAL        reduce using rule 143 (id -> ID .)
    ANDEQUAL        reduce using rule 143 (id -> ID .)
    OREQUAL         reduce using rule 143 (id -> ID .)
    LBRACKET        reduce using rule 143 (id -> ID .)
    PERIOD          reduce using rule 143 (id -> ID .)
    COLON           reduce using rule 143 (id -> ID .)
    LOOP            reduce using rule 143 (id -> ID .)
    WHILE           reduce using rule 143 (id -> ID .)
    BOX             reduce using rule 143 (id -> ID .)
    IF              reduce using rule 143 (id -> ID .)
    MATCH           reduce using rule 143 (id -> ID .)
    NOT             reduce using rule 143 (id -> ID .)
    AND             reduce using rule 143 (id -> ID .)
    LITDEC          reduce using rule 143 (id -> ID .)
    LITCHAR         reduce using rule 143 (id -> ID .)
    LITBOOL         reduce using rule 143 (id -> ID .)
    LITSTRING       reduce using rule 143 (id -> ID .)
    OR              reduce using rule 143 (id -> ID .)
    PIPE            reduce using rule 143 (id -> ID .)


state 11

    (178) struct -> STRUCT id . LSQUIGBRACKET field_defs RSQUIGBRACKET

    LSQUIGBRACKET   shift and go to state 15


state 12

    (195) enum -> ENUM id . LSQUIGBRACKET enum_params RSQUIGBRACKET

    LSQUIGBRACKET   shift and go to state 16


state 13

    (126) function -> FN id . LPAREN fn_params_seq RPAREN block
    (127) function -> FN id . LPAREN fn_params_seq RPAREN OBJECTACCESS type block

    LPAREN          shift and go to state 17


state 14

    (2) items -> item items .

    $end            reduce using rule 2 (items -> item items .)


state 15

    (178) struct -> STRUCT id LSQUIGBRACKET . field_defs RSQUIGBRACKET
    (179) field_defs -> . field_def field_defs
    (180) field_defs -> . field_def
    (181) field_def -> . field_def COMMA
    (182) field_def -> . id COLON type
    (143) id -> . ID

    ID              shift and go to state 10

    field_def                      shift and go to state 18
    id                             shift and go to state 19
    field_defs                     shift and go to state 20

state 16

    (195) enum -> ENUM id LSQUIGBRACKET . enum_params RSQUIGBRACKET
    (196) enum_params -> . enum_param enum_params
    (197) enum_params -> .
    (198) enum_param -> . enum_param COMMA
    (199) enum_param -> . id LPAREN types RPAREN
    (200) enum_param -> . id
    (143) id -> . ID

    RSQUIGBRACKET   reduce using rule 197 (enum_params -> .)
    ID              shift and go to state 10

    id                             shift and go to state 23
    enum_param                     shift and go to state 21
    enum_params                    shift and go to state 22

state 17

    (126) function -> FN id LPAREN . fn_params_seq RPAREN block
    (127) function -> FN id LPAREN . fn_params_seq RPAREN OBJECTACCESS type block
    (144) fn_params_seq -> . fn_params
    (145) fn_params_seq -> .
    (146) fn_params -> . fn_param COMMA fn_params
    (147) fn_params -> . fn_param
    (148) fn_param -> . pat COLON type
    (149) fn_param -> . pat COLON id
    (107) pat -> . p_lit
    (108) pat -> . LPAREN RPAREN
    (109) pat -> . WC
    (110) pat -> . SUB p_lit
    (111) pat -> . id
    (112) pat -> . REF id
    (113) pat -> . REF MUT id
    (114) pat -> . MUT id
    (115) pat -> . AND pat
    (116) pat -> . pat_arr
    (117) pat -> . pat_enum
    (118) pat -> . pat_struct
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (143) id -> . ID
    (119) pat_arr -> . LBRACKET pats RBRACKET
    (193) pat_enum -> . pat_enum LPAREN pats RPAREN
    (194) pat_enum -> . id CLASSACCESS id
    (120) pat_struct -> . id LSQUIGBRACKET pat_fields RSQUIGBRACKET

    RPAREN          reduce using rule 145 (fn_params_seq -> .)
    LPAREN          shift and go to state 29
    WC              shift and go to state 36
    SUB             shift and go to state 34
    REF             shift and go to state 32
    MUT             shift and go to state 33
    AND             shift and go to state 30
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40
    ID              shift and go to state 10
    LBRACKET        shift and go to state 41

    id                             shift and go to state 43
    fn_params                      shift and go to state 24
    p_lit                          shift and go to state 26
    pat_enum                       shift and go to state 35
    pat_arr                        shift and go to state 37
    pat                            shift and go to state 38
    fn_params_seq                  shift and go to state 27
    fn_param                       shift and go to state 28
    pat_struct                     shift and go to state 42

state 18

    (179) field_defs -> field_def . field_defs
    (180) field_defs -> field_def .
    (181) field_def -> field_def . COMMA
    (179) field_defs -> . field_def field_defs
    (180) field_defs -> . field_def
    (181) field_def -> . field_def COMMA
    (182) field_def -> . id COLON type
    (143) id -> . ID

    RSQUIGBRACKET   reduce using rule 180 (field_defs -> field_def .)
    COMMA           shift and go to state 45
    ID              shift and go to state 10

    field_def                      shift and go to state 18
    id                             shift and go to state 19
    field_defs                     shift and go to state 44

state 19

    (182) field_def -> id . COLON type

    COLON           shift and go to state 46


state 20

    (178) struct -> STRUCT id LSQUIGBRACKET field_defs . RSQUIGBRACKET

    RSQUIGBRACKET   shift and go to state 47


state 21

    (196) enum_params -> enum_param . enum_params
    (198) enum_param -> enum_param . COMMA
    (196) enum_params -> . enum_param enum_params
    (197) enum_params -> .
    (198) enum_param -> . enum_param COMMA
    (199) enum_param -> . id LPAREN types RPAREN
    (200) enum_param -> . id
    (143) id -> . ID

    COMMA           shift and go to state 49
    RSQUIGBRACKET   reduce using rule 197 (enum_params -> .)
    ID              shift and go to state 10

    enum_param                     shift and go to state 21
    id                             shift and go to state 23
    enum_params                    shift and go to state 48

state 22

    (195) enum -> ENUM id LSQUIGBRACKET enum_params . RSQUIGBRACKET

    RSQUIGBRACKET   shift and go to state 50


state 23

    (199) enum_param -> id . LPAREN types RPAREN
    (200) enum_param -> id .

    LPAREN          shift and go to state 51
    COMMA           reduce using rule 200 (enum_param -> id .)
    ID              reduce using rule 200 (enum_param -> id .)
    RSQUIGBRACKET   reduce using rule 200 (enum_param -> id .)


state 24

    (144) fn_params_seq -> fn_params .

    RPAREN          reduce using rule 144 (fn_params_seq -> fn_params .)


state 25

    (141) p_lit -> LITBOOL .

    COMMA           reduce using rule 141 (p_lit -> LITBOOL .)
    RPAREN          reduce using rule 141 (p_lit -> LITBOOL .)
    ADD             reduce using rule 141 (p_lit -> LITBOOL .)
    SUB             reduce using rule 141 (p_lit -> LITBOOL .)
    MUL             reduce using rule 141 (p_lit -> LITBOOL .)
    DIV             reduce using rule 141 (p_lit -> LITBOOL .)
    MODOP           reduce using rule 141 (p_lit -> LITBOOL .)
    LESSTHAN        reduce using rule 141 (p_lit -> LITBOOL .)
    LESSTHANOREQUAL reduce using rule 141 (p_lit -> LITBOOL .)
    GREATERTHAN     reduce using rule 141 (p_lit -> LITBOOL .)
    GREATERTHANOREQUAL reduce using rule 141 (p_lit -> LITBOOL .)
    EQUALTO         reduce using rule 141 (p_lit -> LITBOOL .)
    NOTEQUAL        reduce using rule 141 (p_lit -> LITBOOL .)
    LOGICALOR       reduce using rule 141 (p_lit -> LITBOOL .)
    LOGICALAND      reduce using rule 141 (p_lit -> LITBOOL .)
    EQU             reduce using rule 141 (p_lit -> LITBOOL .)
    PLUSEQUAL       reduce using rule 141 (p_lit -> LITBOOL .)
    SUBEQUAL        reduce using rule 141 (p_lit -> LITBOOL .)
    DIVEQUAL        reduce using rule 141 (p_lit -> LITBOOL .)
    TIMESEQUAL      reduce using rule 141 (p_lit -> LITBOOL .)
    MODEQUAL        reduce using rule 141 (p_lit -> LITBOOL .)
    ANDEQUAL        reduce using rule 141 (p_lit -> LITBOOL .)
    OREQUAL         reduce using rule 141 (p_lit -> LITBOOL .)
    LBRACKET        reduce using rule 141 (p_lit -> LITBOOL .)
    PERIOD          reduce using rule 141 (p_lit -> LITBOOL .)
    SEMICOLON       reduce using rule 141 (p_lit -> LITBOOL .)
    RSQUIGBRACKET   reduce using rule 141 (p_lit -> LITBOOL .)
    LPAREN          reduce using rule 141 (p_lit -> LITBOOL .)
    LOOP            reduce using rule 141 (p_lit -> LITBOOL .)
    WHILE           reduce using rule 141 (p_lit -> LITBOOL .)
    BOX             reduce using rule 141 (p_lit -> LITBOOL .)
    IF              reduce using rule 141 (p_lit -> LITBOOL .)
    MATCH           reduce using rule 141 (p_lit -> LITBOOL .)
    ID              reduce using rule 141 (p_lit -> LITBOOL .)
    NOT             reduce using rule 141 (p_lit -> LITBOOL .)
    AND             reduce using rule 141 (p_lit -> LITBOOL .)
    LITDEC          reduce using rule 141 (p_lit -> LITBOOL .)
    LITCHAR         reduce using rule 141 (p_lit -> LITBOOL .)
    LITBOOL         reduce using rule 141 (p_lit -> LITBOOL .)
    LITSTRING       reduce using rule 141 (p_lit -> LITBOOL .)
    RBRACKET        reduce using rule 141 (p_lit -> LITBOOL .)
    COLON           reduce using rule 141 (p_lit -> LITBOOL .)
    OR              reduce using rule 141 (p_lit -> LITBOOL .)
    PIPE            reduce using rule 141 (p_lit -> LITBOOL .)


state 26

    (107) pat -> p_lit .

    COMMA           reduce using rule 107 (pat -> p_lit .)
    RPAREN          reduce using rule 107 (pat -> p_lit .)
    OR              reduce using rule 107 (pat -> p_lit .)
    PIPE            reduce using rule 107 (pat -> p_lit .)
    RSQUIGBRACKET   reduce using rule 107 (pat -> p_lit .)
    RBRACKET        reduce using rule 107 (pat -> p_lit .)
    COLON           reduce using rule 107 (pat -> p_lit .)
    EQU             reduce using rule 107 (pat -> p_lit .)
    SEMICOLON       reduce using rule 107 (pat -> p_lit .)


state 27

    (126) function -> FN id LPAREN fn_params_seq . RPAREN block
    (127) function -> FN id LPAREN fn_params_seq . RPAREN OBJECTACCESS type block

    RPAREN          shift and go to state 52


state 28

    (146) fn_params -> fn_param . COMMA fn_params
    (147) fn_params -> fn_param .

    COMMA           shift and go to state 53
    RPAREN          reduce using rule 147 (fn_params -> fn_param .)


state 29

    (108) pat -> LPAREN . RPAREN

    RPAREN          shift and go to state 54


state 30

    (115) pat -> AND . pat
    (107) pat -> . p_lit
    (108) pat -> . LPAREN RPAREN
    (109) pat -> . WC
    (110) pat -> . SUB p_lit
    (111) pat -> . id
    (112) pat -> . REF id
    (113) pat -> . REF MUT id
    (114) pat -> . MUT id
    (115) pat -> . AND pat
    (116) pat -> . pat_arr
    (117) pat -> . pat_enum
    (118) pat -> . pat_struct
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (143) id -> . ID
    (119) pat_arr -> . LBRACKET pats RBRACKET
    (193) pat_enum -> . pat_enum LPAREN pats RPAREN
    (194) pat_enum -> . id CLASSACCESS id
    (120) pat_struct -> . id LSQUIGBRACKET pat_fields RSQUIGBRACKET

    LPAREN          shift and go to state 29
    WC              shift and go to state 36
    SUB             shift and go to state 34
    REF             shift and go to state 32
    MUT             shift and go to state 33
    AND             shift and go to state 30
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40
    ID              shift and go to state 10
    LBRACKET        shift and go to state 41

    pat_arr                        shift and go to state 37
    pat                            shift and go to state 55
    id                             shift and go to state 43
    pat_struct                     shift and go to state 42
    p_lit                          shift and go to state 26
    pat_enum                       shift and go to state 35

state 31

    (139) p_lit -> LITDEC .

    COMMA           reduce using rule 139 (p_lit -> LITDEC .)
    RPAREN          reduce using rule 139 (p_lit -> LITDEC .)
    ADD             reduce using rule 139 (p_lit -> LITDEC .)
    SUB             reduce using rule 139 (p_lit -> LITDEC .)
    MUL             reduce using rule 139 (p_lit -> LITDEC .)
    DIV             reduce using rule 139 (p_lit -> LITDEC .)
    MODOP           reduce using rule 139 (p_lit -> LITDEC .)
    LESSTHAN        reduce using rule 139 (p_lit -> LITDEC .)
    LESSTHANOREQUAL reduce using rule 139 (p_lit -> LITDEC .)
    GREATERTHAN     reduce using rule 139 (p_lit -> LITDEC .)
    GREATERTHANOREQUAL reduce using rule 139 (p_lit -> LITDEC .)
    EQUALTO         reduce using rule 139 (p_lit -> LITDEC .)
    NOTEQUAL        reduce using rule 139 (p_lit -> LITDEC .)
    LOGICALOR       reduce using rule 139 (p_lit -> LITDEC .)
    LOGICALAND      reduce using rule 139 (p_lit -> LITDEC .)
    EQU             reduce using rule 139 (p_lit -> LITDEC .)
    PLUSEQUAL       reduce using rule 139 (p_lit -> LITDEC .)
    SUBEQUAL        reduce using rule 139 (p_lit -> LITDEC .)
    DIVEQUAL        reduce using rule 139 (p_lit -> LITDEC .)
    TIMESEQUAL      reduce using rule 139 (p_lit -> LITDEC .)
    MODEQUAL        reduce using rule 139 (p_lit -> LITDEC .)
    ANDEQUAL        reduce using rule 139 (p_lit -> LITDEC .)
    OREQUAL         reduce using rule 139 (p_lit -> LITDEC .)
    LBRACKET        reduce using rule 139 (p_lit -> LITDEC .)
    PERIOD          reduce using rule 139 (p_lit -> LITDEC .)
    SEMICOLON       reduce using rule 139 (p_lit -> LITDEC .)
    RSQUIGBRACKET   reduce using rule 139 (p_lit -> LITDEC .)
    LPAREN          reduce using rule 139 (p_lit -> LITDEC .)
    LOOP            reduce using rule 139 (p_lit -> LITDEC .)
    WHILE           reduce using rule 139 (p_lit -> LITDEC .)
    BOX             reduce using rule 139 (p_lit -> LITDEC .)
    IF              reduce using rule 139 (p_lit -> LITDEC .)
    MATCH           reduce using rule 139 (p_lit -> LITDEC .)
    ID              reduce using rule 139 (p_lit -> LITDEC .)
    NOT             reduce using rule 139 (p_lit -> LITDEC .)
    AND             reduce using rule 139 (p_lit -> LITDEC .)
    LITDEC          reduce using rule 139 (p_lit -> LITDEC .)
    LITCHAR         reduce using rule 139 (p_lit -> LITDEC .)
    LITBOOL         reduce using rule 139 (p_lit -> LITDEC .)
    LITSTRING       reduce using rule 139 (p_lit -> LITDEC .)
    RBRACKET        reduce using rule 139 (p_lit -> LITDEC .)
    COLON           reduce using rule 139 (p_lit -> LITDEC .)
    OR              reduce using rule 139 (p_lit -> LITDEC .)
    PIPE            reduce using rule 139 (p_lit -> LITDEC .)


state 32

    (112) pat -> REF . id
    (113) pat -> REF . MUT id
    (143) id -> . ID

    MUT             shift and go to state 57
    ID              shift and go to state 10

    id                             shift and go to state 56

state 33

    (114) pat -> MUT . id
    (143) id -> . ID

    ID              shift and go to state 10

    id                             shift and go to state 58

state 34

    (110) pat -> SUB . p_lit
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING

    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

    p_lit                          shift and go to state 59

state 35

    (117) pat -> pat_enum .
    (193) pat_enum -> pat_enum . LPAREN pats RPAREN

    COMMA           reduce using rule 117 (pat -> pat_enum .)
    RPAREN          reduce using rule 117 (pat -> pat_enum .)
    OR              reduce using rule 117 (pat -> pat_enum .)
    PIPE            reduce using rule 117 (pat -> pat_enum .)
    RSQUIGBRACKET   reduce using rule 117 (pat -> pat_enum .)
    RBRACKET        reduce using rule 117 (pat -> pat_enum .)
    COLON           reduce using rule 117 (pat -> pat_enum .)
    EQU             reduce using rule 117 (pat -> pat_enum .)
    SEMICOLON       reduce using rule 117 (pat -> pat_enum .)
    LPAREN          shift and go to state 60


state 36

    (109) pat -> WC .

    COMMA           reduce using rule 109 (pat -> WC .)
    RPAREN          reduce using rule 109 (pat -> WC .)
    OR              reduce using rule 109 (pat -> WC .)
    PIPE            reduce using rule 109 (pat -> WC .)
    RSQUIGBRACKET   reduce using rule 109 (pat -> WC .)
    RBRACKET        reduce using rule 109 (pat -> WC .)
    COLON           reduce using rule 109 (pat -> WC .)
    EQU             reduce using rule 109 (pat -> WC .)
    SEMICOLON       reduce using rule 109 (pat -> WC .)


state 37

    (116) pat -> pat_arr .

    COMMA           reduce using rule 116 (pat -> pat_arr .)
    RPAREN          reduce using rule 116 (pat -> pat_arr .)
    OR              reduce using rule 116 (pat -> pat_arr .)
    PIPE            reduce using rule 116 (pat -> pat_arr .)
    RSQUIGBRACKET   reduce using rule 116 (pat -> pat_arr .)
    RBRACKET        reduce using rule 116 (pat -> pat_arr .)
    COLON           reduce using rule 116 (pat -> pat_arr .)
    EQU             reduce using rule 116 (pat -> pat_arr .)
    SEMICOLON       reduce using rule 116 (pat -> pat_arr .)


state 38

    (148) fn_param -> pat . COLON type
    (149) fn_param -> pat . COLON id

    COLON           shift and go to state 61


state 39

    (140) p_lit -> LITCHAR .

    COMMA           reduce using rule 140 (p_lit -> LITCHAR .)
    RPAREN          reduce using rule 140 (p_lit -> LITCHAR .)
    ADD             reduce using rule 140 (p_lit -> LITCHAR .)
    SUB             reduce using rule 140 (p_lit -> LITCHAR .)
    MUL             reduce using rule 140 (p_lit -> LITCHAR .)
    DIV             reduce using rule 140 (p_lit -> LITCHAR .)
    MODOP           reduce using rule 140 (p_lit -> LITCHAR .)
    LESSTHAN        reduce using rule 140 (p_lit -> LITCHAR .)
    LESSTHANOREQUAL reduce using rule 140 (p_lit -> LITCHAR .)
    GREATERTHAN     reduce using rule 140 (p_lit -> LITCHAR .)
    GREATERTHANOREQUAL reduce using rule 140 (p_lit -> LITCHAR .)
    EQUALTO         reduce using rule 140 (p_lit -> LITCHAR .)
    NOTEQUAL        reduce using rule 140 (p_lit -> LITCHAR .)
    LOGICALOR       reduce using rule 140 (p_lit -> LITCHAR .)
    LOGICALAND      reduce using rule 140 (p_lit -> LITCHAR .)
    EQU             reduce using rule 140 (p_lit -> LITCHAR .)
    PLUSEQUAL       reduce using rule 140 (p_lit -> LITCHAR .)
    SUBEQUAL        reduce using rule 140 (p_lit -> LITCHAR .)
    DIVEQUAL        reduce using rule 140 (p_lit -> LITCHAR .)
    TIMESEQUAL      reduce using rule 140 (p_lit -> LITCHAR .)
    MODEQUAL        reduce using rule 140 (p_lit -> LITCHAR .)
    ANDEQUAL        reduce using rule 140 (p_lit -> LITCHAR .)
    OREQUAL         reduce using rule 140 (p_lit -> LITCHAR .)
    LBRACKET        reduce using rule 140 (p_lit -> LITCHAR .)
    PERIOD          reduce using rule 140 (p_lit -> LITCHAR .)
    SEMICOLON       reduce using rule 140 (p_lit -> LITCHAR .)
    RSQUIGBRACKET   reduce using rule 140 (p_lit -> LITCHAR .)
    LPAREN          reduce using rule 140 (p_lit -> LITCHAR .)
    LOOP            reduce using rule 140 (p_lit -> LITCHAR .)
    WHILE           reduce using rule 140 (p_lit -> LITCHAR .)
    BOX             reduce using rule 140 (p_lit -> LITCHAR .)
    IF              reduce using rule 140 (p_lit -> LITCHAR .)
    MATCH           reduce using rule 140 (p_lit -> LITCHAR .)
    ID              reduce using rule 140 (p_lit -> LITCHAR .)
    NOT             reduce using rule 140 (p_lit -> LITCHAR .)
    AND             reduce using rule 140 (p_lit -> LITCHAR .)
    LITDEC          reduce using rule 140 (p_lit -> LITCHAR .)
    LITCHAR         reduce using rule 140 (p_lit -> LITCHAR .)
    LITBOOL         reduce using rule 140 (p_lit -> LITCHAR .)
    LITSTRING       reduce using rule 140 (p_lit -> LITCHAR .)
    RBRACKET        reduce using rule 140 (p_lit -> LITCHAR .)
    COLON           reduce using rule 140 (p_lit -> LITCHAR .)
    OR              reduce using rule 140 (p_lit -> LITCHAR .)
    PIPE            reduce using rule 140 (p_lit -> LITCHAR .)


state 40

    (142) p_lit -> LITSTRING .

    COMMA           reduce using rule 142 (p_lit -> LITSTRING .)
    RPAREN          reduce using rule 142 (p_lit -> LITSTRING .)
    ADD             reduce using rule 142 (p_lit -> LITSTRING .)
    SUB             reduce using rule 142 (p_lit -> LITSTRING .)
    MUL             reduce using rule 142 (p_lit -> LITSTRING .)
    DIV             reduce using rule 142 (p_lit -> LITSTRING .)
    MODOP           reduce using rule 142 (p_lit -> LITSTRING .)
    LESSTHAN        reduce using rule 142 (p_lit -> LITSTRING .)
    LESSTHANOREQUAL reduce using rule 142 (p_lit -> LITSTRING .)
    GREATERTHAN     reduce using rule 142 (p_lit -> LITSTRING .)
    GREATERTHANOREQUAL reduce using rule 142 (p_lit -> LITSTRING .)
    EQUALTO         reduce using rule 142 (p_lit -> LITSTRING .)
    NOTEQUAL        reduce using rule 142 (p_lit -> LITSTRING .)
    LOGICALOR       reduce using rule 142 (p_lit -> LITSTRING .)
    LOGICALAND      reduce using rule 142 (p_lit -> LITSTRING .)
    EQU             reduce using rule 142 (p_lit -> LITSTRING .)
    PLUSEQUAL       reduce using rule 142 (p_lit -> LITSTRING .)
    SUBEQUAL        reduce using rule 142 (p_lit -> LITSTRING .)
    DIVEQUAL        reduce using rule 142 (p_lit -> LITSTRING .)
    TIMESEQUAL      reduce using rule 142 (p_lit -> LITSTRING .)
    MODEQUAL        reduce using rule 142 (p_lit -> LITSTRING .)
    ANDEQUAL        reduce using rule 142 (p_lit -> LITSTRING .)
    OREQUAL         reduce using rule 142 (p_lit -> LITSTRING .)
    LBRACKET        reduce using rule 142 (p_lit -> LITSTRING .)
    PERIOD          reduce using rule 142 (p_lit -> LITSTRING .)
    SEMICOLON       reduce using rule 142 (p_lit -> LITSTRING .)
    RSQUIGBRACKET   reduce using rule 142 (p_lit -> LITSTRING .)
    LPAREN          reduce using rule 142 (p_lit -> LITSTRING .)
    LOOP            reduce using rule 142 (p_lit -> LITSTRING .)
    WHILE           reduce using rule 142 (p_lit -> LITSTRING .)
    BOX             reduce using rule 142 (p_lit -> LITSTRING .)
    IF              reduce using rule 142 (p_lit -> LITSTRING .)
    MATCH           reduce using rule 142 (p_lit -> LITSTRING .)
    ID              reduce using rule 142 (p_lit -> LITSTRING .)
    NOT             reduce using rule 142 (p_lit -> LITSTRING .)
    AND             reduce using rule 142 (p_lit -> LITSTRING .)
    LITDEC          reduce using rule 142 (p_lit -> LITSTRING .)
    LITCHAR         reduce using rule 142 (p_lit -> LITSTRING .)
    LITBOOL         reduce using rule 142 (p_lit -> LITSTRING .)
    LITSTRING       reduce using rule 142 (p_lit -> LITSTRING .)
    RBRACKET        reduce using rule 142 (p_lit -> LITSTRING .)
    COLON           reduce using rule 142 (p_lit -> LITSTRING .)
    OR              reduce using rule 142 (p_lit -> LITSTRING .)
    PIPE            reduce using rule 142 (p_lit -> LITSTRING .)


state 41

    (119) pat_arr -> LBRACKET . pats RBRACKET
    (105) pats -> . pat COMMA pats
    (106) pats -> . pat
    (107) pat -> . p_lit
    (108) pat -> . LPAREN RPAREN
    (109) pat -> . WC
    (110) pat -> . SUB p_lit
    (111) pat -> . id
    (112) pat -> . REF id
    (113) pat -> . REF MUT id
    (114) pat -> . MUT id
    (115) pat -> . AND pat
    (116) pat -> . pat_arr
    (117) pat -> . pat_enum
    (118) pat -> . pat_struct
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (143) id -> . ID
    (119) pat_arr -> . LBRACKET pats RBRACKET
    (193) pat_enum -> . pat_enum LPAREN pats RPAREN
    (194) pat_enum -> . id CLASSACCESS id
    (120) pat_struct -> . id LSQUIGBRACKET pat_fields RSQUIGBRACKET

    LPAREN          shift and go to state 29
    WC              shift and go to state 36
    SUB             shift and go to state 34
    REF             shift and go to state 32
    MUT             shift and go to state 33
    AND             shift and go to state 30
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40
    ID              shift and go to state 10
    LBRACKET        shift and go to state 41

    pat_arr                        shift and go to state 37
    pat                            shift and go to state 63
    pats                           shift and go to state 62
    id                             shift and go to state 43
    pat_struct                     shift and go to state 42
    p_lit                          shift and go to state 26
    pat_enum                       shift and go to state 35

state 42

    (118) pat -> pat_struct .

    COMMA           reduce using rule 118 (pat -> pat_struct .)
    RPAREN          reduce using rule 118 (pat -> pat_struct .)
    OR              reduce using rule 118 (pat -> pat_struct .)
    PIPE            reduce using rule 118 (pat -> pat_struct .)
    RSQUIGBRACKET   reduce using rule 118 (pat -> pat_struct .)
    RBRACKET        reduce using rule 118 (pat -> pat_struct .)
    COLON           reduce using rule 118 (pat -> pat_struct .)
    EQU             reduce using rule 118 (pat -> pat_struct .)
    SEMICOLON       reduce using rule 118 (pat -> pat_struct .)


state 43

    (111) pat -> id .
    (194) pat_enum -> id . CLASSACCESS id
    (120) pat_struct -> id . LSQUIGBRACKET pat_fields RSQUIGBRACKET

    COMMA           reduce using rule 111 (pat -> id .)
    RPAREN          reduce using rule 111 (pat -> id .)
    OR              reduce using rule 111 (pat -> id .)
    PIPE            reduce using rule 111 (pat -> id .)
    RSQUIGBRACKET   reduce using rule 111 (pat -> id .)
    RBRACKET        reduce using rule 111 (pat -> id .)
    COLON           reduce using rule 111 (pat -> id .)
    EQU             reduce using rule 111 (pat -> id .)
    SEMICOLON       reduce using rule 111 (pat -> id .)
    CLASSACCESS     shift and go to state 65
    LSQUIGBRACKET   shift and go to state 64


state 44

    (179) field_defs -> field_def field_defs .

    RSQUIGBRACKET   reduce using rule 179 (field_defs -> field_def field_defs .)


state 45

    (181) field_def -> field_def COMMA .

    COMMA           reduce using rule 181 (field_def -> field_def COMMA .)
    ID              reduce using rule 181 (field_def -> field_def COMMA .)
    RSQUIGBRACKET   reduce using rule 181 (field_def -> field_def COMMA .)


state 46

    (182) field_def -> id COLON . type
    (152) type -> . BOOL
    (153) type -> . UEIGHT
    (154) type -> . USIXTEEN
    (155) type -> . UTHREETWO
    (156) type -> . USIXFOUR
    (157) type -> . IEIGHT
    (158) type -> . ISIXTEEN
    (159) type -> . ITHREETWO
    (160) type -> . ISIXFOUR
    (161) type -> . FTHREETWO
    (162) type -> . FSIXFOUR
    (163) type -> . CHAR
    (164) type -> . STR
    (165) type -> . box
    (166) type -> . NOT
    (167) type -> . type_ref
    (168) type -> . id
    (169) type -> . AND MUT type
    (170) type -> . type_arr
    (171) type -> . LPAREN RPAREN
    (172) type -> .
    (176) box -> . BOX LESSTHAN type GREATERTHAN
    (175) type_ref -> . AND type
    (143) id -> . ID
    (173) type_arr -> . LBRACKET type RBRACKET
    (174) type_arr -> . LBRACKET type SEMICOLON p_lit RBRACKET

  ! shift/reduce conflict for ID resolved as shift
    BOOL            shift and go to state 72
    UEIGHT          shift and go to state 70
    USIXTEEN        shift and go to state 79
    UTHREETWO       shift and go to state 83
    USIXFOUR        shift and go to state 85
    IEIGHT          shift and go to state 76
    ISIXTEEN        shift and go to state 88
    ITHREETWO       shift and go to state 74
    ISIXFOUR        shift and go to state 73
    FTHREETWO       shift and go to state 80
    FSIXFOUR        shift and go to state 75
    CHAR            shift and go to state 67
    STR             shift and go to state 81
    NOT             shift and go to state 86
    AND             shift and go to state 71
    LPAREN          shift and go to state 78
    COMMA           reduce using rule 172 (type -> .)
    RSQUIGBRACKET   reduce using rule 172 (type -> .)
    BOX             shift and go to state 69
    ID              shift and go to state 10
    LBRACKET        shift and go to state 87

  ! ID              [ reduce using rule 172 (type -> .) ]

    box                            shift and go to state 82
    type_ref                       shift and go to state 84
    id                             shift and go to state 66
    type                           shift and go to state 77
    type_arr                       shift and go to state 68

state 47

    (178) struct -> STRUCT id LSQUIGBRACKET field_defs RSQUIGBRACKET .

    FN              reduce using rule 178 (struct -> STRUCT id LSQUIGBRACKET field_defs RSQUIGBRACKET .)
    STRUCT          reduce using rule 178 (struct -> STRUCT id LSQUIGBRACKET field_defs RSQUIGBRACKET .)
    ENUM            reduce using rule 178 (struct -> STRUCT id LSQUIGBRACKET field_defs RSQUIGBRACKET .)
    $end            reduce using rule 178 (struct -> STRUCT id LSQUIGBRACKET field_defs RSQUIGBRACKET .)


state 48

    (196) enum_params -> enum_param enum_params .

    RSQUIGBRACKET   reduce using rule 196 (enum_params -> enum_param enum_params .)


state 49

    (198) enum_param -> enum_param COMMA .

    COMMA           reduce using rule 198 (enum_param -> enum_param COMMA .)
    ID              reduce using rule 198 (enum_param -> enum_param COMMA .)
    RSQUIGBRACKET   reduce using rule 198 (enum_param -> enum_param COMMA .)


state 50

    (195) enum -> ENUM id LSQUIGBRACKET enum_params RSQUIGBRACKET .

    FN              reduce using rule 195 (enum -> ENUM id LSQUIGBRACKET enum_params RSQUIGBRACKET .)
    STRUCT          reduce using rule 195 (enum -> ENUM id LSQUIGBRACKET enum_params RSQUIGBRACKET .)
    ENUM            reduce using rule 195 (enum -> ENUM id LSQUIGBRACKET enum_params RSQUIGBRACKET .)
    $end            reduce using rule 195 (enum -> ENUM id LSQUIGBRACKET enum_params RSQUIGBRACKET .)


state 51

    (199) enum_param -> id LPAREN . types RPAREN
    (150) types -> . type COMMA types
    (151) types -> . type
    (152) type -> . BOOL
    (153) type -> . UEIGHT
    (154) type -> . USIXTEEN
    (155) type -> . UTHREETWO
    (156) type -> . USIXFOUR
    (157) type -> . IEIGHT
    (158) type -> . ISIXTEEN
    (159) type -> . ITHREETWO
    (160) type -> . ISIXFOUR
    (161) type -> . FTHREETWO
    (162) type -> . FSIXFOUR
    (163) type -> . CHAR
    (164) type -> . STR
    (165) type -> . box
    (166) type -> . NOT
    (167) type -> . type_ref
    (168) type -> . id
    (169) type -> . AND MUT type
    (170) type -> . type_arr
    (171) type -> . LPAREN RPAREN
    (172) type -> .
    (176) box -> . BOX LESSTHAN type GREATERTHAN
    (175) type_ref -> . AND type
    (143) id -> . ID
    (173) type_arr -> . LBRACKET type RBRACKET
    (174) type_arr -> . LBRACKET type SEMICOLON p_lit RBRACKET

    BOOL            shift and go to state 72
    UEIGHT          shift and go to state 70
    USIXTEEN        shift and go to state 79
    UTHREETWO       shift and go to state 83
    USIXFOUR        shift and go to state 85
    IEIGHT          shift and go to state 76
    ISIXTEEN        shift and go to state 88
    ITHREETWO       shift and go to state 74
    ISIXFOUR        shift and go to state 73
    FTHREETWO       shift and go to state 80
    FSIXFOUR        shift and go to state 75
    CHAR            shift and go to state 67
    STR             shift and go to state 81
    NOT             shift and go to state 86
    AND             shift and go to state 71
    LPAREN          shift and go to state 78
    COMMA           reduce using rule 172 (type -> .)
    RPAREN          reduce using rule 172 (type -> .)
    BOX             shift and go to state 69
    ID              shift and go to state 10
    LBRACKET        shift and go to state 87

    box                            shift and go to state 82
    types                          shift and go to state 90
    type_ref                       shift and go to state 84
    id                             shift and go to state 66
    type                           shift and go to state 89
    type_arr                       shift and go to state 68

state 52

    (126) function -> FN id LPAREN fn_params_seq RPAREN . block
    (127) function -> FN id LPAREN fn_params_seq RPAREN . OBJECTACCESS type block
    (183) block -> . LSQUIGBRACKET stmts RSQUIGBRACKET

    OBJECTACCESS    shift and go to state 93
    LSQUIGBRACKET   shift and go to state 91

    block                          shift and go to state 92

state 53

    (146) fn_params -> fn_param COMMA . fn_params
    (146) fn_params -> . fn_param COMMA fn_params
    (147) fn_params -> . fn_param
    (148) fn_param -> . pat COLON type
    (149) fn_param -> . pat COLON id
    (107) pat -> . p_lit
    (108) pat -> . LPAREN RPAREN
    (109) pat -> . WC
    (110) pat -> . SUB p_lit
    (111) pat -> . id
    (112) pat -> . REF id
    (113) pat -> . REF MUT id
    (114) pat -> . MUT id
    (115) pat -> . AND pat
    (116) pat -> . pat_arr
    (117) pat -> . pat_enum
    (118) pat -> . pat_struct
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (143) id -> . ID
    (119) pat_arr -> . LBRACKET pats RBRACKET
    (193) pat_enum -> . pat_enum LPAREN pats RPAREN
    (194) pat_enum -> . id CLASSACCESS id
    (120) pat_struct -> . id LSQUIGBRACKET pat_fields RSQUIGBRACKET

    LPAREN          shift and go to state 29
    WC              shift and go to state 36
    SUB             shift and go to state 34
    REF             shift and go to state 32
    MUT             shift and go to state 33
    AND             shift and go to state 30
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40
    ID              shift and go to state 10
    LBRACKET        shift and go to state 41

    fn_params                      shift and go to state 94
    pat                            shift and go to state 38
    fn_param                       shift and go to state 28
    pat_arr                        shift and go to state 37
    id                             shift and go to state 43
    pat_struct                     shift and go to state 42
    p_lit                          shift and go to state 26
    pat_enum                       shift and go to state 35

state 54

    (108) pat -> LPAREN RPAREN .

    COMMA           reduce using rule 108 (pat -> LPAREN RPAREN .)
    RPAREN          reduce using rule 108 (pat -> LPAREN RPAREN .)
    OR              reduce using rule 108 (pat -> LPAREN RPAREN .)
    PIPE            reduce using rule 108 (pat -> LPAREN RPAREN .)
    RSQUIGBRACKET   reduce using rule 108 (pat -> LPAREN RPAREN .)
    RBRACKET        reduce using rule 108 (pat -> LPAREN RPAREN .)
    COLON           reduce using rule 108 (pat -> LPAREN RPAREN .)
    EQU             reduce using rule 108 (pat -> LPAREN RPAREN .)
    SEMICOLON       reduce using rule 108 (pat -> LPAREN RPAREN .)


state 55

    (115) pat -> AND pat .

    COMMA           reduce using rule 115 (pat -> AND pat .)
    RPAREN          reduce using rule 115 (pat -> AND pat .)
    OR              reduce using rule 115 (pat -> AND pat .)
    PIPE            reduce using rule 115 (pat -> AND pat .)
    RSQUIGBRACKET   reduce using rule 115 (pat -> AND pat .)
    RBRACKET        reduce using rule 115 (pat -> AND pat .)
    COLON           reduce using rule 115 (pat -> AND pat .)
    EQU             reduce using rule 115 (pat -> AND pat .)
    SEMICOLON       reduce using rule 115 (pat -> AND pat .)


state 56

    (112) pat -> REF id .

    COMMA           reduce using rule 112 (pat -> REF id .)
    RPAREN          reduce using rule 112 (pat -> REF id .)
    OR              reduce using rule 112 (pat -> REF id .)
    PIPE            reduce using rule 112 (pat -> REF id .)
    RSQUIGBRACKET   reduce using rule 112 (pat -> REF id .)
    RBRACKET        reduce using rule 112 (pat -> REF id .)
    COLON           reduce using rule 112 (pat -> REF id .)
    EQU             reduce using rule 112 (pat -> REF id .)
    SEMICOLON       reduce using rule 112 (pat -> REF id .)


state 57

    (113) pat -> REF MUT . id
    (143) id -> . ID

    ID              shift and go to state 10

    id                             shift and go to state 95

state 58

    (114) pat -> MUT id .

    COMMA           reduce using rule 114 (pat -> MUT id .)
    RPAREN          reduce using rule 114 (pat -> MUT id .)
    OR              reduce using rule 114 (pat -> MUT id .)
    PIPE            reduce using rule 114 (pat -> MUT id .)
    RSQUIGBRACKET   reduce using rule 114 (pat -> MUT id .)
    RBRACKET        reduce using rule 114 (pat -> MUT id .)
    COLON           reduce using rule 114 (pat -> MUT id .)
    EQU             reduce using rule 114 (pat -> MUT id .)
    SEMICOLON       reduce using rule 114 (pat -> MUT id .)


state 59

    (110) pat -> SUB p_lit .

    COMMA           reduce using rule 110 (pat -> SUB p_lit .)
    RPAREN          reduce using rule 110 (pat -> SUB p_lit .)
    OR              reduce using rule 110 (pat -> SUB p_lit .)
    PIPE            reduce using rule 110 (pat -> SUB p_lit .)
    RSQUIGBRACKET   reduce using rule 110 (pat -> SUB p_lit .)
    RBRACKET        reduce using rule 110 (pat -> SUB p_lit .)
    COLON           reduce using rule 110 (pat -> SUB p_lit .)
    EQU             reduce using rule 110 (pat -> SUB p_lit .)
    SEMICOLON       reduce using rule 110 (pat -> SUB p_lit .)


state 60

    (193) pat_enum -> pat_enum LPAREN . pats RPAREN
    (105) pats -> . pat COMMA pats
    (106) pats -> . pat
    (107) pat -> . p_lit
    (108) pat -> . LPAREN RPAREN
    (109) pat -> . WC
    (110) pat -> . SUB p_lit
    (111) pat -> . id
    (112) pat -> . REF id
    (113) pat -> . REF MUT id
    (114) pat -> . MUT id
    (115) pat -> . AND pat
    (116) pat -> . pat_arr
    (117) pat -> . pat_enum
    (118) pat -> . pat_struct
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (143) id -> . ID
    (119) pat_arr -> . LBRACKET pats RBRACKET
    (193) pat_enum -> . pat_enum LPAREN pats RPAREN
    (194) pat_enum -> . id CLASSACCESS id
    (120) pat_struct -> . id LSQUIGBRACKET pat_fields RSQUIGBRACKET

    LPAREN          shift and go to state 29
    WC              shift and go to state 36
    SUB             shift and go to state 34
    REF             shift and go to state 32
    MUT             shift and go to state 33
    AND             shift and go to state 30
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40
    ID              shift and go to state 10
    LBRACKET        shift and go to state 41

    pat_arr                        shift and go to state 37
    pat                            shift and go to state 63
    pats                           shift and go to state 96
    id                             shift and go to state 43
    pat_struct                     shift and go to state 42
    p_lit                          shift and go to state 26
    pat_enum                       shift and go to state 35

state 61

    (148) fn_param -> pat COLON . type
    (149) fn_param -> pat COLON . id
    (152) type -> . BOOL
    (153) type -> . UEIGHT
    (154) type -> . USIXTEEN
    (155) type -> . UTHREETWO
    (156) type -> . USIXFOUR
    (157) type -> . IEIGHT
    (158) type -> . ISIXTEEN
    (159) type -> . ITHREETWO
    (160) type -> . ISIXFOUR
    (161) type -> . FTHREETWO
    (162) type -> . FSIXFOUR
    (163) type -> . CHAR
    (164) type -> . STR
    (165) type -> . box
    (166) type -> . NOT
    (167) type -> . type_ref
    (168) type -> . id
    (169) type -> . AND MUT type
    (170) type -> . type_arr
    (171) type -> . LPAREN RPAREN
    (172) type -> .
    (143) id -> . ID
    (176) box -> . BOX LESSTHAN type GREATERTHAN
    (175) type_ref -> . AND type
    (173) type_arr -> . LBRACKET type RBRACKET
    (174) type_arr -> . LBRACKET type SEMICOLON p_lit RBRACKET

    BOOL            shift and go to state 72
    UEIGHT          shift and go to state 70
    USIXTEEN        shift and go to state 79
    UTHREETWO       shift and go to state 83
    USIXFOUR        shift and go to state 85
    IEIGHT          shift and go to state 76
    ISIXTEEN        shift and go to state 88
    ITHREETWO       shift and go to state 74
    ISIXFOUR        shift and go to state 73
    FTHREETWO       shift and go to state 80
    FSIXFOUR        shift and go to state 75
    CHAR            shift and go to state 67
    STR             shift and go to state 81
    NOT             shift and go to state 86
    AND             shift and go to state 71
    LPAREN          shift and go to state 78
    COMMA           reduce using rule 172 (type -> .)
    RPAREN          reduce using rule 172 (type -> .)
    ID              shift and go to state 10
    BOX             shift and go to state 69
    LBRACKET        shift and go to state 87

    box                            shift and go to state 82
    type_ref                       shift and go to state 84
    id                             shift and go to state 97
    type                           shift and go to state 98
    type_arr                       shift and go to state 68

state 62

    (119) pat_arr -> LBRACKET pats . RBRACKET

    RBRACKET        shift and go to state 99


state 63

    (105) pats -> pat . COMMA pats
    (106) pats -> pat .

    COMMA           shift and go to state 100
    RPAREN          reduce using rule 106 (pats -> pat .)
    RBRACKET        reduce using rule 106 (pats -> pat .)


state 64

    (120) pat_struct -> id LSQUIGBRACKET . pat_fields RSQUIGBRACKET
    (121) pat_fields -> . pat_field COMMA pat_fields
    (122) pat_fields -> . pat_field
    (123) pat_field -> . id COLON pat
    (143) id -> . ID

    ID              shift and go to state 10

    pat_fields                     shift and go to state 101
    id                             shift and go to state 103
    pat_field                      shift and go to state 102

state 65

    (194) pat_enum -> id CLASSACCESS . id
    (143) id -> . ID

    ID              shift and go to state 10

    id                             shift and go to state 104

state 66

    (168) type -> id .

    LSQUIGBRACKET   reduce using rule 168 (type -> id .)
    COMMA           reduce using rule 168 (type -> id .)
    ID              reduce using rule 168 (type -> id .)
    RSQUIGBRACKET   reduce using rule 168 (type -> id .)
    RPAREN          reduce using rule 168 (type -> id .)
    RBRACKET        reduce using rule 168 (type -> id .)
    SEMICOLON       reduce using rule 168 (type -> id .)
    GREATERTHAN     reduce using rule 168 (type -> id .)
    EQU             reduce using rule 168 (type -> id .)


state 67

    (163) type -> CHAR .

    LSQUIGBRACKET   reduce using rule 163 (type -> CHAR .)
    COMMA           reduce using rule 163 (type -> CHAR .)
    ID              reduce using rule 163 (type -> CHAR .)
    RSQUIGBRACKET   reduce using rule 163 (type -> CHAR .)
    RPAREN          reduce using rule 163 (type -> CHAR .)
    RBRACKET        reduce using rule 163 (type -> CHAR .)
    SEMICOLON       reduce using rule 163 (type -> CHAR .)
    GREATERTHAN     reduce using rule 163 (type -> CHAR .)
    EQU             reduce using rule 163 (type -> CHAR .)


state 68

    (170) type -> type_arr .

    LSQUIGBRACKET   reduce using rule 170 (type -> type_arr .)
    COMMA           reduce using rule 170 (type -> type_arr .)
    ID              reduce using rule 170 (type -> type_arr .)
    RSQUIGBRACKET   reduce using rule 170 (type -> type_arr .)
    RPAREN          reduce using rule 170 (type -> type_arr .)
    RBRACKET        reduce using rule 170 (type -> type_arr .)
    SEMICOLON       reduce using rule 170 (type -> type_arr .)
    GREATERTHAN     reduce using rule 170 (type -> type_arr .)
    EQU             reduce using rule 170 (type -> type_arr .)


state 69

    (176) box -> BOX . LESSTHAN type GREATERTHAN

    LESSTHAN        shift and go to state 105


state 70

    (153) type -> UEIGHT .

    LSQUIGBRACKET   reduce using rule 153 (type -> UEIGHT .)
    COMMA           reduce using rule 153 (type -> UEIGHT .)
    ID              reduce using rule 153 (type -> UEIGHT .)
    RSQUIGBRACKET   reduce using rule 153 (type -> UEIGHT .)
    RPAREN          reduce using rule 153 (type -> UEIGHT .)
    RBRACKET        reduce using rule 153 (type -> UEIGHT .)
    SEMICOLON       reduce using rule 153 (type -> UEIGHT .)
    GREATERTHAN     reduce using rule 153 (type -> UEIGHT .)
    EQU             reduce using rule 153 (type -> UEIGHT .)


state 71

    (169) type -> AND . MUT type
    (175) type_ref -> AND . type
    (152) type -> . BOOL
    (153) type -> . UEIGHT
    (154) type -> . USIXTEEN
    (155) type -> . UTHREETWO
    (156) type -> . USIXFOUR
    (157) type -> . IEIGHT
    (158) type -> . ISIXTEEN
    (159) type -> . ITHREETWO
    (160) type -> . ISIXFOUR
    (161) type -> . FTHREETWO
    (162) type -> . FSIXFOUR
    (163) type -> . CHAR
    (164) type -> . STR
    (165) type -> . box
    (166) type -> . NOT
    (167) type -> . type_ref
    (168) type -> . id
    (169) type -> . AND MUT type
    (170) type -> . type_arr
    (171) type -> . LPAREN RPAREN
    (172) type -> .
    (176) box -> . BOX LESSTHAN type GREATERTHAN
    (175) type_ref -> . AND type
    (143) id -> . ID
    (173) type_arr -> . LBRACKET type RBRACKET
    (174) type_arr -> . LBRACKET type SEMICOLON p_lit RBRACKET

  ! shift/reduce conflict for ID resolved as shift
    MUT             shift and go to state 106
    BOOL            shift and go to state 72
    UEIGHT          shift and go to state 70
    USIXTEEN        shift and go to state 79
    UTHREETWO       shift and go to state 83
    USIXFOUR        shift and go to state 85
    IEIGHT          shift and go to state 76
    ISIXTEEN        shift and go to state 88
    ITHREETWO       shift and go to state 74
    ISIXFOUR        shift and go to state 73
    FTHREETWO       shift and go to state 80
    FSIXFOUR        shift and go to state 75
    CHAR            shift and go to state 67
    STR             shift and go to state 81
    NOT             shift and go to state 86
    AND             shift and go to state 71
    LPAREN          shift and go to state 78
    COMMA           reduce using rule 172 (type -> .)
    RSQUIGBRACKET   reduce using rule 172 (type -> .)
    RPAREN          reduce using rule 172 (type -> .)
    RBRACKET        reduce using rule 172 (type -> .)
    SEMICOLON       reduce using rule 172 (type -> .)
    LSQUIGBRACKET   reduce using rule 172 (type -> .)
    GREATERTHAN     reduce using rule 172 (type -> .)
    EQU             reduce using rule 172 (type -> .)
    BOX             shift and go to state 69
    ID              shift and go to state 10
    LBRACKET        shift and go to state 87

  ! ID              [ reduce using rule 172 (type -> .) ]

    box                            shift and go to state 82
    type_ref                       shift and go to state 84
    type                           shift and go to state 107
    id                             shift and go to state 66
    type_arr                       shift and go to state 68

state 72

    (152) type -> BOOL .

    LSQUIGBRACKET   reduce using rule 152 (type -> BOOL .)
    COMMA           reduce using rule 152 (type -> BOOL .)
    ID              reduce using rule 152 (type -> BOOL .)
    RSQUIGBRACKET   reduce using rule 152 (type -> BOOL .)
    RPAREN          reduce using rule 152 (type -> BOOL .)
    RBRACKET        reduce using rule 152 (type -> BOOL .)
    SEMICOLON       reduce using rule 152 (type -> BOOL .)
    GREATERTHAN     reduce using rule 152 (type -> BOOL .)
    EQU             reduce using rule 152 (type -> BOOL .)


state 73

    (160) type -> ISIXFOUR .

    LSQUIGBRACKET   reduce using rule 160 (type -> ISIXFOUR .)
    COMMA           reduce using rule 160 (type -> ISIXFOUR .)
    ID              reduce using rule 160 (type -> ISIXFOUR .)
    RSQUIGBRACKET   reduce using rule 160 (type -> ISIXFOUR .)
    RPAREN          reduce using rule 160 (type -> ISIXFOUR .)
    RBRACKET        reduce using rule 160 (type -> ISIXFOUR .)
    SEMICOLON       reduce using rule 160 (type -> ISIXFOUR .)
    GREATERTHAN     reduce using rule 160 (type -> ISIXFOUR .)
    EQU             reduce using rule 160 (type -> ISIXFOUR .)


state 74

    (159) type -> ITHREETWO .

    LSQUIGBRACKET   reduce using rule 159 (type -> ITHREETWO .)
    COMMA           reduce using rule 159 (type -> ITHREETWO .)
    ID              reduce using rule 159 (type -> ITHREETWO .)
    RSQUIGBRACKET   reduce using rule 159 (type -> ITHREETWO .)
    RPAREN          reduce using rule 159 (type -> ITHREETWO .)
    RBRACKET        reduce using rule 159 (type -> ITHREETWO .)
    SEMICOLON       reduce using rule 159 (type -> ITHREETWO .)
    GREATERTHAN     reduce using rule 159 (type -> ITHREETWO .)
    EQU             reduce using rule 159 (type -> ITHREETWO .)


state 75

    (162) type -> FSIXFOUR .

    LSQUIGBRACKET   reduce using rule 162 (type -> FSIXFOUR .)
    COMMA           reduce using rule 162 (type -> FSIXFOUR .)
    ID              reduce using rule 162 (type -> FSIXFOUR .)
    RSQUIGBRACKET   reduce using rule 162 (type -> FSIXFOUR .)
    RPAREN          reduce using rule 162 (type -> FSIXFOUR .)
    RBRACKET        reduce using rule 162 (type -> FSIXFOUR .)
    SEMICOLON       reduce using rule 162 (type -> FSIXFOUR .)
    GREATERTHAN     reduce using rule 162 (type -> FSIXFOUR .)
    EQU             reduce using rule 162 (type -> FSIXFOUR .)


state 76

    (157) type -> IEIGHT .

    LSQUIGBRACKET   reduce using rule 157 (type -> IEIGHT .)
    COMMA           reduce using rule 157 (type -> IEIGHT .)
    ID              reduce using rule 157 (type -> IEIGHT .)
    RSQUIGBRACKET   reduce using rule 157 (type -> IEIGHT .)
    RPAREN          reduce using rule 157 (type -> IEIGHT .)
    RBRACKET        reduce using rule 157 (type -> IEIGHT .)
    SEMICOLON       reduce using rule 157 (type -> IEIGHT .)
    GREATERTHAN     reduce using rule 157 (type -> IEIGHT .)
    EQU             reduce using rule 157 (type -> IEIGHT .)


state 77

    (182) field_def -> id COLON type .

    COMMA           reduce using rule 182 (field_def -> id COLON type .)
    ID              reduce using rule 182 (field_def -> id COLON type .)
    RSQUIGBRACKET   reduce using rule 182 (field_def -> id COLON type .)


state 78

    (171) type -> LPAREN . RPAREN

    RPAREN          shift and go to state 108


state 79

    (154) type -> USIXTEEN .

    LSQUIGBRACKET   reduce using rule 154 (type -> USIXTEEN .)
    COMMA           reduce using rule 154 (type -> USIXTEEN .)
    ID              reduce using rule 154 (type -> USIXTEEN .)
    RSQUIGBRACKET   reduce using rule 154 (type -> USIXTEEN .)
    RPAREN          reduce using rule 154 (type -> USIXTEEN .)
    RBRACKET        reduce using rule 154 (type -> USIXTEEN .)
    SEMICOLON       reduce using rule 154 (type -> USIXTEEN .)
    GREATERTHAN     reduce using rule 154 (type -> USIXTEEN .)
    EQU             reduce using rule 154 (type -> USIXTEEN .)


state 80

    (161) type -> FTHREETWO .

    LSQUIGBRACKET   reduce using rule 161 (type -> FTHREETWO .)
    COMMA           reduce using rule 161 (type -> FTHREETWO .)
    ID              reduce using rule 161 (type -> FTHREETWO .)
    RSQUIGBRACKET   reduce using rule 161 (type -> FTHREETWO .)
    RPAREN          reduce using rule 161 (type -> FTHREETWO .)
    RBRACKET        reduce using rule 161 (type -> FTHREETWO .)
    SEMICOLON       reduce using rule 161 (type -> FTHREETWO .)
    GREATERTHAN     reduce using rule 161 (type -> FTHREETWO .)
    EQU             reduce using rule 161 (type -> FTHREETWO .)


state 81

    (164) type -> STR .

    LSQUIGBRACKET   reduce using rule 164 (type -> STR .)
    COMMA           reduce using rule 164 (type -> STR .)
    ID              reduce using rule 164 (type -> STR .)
    RSQUIGBRACKET   reduce using rule 164 (type -> STR .)
    RPAREN          reduce using rule 164 (type -> STR .)
    RBRACKET        reduce using rule 164 (type -> STR .)
    SEMICOLON       reduce using rule 164 (type -> STR .)
    GREATERTHAN     reduce using rule 164 (type -> STR .)
    EQU             reduce using rule 164 (type -> STR .)


state 82

    (165) type -> box .

    LSQUIGBRACKET   reduce using rule 165 (type -> box .)
    COMMA           reduce using rule 165 (type -> box .)
    ID              reduce using rule 165 (type -> box .)
    RSQUIGBRACKET   reduce using rule 165 (type -> box .)
    RPAREN          reduce using rule 165 (type -> box .)
    RBRACKET        reduce using rule 165 (type -> box .)
    SEMICOLON       reduce using rule 165 (type -> box .)
    GREATERTHAN     reduce using rule 165 (type -> box .)
    EQU             reduce using rule 165 (type -> box .)


state 83

    (155) type -> UTHREETWO .

    LSQUIGBRACKET   reduce using rule 155 (type -> UTHREETWO .)
    COMMA           reduce using rule 155 (type -> UTHREETWO .)
    ID              reduce using rule 155 (type -> UTHREETWO .)
    RSQUIGBRACKET   reduce using rule 155 (type -> UTHREETWO .)
    RPAREN          reduce using rule 155 (type -> UTHREETWO .)
    RBRACKET        reduce using rule 155 (type -> UTHREETWO .)
    SEMICOLON       reduce using rule 155 (type -> UTHREETWO .)
    GREATERTHAN     reduce using rule 155 (type -> UTHREETWO .)
    EQU             reduce using rule 155 (type -> UTHREETWO .)


state 84

    (167) type -> type_ref .

    LSQUIGBRACKET   reduce using rule 167 (type -> type_ref .)
    COMMA           reduce using rule 167 (type -> type_ref .)
    ID              reduce using rule 167 (type -> type_ref .)
    RSQUIGBRACKET   reduce using rule 167 (type -> type_ref .)
    RPAREN          reduce using rule 167 (type -> type_ref .)
    RBRACKET        reduce using rule 167 (type -> type_ref .)
    SEMICOLON       reduce using rule 167 (type -> type_ref .)
    GREATERTHAN     reduce using rule 167 (type -> type_ref .)
    EQU             reduce using rule 167 (type -> type_ref .)


state 85

    (156) type -> USIXFOUR .

    LSQUIGBRACKET   reduce using rule 156 (type -> USIXFOUR .)
    COMMA           reduce using rule 156 (type -> USIXFOUR .)
    ID              reduce using rule 156 (type -> USIXFOUR .)
    RSQUIGBRACKET   reduce using rule 156 (type -> USIXFOUR .)
    RPAREN          reduce using rule 156 (type -> USIXFOUR .)
    RBRACKET        reduce using rule 156 (type -> USIXFOUR .)
    SEMICOLON       reduce using rule 156 (type -> USIXFOUR .)
    GREATERTHAN     reduce using rule 156 (type -> USIXFOUR .)
    EQU             reduce using rule 156 (type -> USIXFOUR .)


state 86

    (166) type -> NOT .

    LSQUIGBRACKET   reduce using rule 166 (type -> NOT .)
    COMMA           reduce using rule 166 (type -> NOT .)
    ID              reduce using rule 166 (type -> NOT .)
    RSQUIGBRACKET   reduce using rule 166 (type -> NOT .)
    RPAREN          reduce using rule 166 (type -> NOT .)
    RBRACKET        reduce using rule 166 (type -> NOT .)
    SEMICOLON       reduce using rule 166 (type -> NOT .)
    GREATERTHAN     reduce using rule 166 (type -> NOT .)
    EQU             reduce using rule 166 (type -> NOT .)


state 87

    (173) type_arr -> LBRACKET . type RBRACKET
    (174) type_arr -> LBRACKET . type SEMICOLON p_lit RBRACKET
    (152) type -> . BOOL
    (153) type -> . UEIGHT
    (154) type -> . USIXTEEN
    (155) type -> . UTHREETWO
    (156) type -> . USIXFOUR
    (157) type -> . IEIGHT
    (158) type -> . ISIXTEEN
    (159) type -> . ITHREETWO
    (160) type -> . ISIXFOUR
    (161) type -> . FTHREETWO
    (162) type -> . FSIXFOUR
    (163) type -> . CHAR
    (164) type -> . STR
    (165) type -> . box
    (166) type -> . NOT
    (167) type -> . type_ref
    (168) type -> . id
    (169) type -> . AND MUT type
    (170) type -> . type_arr
    (171) type -> . LPAREN RPAREN
    (172) type -> .
    (176) box -> . BOX LESSTHAN type GREATERTHAN
    (175) type_ref -> . AND type
    (143) id -> . ID
    (173) type_arr -> . LBRACKET type RBRACKET
    (174) type_arr -> . LBRACKET type SEMICOLON p_lit RBRACKET

    BOOL            shift and go to state 72
    UEIGHT          shift and go to state 70
    USIXTEEN        shift and go to state 79
    UTHREETWO       shift and go to state 83
    USIXFOUR        shift and go to state 85
    IEIGHT          shift and go to state 76
    ISIXTEEN        shift and go to state 88
    ITHREETWO       shift and go to state 74
    ISIXFOUR        shift and go to state 73
    FTHREETWO       shift and go to state 80
    FSIXFOUR        shift and go to state 75
    CHAR            shift and go to state 67
    STR             shift and go to state 81
    NOT             shift and go to state 86
    AND             shift and go to state 71
    LPAREN          shift and go to state 78
    RBRACKET        reduce using rule 172 (type -> .)
    SEMICOLON       reduce using rule 172 (type -> .)
    BOX             shift and go to state 69
    ID              shift and go to state 10
    LBRACKET        shift and go to state 87

    box                            shift and go to state 82
    type_ref                       shift and go to state 84
    type                           shift and go to state 109
    id                             shift and go to state 66
    type_arr                       shift and go to state 68

state 88

    (158) type -> ISIXTEEN .

    LSQUIGBRACKET   reduce using rule 158 (type -> ISIXTEEN .)
    COMMA           reduce using rule 158 (type -> ISIXTEEN .)
    ID              reduce using rule 158 (type -> ISIXTEEN .)
    RSQUIGBRACKET   reduce using rule 158 (type -> ISIXTEEN .)
    RPAREN          reduce using rule 158 (type -> ISIXTEEN .)
    RBRACKET        reduce using rule 158 (type -> ISIXTEEN .)
    SEMICOLON       reduce using rule 158 (type -> ISIXTEEN .)
    GREATERTHAN     reduce using rule 158 (type -> ISIXTEEN .)
    EQU             reduce using rule 158 (type -> ISIXTEEN .)


state 89

    (150) types -> type . COMMA types
    (151) types -> type .

    COMMA           shift and go to state 110
    RPAREN          reduce using rule 151 (types -> type .)


state 90

    (199) enum_param -> id LPAREN types . RPAREN

    RPAREN          shift and go to state 111


state 91

    (183) block -> LSQUIGBRACKET . stmts RSQUIGBRACKET
    (8) stmts -> . stmt SEMICOLON stmts
    (9) stmts -> . stmt
    (10) stmts -> .
    (11) stmt -> . return
    (12) stmt -> . exp
    (13) stmt -> . let
    (14) stmt -> . function
    (184) return -> . RETURN
    (185) return -> . return exp
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (90) let -> . LET pat COLON type EQU exp
    (91) let -> . LET pat COLON type
    (92) let -> . LET pat EQU exp
    (93) let -> . LET pat
    (126) function -> . FN id LPAREN fn_params_seq RPAREN block
    (127) function -> . FN id LPAREN fn_params_seq RPAREN OBJECTACCESS type block
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! reduce/reduce conflict for RSQUIGBRACKET resolved using rule 10 (stmts -> .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    RSQUIGBRACKET   reduce using rule 10 (stmts -> .)
    RETURN          shift and go to state 120
    LPAREN          shift and go to state 121
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    SEMICOLON       reduce using rule 31 (exp -> .)
    LET             shift and go to state 118
    FN              shift and go to state 4
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]
  ! RSQUIGBRACKET   [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    arith3                         shift and go to state 161
    let                            shift and go to state 115
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    stmt                           shift and go to state 123
    match                          shift and go to state 124
    exp                            shift and go to state 151
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    return                         shift and go to state 132
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    mul                            shift and go to state 143
    function                       shift and go to state 135
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    loop                           shift and go to state 126
    gt                             shift and go to state 125
    stmts                          shift and go to state 144
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 92

    (126) function -> FN id LPAREN fn_params_seq RPAREN block .

    SEMICOLON       reduce using rule 126 (function -> FN id LPAREN fn_params_seq RPAREN block .)
    RSQUIGBRACKET   reduce using rule 126 (function -> FN id LPAREN fn_params_seq RPAREN block .)
    FN              reduce using rule 126 (function -> FN id LPAREN fn_params_seq RPAREN block .)
    STRUCT          reduce using rule 126 (function -> FN id LPAREN fn_params_seq RPAREN block .)
    ENUM            reduce using rule 126 (function -> FN id LPAREN fn_params_seq RPAREN block .)
    $end            reduce using rule 126 (function -> FN id LPAREN fn_params_seq RPAREN block .)


state 93

    (127) function -> FN id LPAREN fn_params_seq RPAREN OBJECTACCESS . type block
    (152) type -> . BOOL
    (153) type -> . UEIGHT
    (154) type -> . USIXTEEN
    (155) type -> . UTHREETWO
    (156) type -> . USIXFOUR
    (157) type -> . IEIGHT
    (158) type -> . ISIXTEEN
    (159) type -> . ITHREETWO
    (160) type -> . ISIXFOUR
    (161) type -> . FTHREETWO
    (162) type -> . FSIXFOUR
    (163) type -> . CHAR
    (164) type -> . STR
    (165) type -> . box
    (166) type -> . NOT
    (167) type -> . type_ref
    (168) type -> . id
    (169) type -> . AND MUT type
    (170) type -> . type_arr
    (171) type -> . LPAREN RPAREN
    (172) type -> .
    (176) box -> . BOX LESSTHAN type GREATERTHAN
    (175) type_ref -> . AND type
    (143) id -> . ID
    (173) type_arr -> . LBRACKET type RBRACKET
    (174) type_arr -> . LBRACKET type SEMICOLON p_lit RBRACKET

    BOOL            shift and go to state 72
    UEIGHT          shift and go to state 70
    USIXTEEN        shift and go to state 79
    UTHREETWO       shift and go to state 83
    USIXFOUR        shift and go to state 85
    IEIGHT          shift and go to state 76
    ISIXTEEN        shift and go to state 88
    ITHREETWO       shift and go to state 74
    ISIXFOUR        shift and go to state 73
    FTHREETWO       shift and go to state 80
    FSIXFOUR        shift and go to state 75
    CHAR            shift and go to state 67
    STR             shift and go to state 81
    NOT             shift and go to state 86
    AND             shift and go to state 71
    LPAREN          shift and go to state 78
    LSQUIGBRACKET   reduce using rule 172 (type -> .)
    BOX             shift and go to state 69
    ID              shift and go to state 10
    LBRACKET        shift and go to state 87

    type                           shift and go to state 171
    box                            shift and go to state 82
    type_ref                       shift and go to state 84
    id                             shift and go to state 66
    type_arr                       shift and go to state 68

state 94

    (146) fn_params -> fn_param COMMA fn_params .

    RPAREN          reduce using rule 146 (fn_params -> fn_param COMMA fn_params .)


state 95

    (113) pat -> REF MUT id .

    COMMA           reduce using rule 113 (pat -> REF MUT id .)
    RPAREN          reduce using rule 113 (pat -> REF MUT id .)
    OR              reduce using rule 113 (pat -> REF MUT id .)
    PIPE            reduce using rule 113 (pat -> REF MUT id .)
    RSQUIGBRACKET   reduce using rule 113 (pat -> REF MUT id .)
    RBRACKET        reduce using rule 113 (pat -> REF MUT id .)
    COLON           reduce using rule 113 (pat -> REF MUT id .)
    EQU             reduce using rule 113 (pat -> REF MUT id .)
    SEMICOLON       reduce using rule 113 (pat -> REF MUT id .)


state 96

    (193) pat_enum -> pat_enum LPAREN pats . RPAREN

    RPAREN          shift and go to state 172


state 97

    (149) fn_param -> pat COLON id .
    (168) type -> id .

  ! reduce/reduce conflict for COMMA resolved using rule 149 (fn_param -> pat COLON id .)
  ! reduce/reduce conflict for RPAREN resolved using rule 149 (fn_param -> pat COLON id .)
    COMMA           reduce using rule 149 (fn_param -> pat COLON id .)
    RPAREN          reduce using rule 149 (fn_param -> pat COLON id .)

  ! COMMA           [ reduce using rule 168 (type -> id .) ]
  ! RPAREN          [ reduce using rule 168 (type -> id .) ]


state 98

    (148) fn_param -> pat COLON type .

    COMMA           reduce using rule 148 (fn_param -> pat COLON type .)
    RPAREN          reduce using rule 148 (fn_param -> pat COLON type .)


state 99

    (119) pat_arr -> LBRACKET pats RBRACKET .

    COLON           reduce using rule 119 (pat_arr -> LBRACKET pats RBRACKET .)
    EQU             reduce using rule 119 (pat_arr -> LBRACKET pats RBRACKET .)
    SEMICOLON       reduce using rule 119 (pat_arr -> LBRACKET pats RBRACKET .)
    RSQUIGBRACKET   reduce using rule 119 (pat_arr -> LBRACKET pats RBRACKET .)
    COMMA           reduce using rule 119 (pat_arr -> LBRACKET pats RBRACKET .)
    RBRACKET        reduce using rule 119 (pat_arr -> LBRACKET pats RBRACKET .)
    RPAREN          reduce using rule 119 (pat_arr -> LBRACKET pats RBRACKET .)
    OR              reduce using rule 119 (pat_arr -> LBRACKET pats RBRACKET .)
    PIPE            reduce using rule 119 (pat_arr -> LBRACKET pats RBRACKET .)


state 100

    (105) pats -> pat COMMA . pats
    (105) pats -> . pat COMMA pats
    (106) pats -> . pat
    (107) pat -> . p_lit
    (108) pat -> . LPAREN RPAREN
    (109) pat -> . WC
    (110) pat -> . SUB p_lit
    (111) pat -> . id
    (112) pat -> . REF id
    (113) pat -> . REF MUT id
    (114) pat -> . MUT id
    (115) pat -> . AND pat
    (116) pat -> . pat_arr
    (117) pat -> . pat_enum
    (118) pat -> . pat_struct
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (143) id -> . ID
    (119) pat_arr -> . LBRACKET pats RBRACKET
    (193) pat_enum -> . pat_enum LPAREN pats RPAREN
    (194) pat_enum -> . id CLASSACCESS id
    (120) pat_struct -> . id LSQUIGBRACKET pat_fields RSQUIGBRACKET

    LPAREN          shift and go to state 29
    WC              shift and go to state 36
    SUB             shift and go to state 34
    REF             shift and go to state 32
    MUT             shift and go to state 33
    AND             shift and go to state 30
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40
    ID              shift and go to state 10
    LBRACKET        shift and go to state 41

    pat_arr                        shift and go to state 37
    pat                            shift and go to state 63
    pats                           shift and go to state 173
    id                             shift and go to state 43
    pat_struct                     shift and go to state 42
    p_lit                          shift and go to state 26
    pat_enum                       shift and go to state 35

state 101

    (120) pat_struct -> id LSQUIGBRACKET pat_fields . RSQUIGBRACKET

    RSQUIGBRACKET   shift and go to state 174


state 102

    (121) pat_fields -> pat_field . COMMA pat_fields
    (122) pat_fields -> pat_field .

    COMMA           shift and go to state 175
    RSQUIGBRACKET   reduce using rule 122 (pat_fields -> pat_field .)


state 103

    (123) pat_field -> id . COLON pat

    COLON           shift and go to state 176


state 104

    (194) pat_enum -> id CLASSACCESS id .

    LPAREN          reduce using rule 194 (pat_enum -> id CLASSACCESS id .)
    COMMA           reduce using rule 194 (pat_enum -> id CLASSACCESS id .)
    RSQUIGBRACKET   reduce using rule 194 (pat_enum -> id CLASSACCESS id .)
    COLON           reduce using rule 194 (pat_enum -> id CLASSACCESS id .)
    RBRACKET        reduce using rule 194 (pat_enum -> id CLASSACCESS id .)
    RPAREN          reduce using rule 194 (pat_enum -> id CLASSACCESS id .)
    EQU             reduce using rule 194 (pat_enum -> id CLASSACCESS id .)
    SEMICOLON       reduce using rule 194 (pat_enum -> id CLASSACCESS id .)
    OR              reduce using rule 194 (pat_enum -> id CLASSACCESS id .)
    PIPE            reduce using rule 194 (pat_enum -> id CLASSACCESS id .)


state 105

    (176) box -> BOX LESSTHAN . type GREATERTHAN
    (152) type -> . BOOL
    (153) type -> . UEIGHT
    (154) type -> . USIXTEEN
    (155) type -> . UTHREETWO
    (156) type -> . USIXFOUR
    (157) type -> . IEIGHT
    (158) type -> . ISIXTEEN
    (159) type -> . ITHREETWO
    (160) type -> . ISIXFOUR
    (161) type -> . FTHREETWO
    (162) type -> . FSIXFOUR
    (163) type -> . CHAR
    (164) type -> . STR
    (165) type -> . box
    (166) type -> . NOT
    (167) type -> . type_ref
    (168) type -> . id
    (169) type -> . AND MUT type
    (170) type -> . type_arr
    (171) type -> . LPAREN RPAREN
    (172) type -> .
    (176) box -> . BOX LESSTHAN type GREATERTHAN
    (175) type_ref -> . AND type
    (143) id -> . ID
    (173) type_arr -> . LBRACKET type RBRACKET
    (174) type_arr -> . LBRACKET type SEMICOLON p_lit RBRACKET

    BOOL            shift and go to state 72
    UEIGHT          shift and go to state 70
    USIXTEEN        shift and go to state 79
    UTHREETWO       shift and go to state 83
    USIXFOUR        shift and go to state 85
    IEIGHT          shift and go to state 76
    ISIXTEEN        shift and go to state 88
    ITHREETWO       shift and go to state 74
    ISIXFOUR        shift and go to state 73
    FTHREETWO       shift and go to state 80
    FSIXFOUR        shift and go to state 75
    CHAR            shift and go to state 67
    STR             shift and go to state 81
    NOT             shift and go to state 86
    AND             shift and go to state 71
    LPAREN          shift and go to state 78
    GREATERTHAN     reduce using rule 172 (type -> .)
    BOX             shift and go to state 69
    ID              shift and go to state 10
    LBRACKET        shift and go to state 87

    box                            shift and go to state 82
    type_ref                       shift and go to state 84
    type                           shift and go to state 177
    id                             shift and go to state 66
    type_arr                       shift and go to state 68

state 106

    (169) type -> AND MUT . type
    (152) type -> . BOOL
    (153) type -> . UEIGHT
    (154) type -> . USIXTEEN
    (155) type -> . UTHREETWO
    (156) type -> . USIXFOUR
    (157) type -> . IEIGHT
    (158) type -> . ISIXTEEN
    (159) type -> . ITHREETWO
    (160) type -> . ISIXFOUR
    (161) type -> . FTHREETWO
    (162) type -> . FSIXFOUR
    (163) type -> . CHAR
    (164) type -> . STR
    (165) type -> . box
    (166) type -> . NOT
    (167) type -> . type_ref
    (168) type -> . id
    (169) type -> . AND MUT type
    (170) type -> . type_arr
    (171) type -> . LPAREN RPAREN
    (172) type -> .
    (176) box -> . BOX LESSTHAN type GREATERTHAN
    (175) type_ref -> . AND type
    (143) id -> . ID
    (173) type_arr -> . LBRACKET type RBRACKET
    (174) type_arr -> . LBRACKET type SEMICOLON p_lit RBRACKET

  ! shift/reduce conflict for ID resolved as shift
    BOOL            shift and go to state 72
    UEIGHT          shift and go to state 70
    USIXTEEN        shift and go to state 79
    UTHREETWO       shift and go to state 83
    USIXFOUR        shift and go to state 85
    IEIGHT          shift and go to state 76
    ISIXTEEN        shift and go to state 88
    ITHREETWO       shift and go to state 74
    ISIXFOUR        shift and go to state 73
    FTHREETWO       shift and go to state 80
    FSIXFOUR        shift and go to state 75
    CHAR            shift and go to state 67
    STR             shift and go to state 81
    NOT             shift and go to state 86
    AND             shift and go to state 71
    LPAREN          shift and go to state 78
    COMMA           reduce using rule 172 (type -> .)
    RSQUIGBRACKET   reduce using rule 172 (type -> .)
    RPAREN          reduce using rule 172 (type -> .)
    RBRACKET        reduce using rule 172 (type -> .)
    SEMICOLON       reduce using rule 172 (type -> .)
    LSQUIGBRACKET   reduce using rule 172 (type -> .)
    GREATERTHAN     reduce using rule 172 (type -> .)
    EQU             reduce using rule 172 (type -> .)
    BOX             shift and go to state 69
    ID              shift and go to state 10
    LBRACKET        shift and go to state 87

  ! ID              [ reduce using rule 172 (type -> .) ]

    box                            shift and go to state 82
    type_ref                       shift and go to state 84
    type                           shift and go to state 178
    id                             shift and go to state 66
    type_arr                       shift and go to state 68

state 107

    (175) type_ref -> AND type .

    EQU             reduce using rule 175 (type_ref -> AND type .)
    SEMICOLON       reduce using rule 175 (type_ref -> AND type .)
    RSQUIGBRACKET   reduce using rule 175 (type_ref -> AND type .)
    COMMA           reduce using rule 175 (type_ref -> AND type .)
    RPAREN          reduce using rule 175 (type_ref -> AND type .)
    ID              reduce using rule 175 (type_ref -> AND type .)
    RBRACKET        reduce using rule 175 (type_ref -> AND type .)
    LSQUIGBRACKET   reduce using rule 175 (type_ref -> AND type .)
    GREATERTHAN     reduce using rule 175 (type_ref -> AND type .)


state 108

    (171) type -> LPAREN RPAREN .

    LSQUIGBRACKET   reduce using rule 171 (type -> LPAREN RPAREN .)
    COMMA           reduce using rule 171 (type -> LPAREN RPAREN .)
    ID              reduce using rule 171 (type -> LPAREN RPAREN .)
    RSQUIGBRACKET   reduce using rule 171 (type -> LPAREN RPAREN .)
    RPAREN          reduce using rule 171 (type -> LPAREN RPAREN .)
    RBRACKET        reduce using rule 171 (type -> LPAREN RPAREN .)
    SEMICOLON       reduce using rule 171 (type -> LPAREN RPAREN .)
    GREATERTHAN     reduce using rule 171 (type -> LPAREN RPAREN .)
    EQU             reduce using rule 171 (type -> LPAREN RPAREN .)


state 109

    (173) type_arr -> LBRACKET type . RBRACKET
    (174) type_arr -> LBRACKET type . SEMICOLON p_lit RBRACKET

    RBRACKET        shift and go to state 180
    SEMICOLON       shift and go to state 179


state 110

    (150) types -> type COMMA . types
    (150) types -> . type COMMA types
    (151) types -> . type
    (152) type -> . BOOL
    (153) type -> . UEIGHT
    (154) type -> . USIXTEEN
    (155) type -> . UTHREETWO
    (156) type -> . USIXFOUR
    (157) type -> . IEIGHT
    (158) type -> . ISIXTEEN
    (159) type -> . ITHREETWO
    (160) type -> . ISIXFOUR
    (161) type -> . FTHREETWO
    (162) type -> . FSIXFOUR
    (163) type -> . CHAR
    (164) type -> . STR
    (165) type -> . box
    (166) type -> . NOT
    (167) type -> . type_ref
    (168) type -> . id
    (169) type -> . AND MUT type
    (170) type -> . type_arr
    (171) type -> . LPAREN RPAREN
    (172) type -> .
    (176) box -> . BOX LESSTHAN type GREATERTHAN
    (175) type_ref -> . AND type
    (143) id -> . ID
    (173) type_arr -> . LBRACKET type RBRACKET
    (174) type_arr -> . LBRACKET type SEMICOLON p_lit RBRACKET

    BOOL            shift and go to state 72
    UEIGHT          shift and go to state 70
    USIXTEEN        shift and go to state 79
    UTHREETWO       shift and go to state 83
    USIXFOUR        shift and go to state 85
    IEIGHT          shift and go to state 76
    ISIXTEEN        shift and go to state 88
    ITHREETWO       shift and go to state 74
    ISIXFOUR        shift and go to state 73
    FTHREETWO       shift and go to state 80
    FSIXFOUR        shift and go to state 75
    CHAR            shift and go to state 67
    STR             shift and go to state 81
    NOT             shift and go to state 86
    AND             shift and go to state 71
    LPAREN          shift and go to state 78
    COMMA           reduce using rule 172 (type -> .)
    RPAREN          reduce using rule 172 (type -> .)
    BOX             shift and go to state 69
    ID              shift and go to state 10
    LBRACKET        shift and go to state 87

    box                            shift and go to state 82
    types                          shift and go to state 181
    type_ref                       shift and go to state 84
    id                             shift and go to state 66
    type                           shift and go to state 89
    type_arr                       shift and go to state 68

state 111

    (199) enum_param -> id LPAREN types RPAREN .

    COMMA           reduce using rule 199 (enum_param -> id LPAREN types RPAREN .)
    ID              reduce using rule 199 (enum_param -> id LPAREN types RPAREN .)
    RSQUIGBRACKET   reduce using rule 199 (enum_param -> id LPAREN types RPAREN .)


state 112

    (26) exp -> arg_struct .

    RPAREN          reduce using rule 26 (exp -> arg_struct .)
    EQU             reduce using rule 26 (exp -> arg_struct .)
    PLUSEQUAL       reduce using rule 26 (exp -> arg_struct .)
    SUBEQUAL        reduce using rule 26 (exp -> arg_struct .)
    DIVEQUAL        reduce using rule 26 (exp -> arg_struct .)
    TIMESEQUAL      reduce using rule 26 (exp -> arg_struct .)
    MODEQUAL        reduce using rule 26 (exp -> arg_struct .)
    ANDEQUAL        reduce using rule 26 (exp -> arg_struct .)
    OREQUAL         reduce using rule 26 (exp -> arg_struct .)
    LBRACKET        reduce using rule 26 (exp -> arg_struct .)
    PERIOD          reduce using rule 26 (exp -> arg_struct .)
    SEMICOLON       reduce using rule 26 (exp -> arg_struct .)
    RSQUIGBRACKET   reduce using rule 26 (exp -> arg_struct .)
    LPAREN          reduce using rule 26 (exp -> arg_struct .)
    LOOP            reduce using rule 26 (exp -> arg_struct .)
    WHILE           reduce using rule 26 (exp -> arg_struct .)
    BOX             reduce using rule 26 (exp -> arg_struct .)
    IF              reduce using rule 26 (exp -> arg_struct .)
    MATCH           reduce using rule 26 (exp -> arg_struct .)
    ID              reduce using rule 26 (exp -> arg_struct .)
    SUB             reduce using rule 26 (exp -> arg_struct .)
    NOT             reduce using rule 26 (exp -> arg_struct .)
    AND             reduce using rule 26 (exp -> arg_struct .)
    MUL             reduce using rule 26 (exp -> arg_struct .)
    LITDEC          reduce using rule 26 (exp -> arg_struct .)
    LITCHAR         reduce using rule 26 (exp -> arg_struct .)
    LITBOOL         reduce using rule 26 (exp -> arg_struct .)
    LITSTRING       reduce using rule 26 (exp -> arg_struct .)
    COMMA           reduce using rule 26 (exp -> arg_struct .)
    RBRACKET        reduce using rule 26 (exp -> arg_struct .)


state 113

    (36) arith2 -> div .

    ADD             reduce using rule 36 (arith2 -> div .)
    SUB             reduce using rule 36 (arith2 -> div .)
    MUL             reduce using rule 36 (arith2 -> div .)
    DIV             reduce using rule 36 (arith2 -> div .)
    MODOP           reduce using rule 36 (arith2 -> div .)
    LESSTHAN        reduce using rule 36 (arith2 -> div .)
    LESSTHANOREQUAL reduce using rule 36 (arith2 -> div .)
    GREATERTHAN     reduce using rule 36 (arith2 -> div .)
    GREATERTHANOREQUAL reduce using rule 36 (arith2 -> div .)
    EQUALTO         reduce using rule 36 (arith2 -> div .)
    NOTEQUAL        reduce using rule 36 (arith2 -> div .)
    LOGICALOR       reduce using rule 36 (arith2 -> div .)
    LOGICALAND      reduce using rule 36 (arith2 -> div .)
    EQU             reduce using rule 36 (arith2 -> div .)
    PLUSEQUAL       reduce using rule 36 (arith2 -> div .)
    SUBEQUAL        reduce using rule 36 (arith2 -> div .)
    DIVEQUAL        reduce using rule 36 (arith2 -> div .)
    TIMESEQUAL      reduce using rule 36 (arith2 -> div .)
    MODEQUAL        reduce using rule 36 (arith2 -> div .)
    ANDEQUAL        reduce using rule 36 (arith2 -> div .)
    OREQUAL         reduce using rule 36 (arith2 -> div .)
    LBRACKET        reduce using rule 36 (arith2 -> div .)
    PERIOD          reduce using rule 36 (arith2 -> div .)
    SEMICOLON       reduce using rule 36 (arith2 -> div .)
    RSQUIGBRACKET   reduce using rule 36 (arith2 -> div .)
    RPAREN          reduce using rule 36 (arith2 -> div .)
    LPAREN          reduce using rule 36 (arith2 -> div .)
    LOOP            reduce using rule 36 (arith2 -> div .)
    WHILE           reduce using rule 36 (arith2 -> div .)
    BOX             reduce using rule 36 (arith2 -> div .)
    IF              reduce using rule 36 (arith2 -> div .)
    MATCH           reduce using rule 36 (arith2 -> div .)
    ID              reduce using rule 36 (arith2 -> div .)
    NOT             reduce using rule 36 (arith2 -> div .)
    AND             reduce using rule 36 (arith2 -> div .)
    LITDEC          reduce using rule 36 (arith2 -> div .)
    LITCHAR         reduce using rule 36 (arith2 -> div .)
    LITBOOL         reduce using rule 36 (arith2 -> div .)
    LITSTRING       reduce using rule 36 (arith2 -> div .)
    COMMA           reduce using rule 36 (arith2 -> div .)
    RBRACKET        reduce using rule 36 (arith2 -> div .)


state 114

    (30) exp -> unit .

    RPAREN          reduce using rule 30 (exp -> unit .)
    EQU             reduce using rule 30 (exp -> unit .)
    PLUSEQUAL       reduce using rule 30 (exp -> unit .)
    SUBEQUAL        reduce using rule 30 (exp -> unit .)
    DIVEQUAL        reduce using rule 30 (exp -> unit .)
    TIMESEQUAL      reduce using rule 30 (exp -> unit .)
    MODEQUAL        reduce using rule 30 (exp -> unit .)
    ANDEQUAL        reduce using rule 30 (exp -> unit .)
    OREQUAL         reduce using rule 30 (exp -> unit .)
    LBRACKET        reduce using rule 30 (exp -> unit .)
    PERIOD          reduce using rule 30 (exp -> unit .)
    SEMICOLON       reduce using rule 30 (exp -> unit .)
    RSQUIGBRACKET   reduce using rule 30 (exp -> unit .)
    LPAREN          reduce using rule 30 (exp -> unit .)
    LOOP            reduce using rule 30 (exp -> unit .)
    WHILE           reduce using rule 30 (exp -> unit .)
    BOX             reduce using rule 30 (exp -> unit .)
    IF              reduce using rule 30 (exp -> unit .)
    MATCH           reduce using rule 30 (exp -> unit .)
    ID              reduce using rule 30 (exp -> unit .)
    SUB             reduce using rule 30 (exp -> unit .)
    NOT             reduce using rule 30 (exp -> unit .)
    AND             reduce using rule 30 (exp -> unit .)
    MUL             reduce using rule 30 (exp -> unit .)
    LITDEC          reduce using rule 30 (exp -> unit .)
    LITCHAR         reduce using rule 30 (exp -> unit .)
    LITBOOL         reduce using rule 30 (exp -> unit .)
    LITSTRING       reduce using rule 30 (exp -> unit .)
    COMMA           reduce using rule 30 (exp -> unit .)
    RBRACKET        reduce using rule 30 (exp -> unit .)


state 115

    (13) stmt -> let .

    SEMICOLON       reduce using rule 13 (stmt -> let .)
    RSQUIGBRACKET   reduce using rule 13 (stmt -> let .)


state 116

    (137) lit -> p_lit .

    ADD             reduce using rule 137 (lit -> p_lit .)
    SUB             reduce using rule 137 (lit -> p_lit .)
    MUL             reduce using rule 137 (lit -> p_lit .)
    DIV             reduce using rule 137 (lit -> p_lit .)
    MODOP           reduce using rule 137 (lit -> p_lit .)
    LESSTHAN        reduce using rule 137 (lit -> p_lit .)
    LESSTHANOREQUAL reduce using rule 137 (lit -> p_lit .)
    GREATERTHAN     reduce using rule 137 (lit -> p_lit .)
    GREATERTHANOREQUAL reduce using rule 137 (lit -> p_lit .)
    EQUALTO         reduce using rule 137 (lit -> p_lit .)
    NOTEQUAL        reduce using rule 137 (lit -> p_lit .)
    LOGICALOR       reduce using rule 137 (lit -> p_lit .)
    LOGICALAND      reduce using rule 137 (lit -> p_lit .)
    RPAREN          reduce using rule 137 (lit -> p_lit .)
    EQU             reduce using rule 137 (lit -> p_lit .)
    PLUSEQUAL       reduce using rule 137 (lit -> p_lit .)
    SUBEQUAL        reduce using rule 137 (lit -> p_lit .)
    DIVEQUAL        reduce using rule 137 (lit -> p_lit .)
    TIMESEQUAL      reduce using rule 137 (lit -> p_lit .)
    MODEQUAL        reduce using rule 137 (lit -> p_lit .)
    ANDEQUAL        reduce using rule 137 (lit -> p_lit .)
    OREQUAL         reduce using rule 137 (lit -> p_lit .)
    LBRACKET        reduce using rule 137 (lit -> p_lit .)
    PERIOD          reduce using rule 137 (lit -> p_lit .)
    RBRACKET        reduce using rule 137 (lit -> p_lit .)
    SEMICOLON       reduce using rule 137 (lit -> p_lit .)
    RSQUIGBRACKET   reduce using rule 137 (lit -> p_lit .)
    LPAREN          reduce using rule 137 (lit -> p_lit .)
    LOOP            reduce using rule 137 (lit -> p_lit .)
    WHILE           reduce using rule 137 (lit -> p_lit .)
    BOX             reduce using rule 137 (lit -> p_lit .)
    IF              reduce using rule 137 (lit -> p_lit .)
    MATCH           reduce using rule 137 (lit -> p_lit .)
    ID              reduce using rule 137 (lit -> p_lit .)
    NOT             reduce using rule 137 (lit -> p_lit .)
    AND             reduce using rule 137 (lit -> p_lit .)
    LITDEC          reduce using rule 137 (lit -> p_lit .)
    LITCHAR         reduce using rule 137 (lit -> p_lit .)
    LITBOOL         reduce using rule 137 (lit -> p_lit .)
    LITSTRING       reduce using rule 137 (lit -> p_lit .)
    COMMA           reduce using rule 137 (lit -> p_lit .)


state 117

    (177) box_new -> BOX . CLASSACCESS NEW LPAREN exp RPAREN

    CLASSACCESS     shift and go to state 182


state 118

    (90) let -> LET . pat COLON type EQU exp
    (91) let -> LET . pat COLON type
    (92) let -> LET . pat EQU exp
    (93) let -> LET . pat
    (107) pat -> . p_lit
    (108) pat -> . LPAREN RPAREN
    (109) pat -> . WC
    (110) pat -> . SUB p_lit
    (111) pat -> . id
    (112) pat -> . REF id
    (113) pat -> . REF MUT id
    (114) pat -> . MUT id
    (115) pat -> . AND pat
    (116) pat -> . pat_arr
    (117) pat -> . pat_enum
    (118) pat -> . pat_struct
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (143) id -> . ID
    (119) pat_arr -> . LBRACKET pats RBRACKET
    (193) pat_enum -> . pat_enum LPAREN pats RPAREN
    (194) pat_enum -> . id CLASSACCESS id
    (120) pat_struct -> . id LSQUIGBRACKET pat_fields RSQUIGBRACKET

    LPAREN          shift and go to state 29
    WC              shift and go to state 36
    SUB             shift and go to state 34
    REF             shift and go to state 32
    MUT             shift and go to state 33
    AND             shift and go to state 30
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40
    ID              shift and go to state 10
    LBRACKET        shift and go to state 41

    pat_arr                        shift and go to state 37
    pat                            shift and go to state 183
    pat_enum                       shift and go to state 35
    id                             shift and go to state 43
    pat_struct                     shift and go to state 42
    p_lit                          shift and go to state 26

state 119

    (44) arith3 -> arith4 .

    ADD             reduce using rule 44 (arith3 -> arith4 .)
    SUB             reduce using rule 44 (arith3 -> arith4 .)
    MUL             reduce using rule 44 (arith3 -> arith4 .)
    DIV             reduce using rule 44 (arith3 -> arith4 .)
    MODOP           reduce using rule 44 (arith3 -> arith4 .)
    LESSTHAN        reduce using rule 44 (arith3 -> arith4 .)
    LESSTHANOREQUAL reduce using rule 44 (arith3 -> arith4 .)
    GREATERTHAN     reduce using rule 44 (arith3 -> arith4 .)
    GREATERTHANOREQUAL reduce using rule 44 (arith3 -> arith4 .)
    EQUALTO         reduce using rule 44 (arith3 -> arith4 .)
    NOTEQUAL        reduce using rule 44 (arith3 -> arith4 .)
    LOGICALOR       reduce using rule 44 (arith3 -> arith4 .)
    LOGICALAND      reduce using rule 44 (arith3 -> arith4 .)
    EQU             reduce using rule 44 (arith3 -> arith4 .)
    PLUSEQUAL       reduce using rule 44 (arith3 -> arith4 .)
    SUBEQUAL        reduce using rule 44 (arith3 -> arith4 .)
    DIVEQUAL        reduce using rule 44 (arith3 -> arith4 .)
    TIMESEQUAL      reduce using rule 44 (arith3 -> arith4 .)
    MODEQUAL        reduce using rule 44 (arith3 -> arith4 .)
    ANDEQUAL        reduce using rule 44 (arith3 -> arith4 .)
    OREQUAL         reduce using rule 44 (arith3 -> arith4 .)
    LBRACKET        reduce using rule 44 (arith3 -> arith4 .)
    PERIOD          reduce using rule 44 (arith3 -> arith4 .)
    SEMICOLON       reduce using rule 44 (arith3 -> arith4 .)
    RSQUIGBRACKET   reduce using rule 44 (arith3 -> arith4 .)
    RPAREN          reduce using rule 44 (arith3 -> arith4 .)
    LPAREN          reduce using rule 44 (arith3 -> arith4 .)
    LOOP            reduce using rule 44 (arith3 -> arith4 .)
    WHILE           reduce using rule 44 (arith3 -> arith4 .)
    BOX             reduce using rule 44 (arith3 -> arith4 .)
    IF              reduce using rule 44 (arith3 -> arith4 .)
    MATCH           reduce using rule 44 (arith3 -> arith4 .)
    ID              reduce using rule 44 (arith3 -> arith4 .)
    NOT             reduce using rule 44 (arith3 -> arith4 .)
    AND             reduce using rule 44 (arith3 -> arith4 .)
    LITDEC          reduce using rule 44 (arith3 -> arith4 .)
    LITCHAR         reduce using rule 44 (arith3 -> arith4 .)
    LITBOOL         reduce using rule 44 (arith3 -> arith4 .)
    LITSTRING       reduce using rule 44 (arith3 -> arith4 .)
    COMMA           reduce using rule 44 (arith3 -> arith4 .)
    RBRACKET        reduce using rule 44 (arith3 -> arith4 .)


state 120

    (184) return -> RETURN .

    LPAREN          reduce using rule 184 (return -> RETURN .)
    LOOP            reduce using rule 184 (return -> RETURN .)
    WHILE           reduce using rule 184 (return -> RETURN .)
    BOX             reduce using rule 184 (return -> RETURN .)
    IF              reduce using rule 184 (return -> RETURN .)
    MATCH           reduce using rule 184 (return -> RETURN .)
    LBRACKET        reduce using rule 184 (return -> RETURN .)
    ID              reduce using rule 184 (return -> RETURN .)
    SUB             reduce using rule 184 (return -> RETURN .)
    NOT             reduce using rule 184 (return -> RETURN .)
    AND             reduce using rule 184 (return -> RETURN .)
    MUL             reduce using rule 184 (return -> RETURN .)
    LITDEC          reduce using rule 184 (return -> RETURN .)
    LITCHAR         reduce using rule 184 (return -> RETURN .)
    LITBOOL         reduce using rule 184 (return -> RETURN .)
    LITSTRING       reduce using rule 184 (return -> RETURN .)
    EQU             reduce using rule 184 (return -> RETURN .)
    PLUSEQUAL       reduce using rule 184 (return -> RETURN .)
    SUBEQUAL        reduce using rule 184 (return -> RETURN .)
    DIVEQUAL        reduce using rule 184 (return -> RETURN .)
    TIMESEQUAL      reduce using rule 184 (return -> RETURN .)
    MODEQUAL        reduce using rule 184 (return -> RETURN .)
    ANDEQUAL        reduce using rule 184 (return -> RETURN .)
    OREQUAL         reduce using rule 184 (return -> RETURN .)
    PERIOD          reduce using rule 184 (return -> RETURN .)
    SEMICOLON       reduce using rule 184 (return -> RETURN .)
    RSQUIGBRACKET   reduce using rule 184 (return -> RETURN .)


state 121

    (19) exp -> LPAREN . exp RPAREN
    (81) unit -> LPAREN . RPAREN
    (40) arith3 -> LPAREN . arith1 RPAREN
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    RPAREN          shift and go to state 186
    LPAREN          shift and go to state 121
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! RPAREN          [ reduce using rule 31 (exp -> .) ]
  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 185
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 184
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 122

    (38) arith2 -> neg .

    ADD             reduce using rule 38 (arith2 -> neg .)
    SUB             reduce using rule 38 (arith2 -> neg .)
    MUL             reduce using rule 38 (arith2 -> neg .)
    DIV             reduce using rule 38 (arith2 -> neg .)
    MODOP           reduce using rule 38 (arith2 -> neg .)
    LESSTHAN        reduce using rule 38 (arith2 -> neg .)
    LESSTHANOREQUAL reduce using rule 38 (arith2 -> neg .)
    GREATERTHAN     reduce using rule 38 (arith2 -> neg .)
    GREATERTHANOREQUAL reduce using rule 38 (arith2 -> neg .)
    EQUALTO         reduce using rule 38 (arith2 -> neg .)
    NOTEQUAL        reduce using rule 38 (arith2 -> neg .)
    LOGICALOR       reduce using rule 38 (arith2 -> neg .)
    LOGICALAND      reduce using rule 38 (arith2 -> neg .)
    EQU             reduce using rule 38 (arith2 -> neg .)
    PLUSEQUAL       reduce using rule 38 (arith2 -> neg .)
    SUBEQUAL        reduce using rule 38 (arith2 -> neg .)
    DIVEQUAL        reduce using rule 38 (arith2 -> neg .)
    TIMESEQUAL      reduce using rule 38 (arith2 -> neg .)
    MODEQUAL        reduce using rule 38 (arith2 -> neg .)
    ANDEQUAL        reduce using rule 38 (arith2 -> neg .)
    OREQUAL         reduce using rule 38 (arith2 -> neg .)
    LBRACKET        reduce using rule 38 (arith2 -> neg .)
    PERIOD          reduce using rule 38 (arith2 -> neg .)
    SEMICOLON       reduce using rule 38 (arith2 -> neg .)
    RSQUIGBRACKET   reduce using rule 38 (arith2 -> neg .)
    RPAREN          reduce using rule 38 (arith2 -> neg .)
    LPAREN          reduce using rule 38 (arith2 -> neg .)
    LOOP            reduce using rule 38 (arith2 -> neg .)
    WHILE           reduce using rule 38 (arith2 -> neg .)
    BOX             reduce using rule 38 (arith2 -> neg .)
    IF              reduce using rule 38 (arith2 -> neg .)
    MATCH           reduce using rule 38 (arith2 -> neg .)
    ID              reduce using rule 38 (arith2 -> neg .)
    NOT             reduce using rule 38 (arith2 -> neg .)
    AND             reduce using rule 38 (arith2 -> neg .)
    LITDEC          reduce using rule 38 (arith2 -> neg .)
    LITCHAR         reduce using rule 38 (arith2 -> neg .)
    LITBOOL         reduce using rule 38 (arith2 -> neg .)
    LITSTRING       reduce using rule 38 (arith2 -> neg .)
    COMMA           reduce using rule 38 (arith2 -> neg .)
    RBRACKET        reduce using rule 38 (arith2 -> neg .)


state 123

    (8) stmts -> stmt . SEMICOLON stmts
    (9) stmts -> stmt .

    SEMICOLON       shift and go to state 187
    RSQUIGBRACKET   reduce using rule 9 (stmts -> stmt .)


state 124

    (25) exp -> match .

    RPAREN          reduce using rule 25 (exp -> match .)
    EQU             reduce using rule 25 (exp -> match .)
    PLUSEQUAL       reduce using rule 25 (exp -> match .)
    SUBEQUAL        reduce using rule 25 (exp -> match .)
    DIVEQUAL        reduce using rule 25 (exp -> match .)
    TIMESEQUAL      reduce using rule 25 (exp -> match .)
    MODEQUAL        reduce using rule 25 (exp -> match .)
    ANDEQUAL        reduce using rule 25 (exp -> match .)
    OREQUAL         reduce using rule 25 (exp -> match .)
    LBRACKET        reduce using rule 25 (exp -> match .)
    PERIOD          reduce using rule 25 (exp -> match .)
    SEMICOLON       reduce using rule 25 (exp -> match .)
    RSQUIGBRACKET   reduce using rule 25 (exp -> match .)
    LPAREN          reduce using rule 25 (exp -> match .)
    LOOP            reduce using rule 25 (exp -> match .)
    WHILE           reduce using rule 25 (exp -> match .)
    BOX             reduce using rule 25 (exp -> match .)
    IF              reduce using rule 25 (exp -> match .)
    MATCH           reduce using rule 25 (exp -> match .)
    ID              reduce using rule 25 (exp -> match .)
    SUB             reduce using rule 25 (exp -> match .)
    NOT             reduce using rule 25 (exp -> match .)
    AND             reduce using rule 25 (exp -> match .)
    MUL             reduce using rule 25 (exp -> match .)
    LITDEC          reduce using rule 25 (exp -> match .)
    LITCHAR         reduce using rule 25 (exp -> match .)
    LITBOOL         reduce using rule 25 (exp -> match .)
    LITSTRING       reduce using rule 25 (exp -> match .)
    COMMA           reduce using rule 25 (exp -> match .)
    RBRACKET        reduce using rule 25 (exp -> match .)


state 125

    (56) comp -> gt .

    ADD             reduce using rule 56 (comp -> gt .)
    SUB             reduce using rule 56 (comp -> gt .)
    MUL             reduce using rule 56 (comp -> gt .)
    DIV             reduce using rule 56 (comp -> gt .)
    MODOP           reduce using rule 56 (comp -> gt .)
    LESSTHAN        reduce using rule 56 (comp -> gt .)
    LESSTHANOREQUAL reduce using rule 56 (comp -> gt .)
    GREATERTHAN     reduce using rule 56 (comp -> gt .)
    GREATERTHANOREQUAL reduce using rule 56 (comp -> gt .)
    EQUALTO         reduce using rule 56 (comp -> gt .)
    NOTEQUAL        reduce using rule 56 (comp -> gt .)
    LOGICALOR       reduce using rule 56 (comp -> gt .)
    LOGICALAND      reduce using rule 56 (comp -> gt .)
    EQU             reduce using rule 56 (comp -> gt .)
    PLUSEQUAL       reduce using rule 56 (comp -> gt .)
    SUBEQUAL        reduce using rule 56 (comp -> gt .)
    DIVEQUAL        reduce using rule 56 (comp -> gt .)
    TIMESEQUAL      reduce using rule 56 (comp -> gt .)
    MODEQUAL        reduce using rule 56 (comp -> gt .)
    ANDEQUAL        reduce using rule 56 (comp -> gt .)
    OREQUAL         reduce using rule 56 (comp -> gt .)
    LBRACKET        reduce using rule 56 (comp -> gt .)
    PERIOD          reduce using rule 56 (comp -> gt .)
    SEMICOLON       reduce using rule 56 (comp -> gt .)
    RSQUIGBRACKET   reduce using rule 56 (comp -> gt .)
    RPAREN          reduce using rule 56 (comp -> gt .)
    LPAREN          reduce using rule 56 (comp -> gt .)
    LOOP            reduce using rule 56 (comp -> gt .)
    WHILE           reduce using rule 56 (comp -> gt .)
    BOX             reduce using rule 56 (comp -> gt .)
    IF              reduce using rule 56 (comp -> gt .)
    MATCH           reduce using rule 56 (comp -> gt .)
    ID              reduce using rule 56 (comp -> gt .)
    NOT             reduce using rule 56 (comp -> gt .)
    AND             reduce using rule 56 (comp -> gt .)
    LITDEC          reduce using rule 56 (comp -> gt .)
    LITCHAR         reduce using rule 56 (comp -> gt .)
    LITBOOL         reduce using rule 56 (comp -> gt .)
    LITSTRING       reduce using rule 56 (comp -> gt .)
    COMMA           reduce using rule 56 (comp -> gt .)
    RBRACKET        reduce using rule 56 (comp -> gt .)


state 126

    (21) exp -> loop .

    RPAREN          reduce using rule 21 (exp -> loop .)
    EQU             reduce using rule 21 (exp -> loop .)
    PLUSEQUAL       reduce using rule 21 (exp -> loop .)
    SUBEQUAL        reduce using rule 21 (exp -> loop .)
    DIVEQUAL        reduce using rule 21 (exp -> loop .)
    TIMESEQUAL      reduce using rule 21 (exp -> loop .)
    MODEQUAL        reduce using rule 21 (exp -> loop .)
    ANDEQUAL        reduce using rule 21 (exp -> loop .)
    OREQUAL         reduce using rule 21 (exp -> loop .)
    LBRACKET        reduce using rule 21 (exp -> loop .)
    PERIOD          reduce using rule 21 (exp -> loop .)
    SEMICOLON       reduce using rule 21 (exp -> loop .)
    RSQUIGBRACKET   reduce using rule 21 (exp -> loop .)
    LPAREN          reduce using rule 21 (exp -> loop .)
    LOOP            reduce using rule 21 (exp -> loop .)
    WHILE           reduce using rule 21 (exp -> loop .)
    BOX             reduce using rule 21 (exp -> loop .)
    IF              reduce using rule 21 (exp -> loop .)
    MATCH           reduce using rule 21 (exp -> loop .)
    ID              reduce using rule 21 (exp -> loop .)
    SUB             reduce using rule 21 (exp -> loop .)
    NOT             reduce using rule 21 (exp -> loop .)
    AND             reduce using rule 21 (exp -> loop .)
    MUL             reduce using rule 21 (exp -> loop .)
    LITDEC          reduce using rule 21 (exp -> loop .)
    LITCHAR         reduce using rule 21 (exp -> loop .)
    LITBOOL         reduce using rule 21 (exp -> loop .)
    LITSTRING       reduce using rule 21 (exp -> loop .)
    COMMA           reduce using rule 21 (exp -> loop .)
    RBRACKET        reduce using rule 21 (exp -> loop .)


state 127

    (72) ptr -> addr .

    ADD             reduce using rule 72 (ptr -> addr .)
    SUB             reduce using rule 72 (ptr -> addr .)
    MUL             reduce using rule 72 (ptr -> addr .)
    DIV             reduce using rule 72 (ptr -> addr .)
    MODOP           reduce using rule 72 (ptr -> addr .)
    LESSTHAN        reduce using rule 72 (ptr -> addr .)
    LESSTHANOREQUAL reduce using rule 72 (ptr -> addr .)
    GREATERTHAN     reduce using rule 72 (ptr -> addr .)
    GREATERTHANOREQUAL reduce using rule 72 (ptr -> addr .)
    EQUALTO         reduce using rule 72 (ptr -> addr .)
    NOTEQUAL        reduce using rule 72 (ptr -> addr .)
    LOGICALOR       reduce using rule 72 (ptr -> addr .)
    LOGICALAND      reduce using rule 72 (ptr -> addr .)
    EQU             reduce using rule 72 (ptr -> addr .)
    PLUSEQUAL       reduce using rule 72 (ptr -> addr .)
    SUBEQUAL        reduce using rule 72 (ptr -> addr .)
    DIVEQUAL        reduce using rule 72 (ptr -> addr .)
    TIMESEQUAL      reduce using rule 72 (ptr -> addr .)
    MODEQUAL        reduce using rule 72 (ptr -> addr .)
    ANDEQUAL        reduce using rule 72 (ptr -> addr .)
    OREQUAL         reduce using rule 72 (ptr -> addr .)
    LBRACKET        reduce using rule 72 (ptr -> addr .)
    PERIOD          reduce using rule 72 (ptr -> addr .)
    SEMICOLON       reduce using rule 72 (ptr -> addr .)
    RSQUIGBRACKET   reduce using rule 72 (ptr -> addr .)
    RPAREN          reduce using rule 72 (ptr -> addr .)
    LPAREN          reduce using rule 72 (ptr -> addr .)
    LOOP            reduce using rule 72 (ptr -> addr .)
    WHILE           reduce using rule 72 (ptr -> addr .)
    BOX             reduce using rule 72 (ptr -> addr .)
    IF              reduce using rule 72 (ptr -> addr .)
    MATCH           reduce using rule 72 (ptr -> addr .)
    ID              reduce using rule 72 (ptr -> addr .)
    NOT             reduce using rule 72 (ptr -> addr .)
    AND             reduce using rule 72 (ptr -> addr .)
    LITDEC          reduce using rule 72 (ptr -> addr .)
    LITCHAR         reduce using rule 72 (ptr -> addr .)
    LITBOOL         reduce using rule 72 (ptr -> addr .)
    LITSTRING       reduce using rule 72 (ptr -> addr .)
    COMMA           reduce using rule 72 (ptr -> addr .)
    RBRACKET        reduce using rule 72 (ptr -> addr .)


state 128

    (54) comp -> lt .

    ADD             reduce using rule 54 (comp -> lt .)
    SUB             reduce using rule 54 (comp -> lt .)
    MUL             reduce using rule 54 (comp -> lt .)
    DIV             reduce using rule 54 (comp -> lt .)
    MODOP           reduce using rule 54 (comp -> lt .)
    LESSTHAN        reduce using rule 54 (comp -> lt .)
    LESSTHANOREQUAL reduce using rule 54 (comp -> lt .)
    GREATERTHAN     reduce using rule 54 (comp -> lt .)
    GREATERTHANOREQUAL reduce using rule 54 (comp -> lt .)
    EQUALTO         reduce using rule 54 (comp -> lt .)
    NOTEQUAL        reduce using rule 54 (comp -> lt .)
    LOGICALOR       reduce using rule 54 (comp -> lt .)
    LOGICALAND      reduce using rule 54 (comp -> lt .)
    EQU             reduce using rule 54 (comp -> lt .)
    PLUSEQUAL       reduce using rule 54 (comp -> lt .)
    SUBEQUAL        reduce using rule 54 (comp -> lt .)
    DIVEQUAL        reduce using rule 54 (comp -> lt .)
    TIMESEQUAL      reduce using rule 54 (comp -> lt .)
    MODEQUAL        reduce using rule 54 (comp -> lt .)
    ANDEQUAL        reduce using rule 54 (comp -> lt .)
    OREQUAL         reduce using rule 54 (comp -> lt .)
    LBRACKET        reduce using rule 54 (comp -> lt .)
    PERIOD          reduce using rule 54 (comp -> lt .)
    SEMICOLON       reduce using rule 54 (comp -> lt .)
    RSQUIGBRACKET   reduce using rule 54 (comp -> lt .)
    RPAREN          reduce using rule 54 (comp -> lt .)
    LPAREN          reduce using rule 54 (comp -> lt .)
    LOOP            reduce using rule 54 (comp -> lt .)
    WHILE           reduce using rule 54 (comp -> lt .)
    BOX             reduce using rule 54 (comp -> lt .)
    IF              reduce using rule 54 (comp -> lt .)
    MATCH           reduce using rule 54 (comp -> lt .)
    ID              reduce using rule 54 (comp -> lt .)
    NOT             reduce using rule 54 (comp -> lt .)
    AND             reduce using rule 54 (comp -> lt .)
    LITDEC          reduce using rule 54 (comp -> lt .)
    LITCHAR         reduce using rule 54 (comp -> lt .)
    LITBOOL         reduce using rule 54 (comp -> lt .)
    LITSTRING       reduce using rule 54 (comp -> lt .)
    COMMA           reduce using rule 54 (comp -> lt .)
    RBRACKET        reduce using rule 54 (comp -> lt .)


state 129

    (27) exp -> assign .

    RPAREN          reduce using rule 27 (exp -> assign .)
    EQU             reduce using rule 27 (exp -> assign .)
    PLUSEQUAL       reduce using rule 27 (exp -> assign .)
    SUBEQUAL        reduce using rule 27 (exp -> assign .)
    DIVEQUAL        reduce using rule 27 (exp -> assign .)
    TIMESEQUAL      reduce using rule 27 (exp -> assign .)
    MODEQUAL        reduce using rule 27 (exp -> assign .)
    ANDEQUAL        reduce using rule 27 (exp -> assign .)
    OREQUAL         reduce using rule 27 (exp -> assign .)
    LBRACKET        reduce using rule 27 (exp -> assign .)
    PERIOD          reduce using rule 27 (exp -> assign .)
    SEMICOLON       reduce using rule 27 (exp -> assign .)
    RSQUIGBRACKET   reduce using rule 27 (exp -> assign .)
    LPAREN          reduce using rule 27 (exp -> assign .)
    LOOP            reduce using rule 27 (exp -> assign .)
    WHILE           reduce using rule 27 (exp -> assign .)
    BOX             reduce using rule 27 (exp -> assign .)
    IF              reduce using rule 27 (exp -> assign .)
    MATCH           reduce using rule 27 (exp -> assign .)
    ID              reduce using rule 27 (exp -> assign .)
    SUB             reduce using rule 27 (exp -> assign .)
    NOT             reduce using rule 27 (exp -> assign .)
    AND             reduce using rule 27 (exp -> assign .)
    MUL             reduce using rule 27 (exp -> assign .)
    LITDEC          reduce using rule 27 (exp -> assign .)
    LITCHAR         reduce using rule 27 (exp -> assign .)
    LITBOOL         reduce using rule 27 (exp -> assign .)
    LITSTRING       reduce using rule 27 (exp -> assign .)
    COMMA           reduce using rule 27 (exp -> assign .)
    RBRACKET        reduce using rule 27 (exp -> assign .)


state 130

    (41) arith3 -> fn_call .

    ADD             reduce using rule 41 (arith3 -> fn_call .)
    SUB             reduce using rule 41 (arith3 -> fn_call .)
    MUL             reduce using rule 41 (arith3 -> fn_call .)
    DIV             reduce using rule 41 (arith3 -> fn_call .)
    MODOP           reduce using rule 41 (arith3 -> fn_call .)
    LESSTHAN        reduce using rule 41 (arith3 -> fn_call .)
    LESSTHANOREQUAL reduce using rule 41 (arith3 -> fn_call .)
    GREATERTHAN     reduce using rule 41 (arith3 -> fn_call .)
    GREATERTHANOREQUAL reduce using rule 41 (arith3 -> fn_call .)
    EQUALTO         reduce using rule 41 (arith3 -> fn_call .)
    NOTEQUAL        reduce using rule 41 (arith3 -> fn_call .)
    LOGICALOR       reduce using rule 41 (arith3 -> fn_call .)
    LOGICALAND      reduce using rule 41 (arith3 -> fn_call .)
    EQU             reduce using rule 41 (arith3 -> fn_call .)
    PLUSEQUAL       reduce using rule 41 (arith3 -> fn_call .)
    SUBEQUAL        reduce using rule 41 (arith3 -> fn_call .)
    DIVEQUAL        reduce using rule 41 (arith3 -> fn_call .)
    TIMESEQUAL      reduce using rule 41 (arith3 -> fn_call .)
    MODEQUAL        reduce using rule 41 (arith3 -> fn_call .)
    ANDEQUAL        reduce using rule 41 (arith3 -> fn_call .)
    OREQUAL         reduce using rule 41 (arith3 -> fn_call .)
    LBRACKET        reduce using rule 41 (arith3 -> fn_call .)
    PERIOD          reduce using rule 41 (arith3 -> fn_call .)
    SEMICOLON       reduce using rule 41 (arith3 -> fn_call .)
    RSQUIGBRACKET   reduce using rule 41 (arith3 -> fn_call .)
    RPAREN          reduce using rule 41 (arith3 -> fn_call .)
    LPAREN          reduce using rule 41 (arith3 -> fn_call .)
    LOOP            reduce using rule 41 (arith3 -> fn_call .)
    WHILE           reduce using rule 41 (arith3 -> fn_call .)
    BOX             reduce using rule 41 (arith3 -> fn_call .)
    IF              reduce using rule 41 (arith3 -> fn_call .)
    MATCH           reduce using rule 41 (arith3 -> fn_call .)
    ID              reduce using rule 41 (arith3 -> fn_call .)
    NOT             reduce using rule 41 (arith3 -> fn_call .)
    AND             reduce using rule 41 (arith3 -> fn_call .)
    LITDEC          reduce using rule 41 (arith3 -> fn_call .)
    LITCHAR         reduce using rule 41 (arith3 -> fn_call .)
    LITBOOL         reduce using rule 41 (arith3 -> fn_call .)
    LITSTRING       reduce using rule 41 (arith3 -> fn_call .)
    COMMA           reduce using rule 41 (arith3 -> fn_call .)
    RBRACKET        reduce using rule 41 (arith3 -> fn_call .)


state 131

    (32) arith1 -> add .

    ADD             reduce using rule 32 (arith1 -> add .)
    SUB             reduce using rule 32 (arith1 -> add .)
    MUL             reduce using rule 32 (arith1 -> add .)
    DIV             reduce using rule 32 (arith1 -> add .)
    MODOP           reduce using rule 32 (arith1 -> add .)
    LESSTHAN        reduce using rule 32 (arith1 -> add .)
    LESSTHANOREQUAL reduce using rule 32 (arith1 -> add .)
    GREATERTHAN     reduce using rule 32 (arith1 -> add .)
    GREATERTHANOREQUAL reduce using rule 32 (arith1 -> add .)
    EQUALTO         reduce using rule 32 (arith1 -> add .)
    NOTEQUAL        reduce using rule 32 (arith1 -> add .)
    LOGICALOR       reduce using rule 32 (arith1 -> add .)
    LOGICALAND      reduce using rule 32 (arith1 -> add .)
    EQU             reduce using rule 32 (arith1 -> add .)
    PLUSEQUAL       reduce using rule 32 (arith1 -> add .)
    SUBEQUAL        reduce using rule 32 (arith1 -> add .)
    DIVEQUAL        reduce using rule 32 (arith1 -> add .)
    TIMESEQUAL      reduce using rule 32 (arith1 -> add .)
    MODEQUAL        reduce using rule 32 (arith1 -> add .)
    ANDEQUAL        reduce using rule 32 (arith1 -> add .)
    OREQUAL         reduce using rule 32 (arith1 -> add .)
    LBRACKET        reduce using rule 32 (arith1 -> add .)
    PERIOD          reduce using rule 32 (arith1 -> add .)
    SEMICOLON       reduce using rule 32 (arith1 -> add .)
    RSQUIGBRACKET   reduce using rule 32 (arith1 -> add .)
    RPAREN          reduce using rule 32 (arith1 -> add .)
    LPAREN          reduce using rule 32 (arith1 -> add .)
    LOOP            reduce using rule 32 (arith1 -> add .)
    WHILE           reduce using rule 32 (arith1 -> add .)
    BOX             reduce using rule 32 (arith1 -> add .)
    IF              reduce using rule 32 (arith1 -> add .)
    MATCH           reduce using rule 32 (arith1 -> add .)
    ID              reduce using rule 32 (arith1 -> add .)
    NOT             reduce using rule 32 (arith1 -> add .)
    AND             reduce using rule 32 (arith1 -> add .)
    LITDEC          reduce using rule 32 (arith1 -> add .)
    LITCHAR         reduce using rule 32 (arith1 -> add .)
    LITBOOL         reduce using rule 32 (arith1 -> add .)
    LITSTRING       reduce using rule 32 (arith1 -> add .)
    COMMA           reduce using rule 32 (arith1 -> add .)
    RBRACKET        reduce using rule 32 (arith1 -> add .)


state 132

    (11) stmt -> return .
    (185) return -> return . exp
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LPAREN resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 11 (stmt -> return .)
  ! reduce/reduce conflict for RSQUIGBRACKET resolved using rule 11 (stmt -> return .)
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for BOX resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for MATCH resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for LITDEC resolved as shift
  ! shift/reduce conflict for LITCHAR resolved as shift
  ! shift/reduce conflict for LITBOOL resolved as shift
  ! shift/reduce conflict for LITSTRING resolved as shift
    SEMICOLON       reduce using rule 11 (stmt -> return .)
    RSQUIGBRACKET   reduce using rule 11 (stmt -> return .)
    LPAREN          shift and go to state 121
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]
  ! LPAREN          [ reduce using rule 31 (exp -> .) ]
  ! LOOP            [ reduce using rule 31 (exp -> .) ]
  ! WHILE           [ reduce using rule 31 (exp -> .) ]
  ! BOX             [ reduce using rule 31 (exp -> .) ]
  ! IF              [ reduce using rule 31 (exp -> .) ]
  ! MATCH           [ reduce using rule 31 (exp -> .) ]
  ! ID              [ reduce using rule 31 (exp -> .) ]
  ! SUB             [ reduce using rule 31 (exp -> .) ]
  ! NOT             [ reduce using rule 31 (exp -> .) ]
  ! AND             [ reduce using rule 31 (exp -> .) ]
  ! MUL             [ reduce using rule 31 (exp -> .) ]
  ! LITDEC          [ reduce using rule 31 (exp -> .) ]
  ! LITCHAR         [ reduce using rule 31 (exp -> .) ]
  ! LITBOOL         [ reduce using rule 31 (exp -> .) ]
  ! LITSTRING       [ reduce using rule 31 (exp -> .) ]
  ! SEMICOLON       [ reduce using rule 31 (exp -> .) ]
  ! RSQUIGBRACKET   [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 188
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    mul                            shift and go to state 143
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    loop                           shift and go to state 126
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 133

    (138) lit -> enum_con .
    (191) enum_con -> enum_con . LPAREN exps RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    ADD             reduce using rule 138 (lit -> enum_con .)
    SUB             reduce using rule 138 (lit -> enum_con .)
    MUL             reduce using rule 138 (lit -> enum_con .)
    DIV             reduce using rule 138 (lit -> enum_con .)
    MODOP           reduce using rule 138 (lit -> enum_con .)
    LESSTHAN        reduce using rule 138 (lit -> enum_con .)
    LESSTHANOREQUAL reduce using rule 138 (lit -> enum_con .)
    GREATERTHAN     reduce using rule 138 (lit -> enum_con .)
    GREATERTHANOREQUAL reduce using rule 138 (lit -> enum_con .)
    EQUALTO         reduce using rule 138 (lit -> enum_con .)
    NOTEQUAL        reduce using rule 138 (lit -> enum_con .)
    LOGICALOR       reduce using rule 138 (lit -> enum_con .)
    LOGICALAND      reduce using rule 138 (lit -> enum_con .)
    RPAREN          reduce using rule 138 (lit -> enum_con .)
    EQU             reduce using rule 138 (lit -> enum_con .)
    PLUSEQUAL       reduce using rule 138 (lit -> enum_con .)
    SUBEQUAL        reduce using rule 138 (lit -> enum_con .)
    DIVEQUAL        reduce using rule 138 (lit -> enum_con .)
    TIMESEQUAL      reduce using rule 138 (lit -> enum_con .)
    MODEQUAL        reduce using rule 138 (lit -> enum_con .)
    ANDEQUAL        reduce using rule 138 (lit -> enum_con .)
    OREQUAL         reduce using rule 138 (lit -> enum_con .)
    LBRACKET        reduce using rule 138 (lit -> enum_con .)
    PERIOD          reduce using rule 138 (lit -> enum_con .)
    RBRACKET        reduce using rule 138 (lit -> enum_con .)
    SEMICOLON       reduce using rule 138 (lit -> enum_con .)
    RSQUIGBRACKET   reduce using rule 138 (lit -> enum_con .)
    LOOP            reduce using rule 138 (lit -> enum_con .)
    WHILE           reduce using rule 138 (lit -> enum_con .)
    BOX             reduce using rule 138 (lit -> enum_con .)
    IF              reduce using rule 138 (lit -> enum_con .)
    MATCH           reduce using rule 138 (lit -> enum_con .)
    ID              reduce using rule 138 (lit -> enum_con .)
    NOT             reduce using rule 138 (lit -> enum_con .)
    AND             reduce using rule 138 (lit -> enum_con .)
    LITDEC          reduce using rule 138 (lit -> enum_con .)
    LITCHAR         reduce using rule 138 (lit -> enum_con .)
    LITBOOL         reduce using rule 138 (lit -> enum_con .)
    LITSTRING       reduce using rule 138 (lit -> enum_con .)
    COMMA           reduce using rule 138 (lit -> enum_con .)
    LPAREN          shift and go to state 189

  ! LPAREN          [ reduce using rule 138 (lit -> enum_con .) ]


state 134

    (62) comp -> not .

    ADD             reduce using rule 62 (comp -> not .)
    SUB             reduce using rule 62 (comp -> not .)
    MUL             reduce using rule 62 (comp -> not .)
    DIV             reduce using rule 62 (comp -> not .)
    MODOP           reduce using rule 62 (comp -> not .)
    LESSTHAN        reduce using rule 62 (comp -> not .)
    LESSTHANOREQUAL reduce using rule 62 (comp -> not .)
    GREATERTHAN     reduce using rule 62 (comp -> not .)
    GREATERTHANOREQUAL reduce using rule 62 (comp -> not .)
    EQUALTO         reduce using rule 62 (comp -> not .)
    NOTEQUAL        reduce using rule 62 (comp -> not .)
    LOGICALOR       reduce using rule 62 (comp -> not .)
    LOGICALAND      reduce using rule 62 (comp -> not .)
    EQU             reduce using rule 62 (comp -> not .)
    PLUSEQUAL       reduce using rule 62 (comp -> not .)
    SUBEQUAL        reduce using rule 62 (comp -> not .)
    DIVEQUAL        reduce using rule 62 (comp -> not .)
    TIMESEQUAL      reduce using rule 62 (comp -> not .)
    MODEQUAL        reduce using rule 62 (comp -> not .)
    ANDEQUAL        reduce using rule 62 (comp -> not .)
    OREQUAL         reduce using rule 62 (comp -> not .)
    LBRACKET        reduce using rule 62 (comp -> not .)
    PERIOD          reduce using rule 62 (comp -> not .)
    SEMICOLON       reduce using rule 62 (comp -> not .)
    RSQUIGBRACKET   reduce using rule 62 (comp -> not .)
    RPAREN          reduce using rule 62 (comp -> not .)
    LPAREN          reduce using rule 62 (comp -> not .)
    LOOP            reduce using rule 62 (comp -> not .)
    WHILE           reduce using rule 62 (comp -> not .)
    BOX             reduce using rule 62 (comp -> not .)
    IF              reduce using rule 62 (comp -> not .)
    MATCH           reduce using rule 62 (comp -> not .)
    ID              reduce using rule 62 (comp -> not .)
    NOT             reduce using rule 62 (comp -> not .)
    AND             reduce using rule 62 (comp -> not .)
    LITDEC          reduce using rule 62 (comp -> not .)
    LITCHAR         reduce using rule 62 (comp -> not .)
    LITBOOL         reduce using rule 62 (comp -> not .)
    LITSTRING       reduce using rule 62 (comp -> not .)
    COMMA           reduce using rule 62 (comp -> not .)
    RBRACKET        reduce using rule 62 (comp -> not .)


state 135

    (14) stmt -> function .

    SEMICOLON       reduce using rule 14 (stmt -> function .)
    RSQUIGBRACKET   reduce using rule 14 (stmt -> function .)


state 136

    (99) match -> MATCH . LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET

    LPAREN          shift and go to state 190


state 137

    (77) deref -> MUL . arith4
    (78) deref -> MUL . neg
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (53) neg -> . SUB arith4
    (143) id -> . ID
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

    SUB             shift and go to state 156
    ID              shift and go to state 10
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

    ptr                            shift and go to state 145
    deref                          shift and go to state 167
    arith4                         shift and go to state 191
    lit                            shift and go to state 139
    addr_of_mut                    shift and go to state 168
    enum_con                       shift and go to state 133
    addr                           shift and go to state 127
    neg                            shift and go to state 193
    p_lit                          shift and go to state 116
    id                             shift and go to state 192

state 138

    (20) exp -> arith1 .
    (48) add -> arith1 . ADD arith1
    (49) sub -> arith1 . SUB arith1
    (50) mul -> arith1 . MUL arith1
    (51) div -> arith1 . DIV arith1
    (52) mod -> arith1 . MODOP arith1
    (63) lt -> arith1 . LESSTHAN arith1
    (64) leq -> arith1 . LESSTHANOREQUAL arith1
    (65) gt -> arith1 . GREATERTHAN arith1
    (66) geq -> arith1 . GREATERTHANOREQUAL arith1
    (67) eq -> arith1 . EQUALTO arith1
    (68) neq -> arith1 . NOTEQUAL arith1
    (69) or -> arith1 . LOGICALOR arith1
    (70) and -> arith1 . LOGICALAND arith1

  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
    RPAREN          reduce using rule 20 (exp -> arith1 .)
    EQU             reduce using rule 20 (exp -> arith1 .)
    PLUSEQUAL       reduce using rule 20 (exp -> arith1 .)
    SUBEQUAL        reduce using rule 20 (exp -> arith1 .)
    DIVEQUAL        reduce using rule 20 (exp -> arith1 .)
    TIMESEQUAL      reduce using rule 20 (exp -> arith1 .)
    MODEQUAL        reduce using rule 20 (exp -> arith1 .)
    ANDEQUAL        reduce using rule 20 (exp -> arith1 .)
    OREQUAL         reduce using rule 20 (exp -> arith1 .)
    LBRACKET        reduce using rule 20 (exp -> arith1 .)
    PERIOD          reduce using rule 20 (exp -> arith1 .)
    SEMICOLON       reduce using rule 20 (exp -> arith1 .)
    RSQUIGBRACKET   reduce using rule 20 (exp -> arith1 .)
    LPAREN          reduce using rule 20 (exp -> arith1 .)
    LOOP            reduce using rule 20 (exp -> arith1 .)
    WHILE           reduce using rule 20 (exp -> arith1 .)
    BOX             reduce using rule 20 (exp -> arith1 .)
    IF              reduce using rule 20 (exp -> arith1 .)
    MATCH           reduce using rule 20 (exp -> arith1 .)
    ID              reduce using rule 20 (exp -> arith1 .)
    NOT             reduce using rule 20 (exp -> arith1 .)
    AND             reduce using rule 20 (exp -> arith1 .)
    LITDEC          reduce using rule 20 (exp -> arith1 .)
    LITCHAR         reduce using rule 20 (exp -> arith1 .)
    LITBOOL         reduce using rule 20 (exp -> arith1 .)
    LITSTRING       reduce using rule 20 (exp -> arith1 .)
    COMMA           reduce using rule 20 (exp -> arith1 .)
    RBRACKET        reduce using rule 20 (exp -> arith1 .)
    ADD             shift and go to state 204
    SUB             shift and go to state 195
    MUL             shift and go to state 199
    DIV             shift and go to state 197
    MODOP           shift and go to state 205
    LESSTHAN        shift and go to state 202
    LESSTHANOREQUAL shift and go to state 201
    GREATERTHAN     shift and go to state 194
    GREATERTHANOREQUAL shift and go to state 198
    EQUALTO         shift and go to state 206
    NOTEQUAL        shift and go to state 203
    LOGICALOR       shift and go to state 196
    LOGICALAND      shift and go to state 200

  ! SUB             [ reduce using rule 20 (exp -> arith1 .) ]
  ! MUL             [ reduce using rule 20 (exp -> arith1 .) ]


state 139

    (47) arith4 -> lit .

    ADD             reduce using rule 47 (arith4 -> lit .)
    SUB             reduce using rule 47 (arith4 -> lit .)
    MUL             reduce using rule 47 (arith4 -> lit .)
    DIV             reduce using rule 47 (arith4 -> lit .)
    MODOP           reduce using rule 47 (arith4 -> lit .)
    LESSTHAN        reduce using rule 47 (arith4 -> lit .)
    LESSTHANOREQUAL reduce using rule 47 (arith4 -> lit .)
    GREATERTHAN     reduce using rule 47 (arith4 -> lit .)
    GREATERTHANOREQUAL reduce using rule 47 (arith4 -> lit .)
    EQUALTO         reduce using rule 47 (arith4 -> lit .)
    NOTEQUAL        reduce using rule 47 (arith4 -> lit .)
    LOGICALOR       reduce using rule 47 (arith4 -> lit .)
    LOGICALAND      reduce using rule 47 (arith4 -> lit .)
    EQU             reduce using rule 47 (arith4 -> lit .)
    PLUSEQUAL       reduce using rule 47 (arith4 -> lit .)
    SUBEQUAL        reduce using rule 47 (arith4 -> lit .)
    DIVEQUAL        reduce using rule 47 (arith4 -> lit .)
    TIMESEQUAL      reduce using rule 47 (arith4 -> lit .)
    MODEQUAL        reduce using rule 47 (arith4 -> lit .)
    ANDEQUAL        reduce using rule 47 (arith4 -> lit .)
    OREQUAL         reduce using rule 47 (arith4 -> lit .)
    LBRACKET        reduce using rule 47 (arith4 -> lit .)
    PERIOD          reduce using rule 47 (arith4 -> lit .)
    SEMICOLON       reduce using rule 47 (arith4 -> lit .)
    RSQUIGBRACKET   reduce using rule 47 (arith4 -> lit .)
    RPAREN          reduce using rule 47 (arith4 -> lit .)
    LPAREN          reduce using rule 47 (arith4 -> lit .)
    LOOP            reduce using rule 47 (arith4 -> lit .)
    WHILE           reduce using rule 47 (arith4 -> lit .)
    BOX             reduce using rule 47 (arith4 -> lit .)
    IF              reduce using rule 47 (arith4 -> lit .)
    MATCH           reduce using rule 47 (arith4 -> lit .)
    ID              reduce using rule 47 (arith4 -> lit .)
    NOT             reduce using rule 47 (arith4 -> lit .)
    AND             reduce using rule 47 (arith4 -> lit .)
    LITDEC          reduce using rule 47 (arith4 -> lit .)
    LITCHAR         reduce using rule 47 (arith4 -> lit .)
    LITBOOL         reduce using rule 47 (arith4 -> lit .)
    LITSTRING       reduce using rule 47 (arith4 -> lit .)
    COMMA           reduce using rule 47 (arith4 -> lit .)
    RBRACKET        reduce using rule 47 (arith4 -> lit .)


state 140

    (22) exp -> while .

    RPAREN          reduce using rule 22 (exp -> while .)
    EQU             reduce using rule 22 (exp -> while .)
    PLUSEQUAL       reduce using rule 22 (exp -> while .)
    SUBEQUAL        reduce using rule 22 (exp -> while .)
    DIVEQUAL        reduce using rule 22 (exp -> while .)
    TIMESEQUAL      reduce using rule 22 (exp -> while .)
    MODEQUAL        reduce using rule 22 (exp -> while .)
    ANDEQUAL        reduce using rule 22 (exp -> while .)
    OREQUAL         reduce using rule 22 (exp -> while .)
    LBRACKET        reduce using rule 22 (exp -> while .)
    PERIOD          reduce using rule 22 (exp -> while .)
    SEMICOLON       reduce using rule 22 (exp -> while .)
    RSQUIGBRACKET   reduce using rule 22 (exp -> while .)
    LPAREN          reduce using rule 22 (exp -> while .)
    LOOP            reduce using rule 22 (exp -> while .)
    WHILE           reduce using rule 22 (exp -> while .)
    BOX             reduce using rule 22 (exp -> while .)
    IF              reduce using rule 22 (exp -> while .)
    MATCH           reduce using rule 22 (exp -> while .)
    ID              reduce using rule 22 (exp -> while .)
    SUB             reduce using rule 22 (exp -> while .)
    NOT             reduce using rule 22 (exp -> while .)
    AND             reduce using rule 22 (exp -> while .)
    MUL             reduce using rule 22 (exp -> while .)
    LITDEC          reduce using rule 22 (exp -> while .)
    LITCHAR         reduce using rule 22 (exp -> while .)
    LITBOOL         reduce using rule 22 (exp -> while .)
    LITSTRING       reduce using rule 22 (exp -> while .)
    COMMA           reduce using rule 22 (exp -> while .)
    RBRACKET        reduce using rule 22 (exp -> while .)


state 141

    (24) exp -> if .
    (98) if -> if . ELSE block

    RPAREN          reduce using rule 24 (exp -> if .)
    EQU             reduce using rule 24 (exp -> if .)
    PLUSEQUAL       reduce using rule 24 (exp -> if .)
    SUBEQUAL        reduce using rule 24 (exp -> if .)
    DIVEQUAL        reduce using rule 24 (exp -> if .)
    TIMESEQUAL      reduce using rule 24 (exp -> if .)
    MODEQUAL        reduce using rule 24 (exp -> if .)
    ANDEQUAL        reduce using rule 24 (exp -> if .)
    OREQUAL         reduce using rule 24 (exp -> if .)
    LBRACKET        reduce using rule 24 (exp -> if .)
    PERIOD          reduce using rule 24 (exp -> if .)
    SEMICOLON       reduce using rule 24 (exp -> if .)
    RSQUIGBRACKET   reduce using rule 24 (exp -> if .)
    LPAREN          reduce using rule 24 (exp -> if .)
    LOOP            reduce using rule 24 (exp -> if .)
    WHILE           reduce using rule 24 (exp -> if .)
    BOX             reduce using rule 24 (exp -> if .)
    IF              reduce using rule 24 (exp -> if .)
    MATCH           reduce using rule 24 (exp -> if .)
    ID              reduce using rule 24 (exp -> if .)
    SUB             reduce using rule 24 (exp -> if .)
    NOT             reduce using rule 24 (exp -> if .)
    AND             reduce using rule 24 (exp -> if .)
    MUL             reduce using rule 24 (exp -> if .)
    LITDEC          reduce using rule 24 (exp -> if .)
    LITCHAR         reduce using rule 24 (exp -> if .)
    LITBOOL         reduce using rule 24 (exp -> if .)
    LITSTRING       reduce using rule 24 (exp -> if .)
    COMMA           reduce using rule 24 (exp -> if .)
    RBRACKET        reduce using rule 24 (exp -> if .)
    ELSE            shift and go to state 207


state 142

    (33) arith1 -> sub .

    ADD             reduce using rule 33 (arith1 -> sub .)
    SUB             reduce using rule 33 (arith1 -> sub .)
    MUL             reduce using rule 33 (arith1 -> sub .)
    DIV             reduce using rule 33 (arith1 -> sub .)
    MODOP           reduce using rule 33 (arith1 -> sub .)
    LESSTHAN        reduce using rule 33 (arith1 -> sub .)
    LESSTHANOREQUAL reduce using rule 33 (arith1 -> sub .)
    GREATERTHAN     reduce using rule 33 (arith1 -> sub .)
    GREATERTHANOREQUAL reduce using rule 33 (arith1 -> sub .)
    EQUALTO         reduce using rule 33 (arith1 -> sub .)
    NOTEQUAL        reduce using rule 33 (arith1 -> sub .)
    LOGICALOR       reduce using rule 33 (arith1 -> sub .)
    LOGICALAND      reduce using rule 33 (arith1 -> sub .)
    EQU             reduce using rule 33 (arith1 -> sub .)
    PLUSEQUAL       reduce using rule 33 (arith1 -> sub .)
    SUBEQUAL        reduce using rule 33 (arith1 -> sub .)
    DIVEQUAL        reduce using rule 33 (arith1 -> sub .)
    TIMESEQUAL      reduce using rule 33 (arith1 -> sub .)
    MODEQUAL        reduce using rule 33 (arith1 -> sub .)
    ANDEQUAL        reduce using rule 33 (arith1 -> sub .)
    OREQUAL         reduce using rule 33 (arith1 -> sub .)
    LBRACKET        reduce using rule 33 (arith1 -> sub .)
    PERIOD          reduce using rule 33 (arith1 -> sub .)
    SEMICOLON       reduce using rule 33 (arith1 -> sub .)
    RSQUIGBRACKET   reduce using rule 33 (arith1 -> sub .)
    RPAREN          reduce using rule 33 (arith1 -> sub .)
    LPAREN          reduce using rule 33 (arith1 -> sub .)
    LOOP            reduce using rule 33 (arith1 -> sub .)
    WHILE           reduce using rule 33 (arith1 -> sub .)
    BOX             reduce using rule 33 (arith1 -> sub .)
    IF              reduce using rule 33 (arith1 -> sub .)
    MATCH           reduce using rule 33 (arith1 -> sub .)
    ID              reduce using rule 33 (arith1 -> sub .)
    NOT             reduce using rule 33 (arith1 -> sub .)
    AND             reduce using rule 33 (arith1 -> sub .)
    LITDEC          reduce using rule 33 (arith1 -> sub .)
    LITCHAR         reduce using rule 33 (arith1 -> sub .)
    LITBOOL         reduce using rule 33 (arith1 -> sub .)
    LITSTRING       reduce using rule 33 (arith1 -> sub .)
    COMMA           reduce using rule 33 (arith1 -> sub .)
    RBRACKET        reduce using rule 33 (arith1 -> sub .)


state 143

    (35) arith2 -> mul .

    ADD             reduce using rule 35 (arith2 -> mul .)
    SUB             reduce using rule 35 (arith2 -> mul .)
    MUL             reduce using rule 35 (arith2 -> mul .)
    DIV             reduce using rule 35 (arith2 -> mul .)
    MODOP           reduce using rule 35 (arith2 -> mul .)
    LESSTHAN        reduce using rule 35 (arith2 -> mul .)
    LESSTHANOREQUAL reduce using rule 35 (arith2 -> mul .)
    GREATERTHAN     reduce using rule 35 (arith2 -> mul .)
    GREATERTHANOREQUAL reduce using rule 35 (arith2 -> mul .)
    EQUALTO         reduce using rule 35 (arith2 -> mul .)
    NOTEQUAL        reduce using rule 35 (arith2 -> mul .)
    LOGICALOR       reduce using rule 35 (arith2 -> mul .)
    LOGICALAND      reduce using rule 35 (arith2 -> mul .)
    EQU             reduce using rule 35 (arith2 -> mul .)
    PLUSEQUAL       reduce using rule 35 (arith2 -> mul .)
    SUBEQUAL        reduce using rule 35 (arith2 -> mul .)
    DIVEQUAL        reduce using rule 35 (arith2 -> mul .)
    TIMESEQUAL      reduce using rule 35 (arith2 -> mul .)
    MODEQUAL        reduce using rule 35 (arith2 -> mul .)
    ANDEQUAL        reduce using rule 35 (arith2 -> mul .)
    OREQUAL         reduce using rule 35 (arith2 -> mul .)
    LBRACKET        reduce using rule 35 (arith2 -> mul .)
    PERIOD          reduce using rule 35 (arith2 -> mul .)
    SEMICOLON       reduce using rule 35 (arith2 -> mul .)
    RSQUIGBRACKET   reduce using rule 35 (arith2 -> mul .)
    RPAREN          reduce using rule 35 (arith2 -> mul .)
    LPAREN          reduce using rule 35 (arith2 -> mul .)
    LOOP            reduce using rule 35 (arith2 -> mul .)
    WHILE           reduce using rule 35 (arith2 -> mul .)
    BOX             reduce using rule 35 (arith2 -> mul .)
    IF              reduce using rule 35 (arith2 -> mul .)
    MATCH           reduce using rule 35 (arith2 -> mul .)
    ID              reduce using rule 35 (arith2 -> mul .)
    NOT             reduce using rule 35 (arith2 -> mul .)
    AND             reduce using rule 35 (arith2 -> mul .)
    LITDEC          reduce using rule 35 (arith2 -> mul .)
    LITCHAR         reduce using rule 35 (arith2 -> mul .)
    LITBOOL         reduce using rule 35 (arith2 -> mul .)
    LITSTRING       reduce using rule 35 (arith2 -> mul .)
    COMMA           reduce using rule 35 (arith2 -> mul .)
    RBRACKET        reduce using rule 35 (arith2 -> mul .)


state 144

    (183) block -> LSQUIGBRACKET stmts . RSQUIGBRACKET

    RSQUIGBRACKET   shift and go to state 208


state 145

    (46) arith4 -> ptr .

    ADD             reduce using rule 46 (arith4 -> ptr .)
    SUB             reduce using rule 46 (arith4 -> ptr .)
    MUL             reduce using rule 46 (arith4 -> ptr .)
    DIV             reduce using rule 46 (arith4 -> ptr .)
    MODOP           reduce using rule 46 (arith4 -> ptr .)
    LESSTHAN        reduce using rule 46 (arith4 -> ptr .)
    LESSTHANOREQUAL reduce using rule 46 (arith4 -> ptr .)
    GREATERTHAN     reduce using rule 46 (arith4 -> ptr .)
    GREATERTHANOREQUAL reduce using rule 46 (arith4 -> ptr .)
    EQUALTO         reduce using rule 46 (arith4 -> ptr .)
    NOTEQUAL        reduce using rule 46 (arith4 -> ptr .)
    LOGICALOR       reduce using rule 46 (arith4 -> ptr .)
    LOGICALAND      reduce using rule 46 (arith4 -> ptr .)
    EQU             reduce using rule 46 (arith4 -> ptr .)
    PLUSEQUAL       reduce using rule 46 (arith4 -> ptr .)
    SUBEQUAL        reduce using rule 46 (arith4 -> ptr .)
    DIVEQUAL        reduce using rule 46 (arith4 -> ptr .)
    TIMESEQUAL      reduce using rule 46 (arith4 -> ptr .)
    MODEQUAL        reduce using rule 46 (arith4 -> ptr .)
    ANDEQUAL        reduce using rule 46 (arith4 -> ptr .)
    OREQUAL         reduce using rule 46 (arith4 -> ptr .)
    LBRACKET        reduce using rule 46 (arith4 -> ptr .)
    PERIOD          reduce using rule 46 (arith4 -> ptr .)
    SEMICOLON       reduce using rule 46 (arith4 -> ptr .)
    RSQUIGBRACKET   reduce using rule 46 (arith4 -> ptr .)
    RPAREN          reduce using rule 46 (arith4 -> ptr .)
    LPAREN          reduce using rule 46 (arith4 -> ptr .)
    LOOP            reduce using rule 46 (arith4 -> ptr .)
    WHILE           reduce using rule 46 (arith4 -> ptr .)
    BOX             reduce using rule 46 (arith4 -> ptr .)
    IF              reduce using rule 46 (arith4 -> ptr .)
    MATCH           reduce using rule 46 (arith4 -> ptr .)
    ID              reduce using rule 46 (arith4 -> ptr .)
    NOT             reduce using rule 46 (arith4 -> ptr .)
    AND             reduce using rule 46 (arith4 -> ptr .)
    LITDEC          reduce using rule 46 (arith4 -> ptr .)
    LITCHAR         reduce using rule 46 (arith4 -> ptr .)
    LITBOOL         reduce using rule 46 (arith4 -> ptr .)
    LITSTRING       reduce using rule 46 (arith4 -> ptr .)
    COMMA           reduce using rule 46 (arith4 -> ptr .)
    RBRACKET        reduce using rule 46 (arith4 -> ptr .)


state 146

    (23) exp -> box_new .

    RPAREN          reduce using rule 23 (exp -> box_new .)
    EQU             reduce using rule 23 (exp -> box_new .)
    PLUSEQUAL       reduce using rule 23 (exp -> box_new .)
    SUBEQUAL        reduce using rule 23 (exp -> box_new .)
    DIVEQUAL        reduce using rule 23 (exp -> box_new .)
    TIMESEQUAL      reduce using rule 23 (exp -> box_new .)
    MODEQUAL        reduce using rule 23 (exp -> box_new .)
    ANDEQUAL        reduce using rule 23 (exp -> box_new .)
    OREQUAL         reduce using rule 23 (exp -> box_new .)
    LBRACKET        reduce using rule 23 (exp -> box_new .)
    PERIOD          reduce using rule 23 (exp -> box_new .)
    SEMICOLON       reduce using rule 23 (exp -> box_new .)
    RSQUIGBRACKET   reduce using rule 23 (exp -> box_new .)
    LPAREN          reduce using rule 23 (exp -> box_new .)
    LOOP            reduce using rule 23 (exp -> box_new .)
    WHILE           reduce using rule 23 (exp -> box_new .)
    BOX             reduce using rule 23 (exp -> box_new .)
    IF              reduce using rule 23 (exp -> box_new .)
    MATCH           reduce using rule 23 (exp -> box_new .)
    ID              reduce using rule 23 (exp -> box_new .)
    SUB             reduce using rule 23 (exp -> box_new .)
    NOT             reduce using rule 23 (exp -> box_new .)
    AND             reduce using rule 23 (exp -> box_new .)
    MUL             reduce using rule 23 (exp -> box_new .)
    LITDEC          reduce using rule 23 (exp -> box_new .)
    LITCHAR         reduce using rule 23 (exp -> box_new .)
    LITBOOL         reduce using rule 23 (exp -> box_new .)
    LITSTRING       reduce using rule 23 (exp -> box_new .)
    COMMA           reduce using rule 23 (exp -> box_new .)
    RBRACKET        reduce using rule 23 (exp -> box_new .)


state 147

    (42) arith3 -> comp .

    ADD             reduce using rule 42 (arith3 -> comp .)
    SUB             reduce using rule 42 (arith3 -> comp .)
    MUL             reduce using rule 42 (arith3 -> comp .)
    DIV             reduce using rule 42 (arith3 -> comp .)
    MODOP           reduce using rule 42 (arith3 -> comp .)
    LESSTHAN        reduce using rule 42 (arith3 -> comp .)
    LESSTHANOREQUAL reduce using rule 42 (arith3 -> comp .)
    GREATERTHAN     reduce using rule 42 (arith3 -> comp .)
    GREATERTHANOREQUAL reduce using rule 42 (arith3 -> comp .)
    EQUALTO         reduce using rule 42 (arith3 -> comp .)
    NOTEQUAL        reduce using rule 42 (arith3 -> comp .)
    LOGICALOR       reduce using rule 42 (arith3 -> comp .)
    LOGICALAND      reduce using rule 42 (arith3 -> comp .)
    EQU             reduce using rule 42 (arith3 -> comp .)
    PLUSEQUAL       reduce using rule 42 (arith3 -> comp .)
    SUBEQUAL        reduce using rule 42 (arith3 -> comp .)
    DIVEQUAL        reduce using rule 42 (arith3 -> comp .)
    TIMESEQUAL      reduce using rule 42 (arith3 -> comp .)
    MODEQUAL        reduce using rule 42 (arith3 -> comp .)
    ANDEQUAL        reduce using rule 42 (arith3 -> comp .)
    OREQUAL         reduce using rule 42 (arith3 -> comp .)
    LBRACKET        reduce using rule 42 (arith3 -> comp .)
    PERIOD          reduce using rule 42 (arith3 -> comp .)
    SEMICOLON       reduce using rule 42 (arith3 -> comp .)
    RSQUIGBRACKET   reduce using rule 42 (arith3 -> comp .)
    RPAREN          reduce using rule 42 (arith3 -> comp .)
    LPAREN          reduce using rule 42 (arith3 -> comp .)
    LOOP            reduce using rule 42 (arith3 -> comp .)
    WHILE           reduce using rule 42 (arith3 -> comp .)
    BOX             reduce using rule 42 (arith3 -> comp .)
    IF              reduce using rule 42 (arith3 -> comp .)
    MATCH           reduce using rule 42 (arith3 -> comp .)
    ID              reduce using rule 42 (arith3 -> comp .)
    NOT             reduce using rule 42 (arith3 -> comp .)
    AND             reduce using rule 42 (arith3 -> comp .)
    LITDEC          reduce using rule 42 (arith3 -> comp .)
    LITCHAR         reduce using rule 42 (arith3 -> comp .)
    LITBOOL         reduce using rule 42 (arith3 -> comp .)
    LITSTRING       reduce using rule 42 (arith3 -> comp .)
    COMMA           reduce using rule 42 (arith3 -> comp .)
    RBRACKET        reduce using rule 42 (arith3 -> comp .)


state 148

    (55) comp -> leq .

    ADD             reduce using rule 55 (comp -> leq .)
    SUB             reduce using rule 55 (comp -> leq .)
    MUL             reduce using rule 55 (comp -> leq .)
    DIV             reduce using rule 55 (comp -> leq .)
    MODOP           reduce using rule 55 (comp -> leq .)
    LESSTHAN        reduce using rule 55 (comp -> leq .)
    LESSTHANOREQUAL reduce using rule 55 (comp -> leq .)
    GREATERTHAN     reduce using rule 55 (comp -> leq .)
    GREATERTHANOREQUAL reduce using rule 55 (comp -> leq .)
    EQUALTO         reduce using rule 55 (comp -> leq .)
    NOTEQUAL        reduce using rule 55 (comp -> leq .)
    LOGICALOR       reduce using rule 55 (comp -> leq .)
    LOGICALAND      reduce using rule 55 (comp -> leq .)
    EQU             reduce using rule 55 (comp -> leq .)
    PLUSEQUAL       reduce using rule 55 (comp -> leq .)
    SUBEQUAL        reduce using rule 55 (comp -> leq .)
    DIVEQUAL        reduce using rule 55 (comp -> leq .)
    TIMESEQUAL      reduce using rule 55 (comp -> leq .)
    MODEQUAL        reduce using rule 55 (comp -> leq .)
    ANDEQUAL        reduce using rule 55 (comp -> leq .)
    OREQUAL         reduce using rule 55 (comp -> leq .)
    LBRACKET        reduce using rule 55 (comp -> leq .)
    PERIOD          reduce using rule 55 (comp -> leq .)
    SEMICOLON       reduce using rule 55 (comp -> leq .)
    RSQUIGBRACKET   reduce using rule 55 (comp -> leq .)
    RPAREN          reduce using rule 55 (comp -> leq .)
    LPAREN          reduce using rule 55 (comp -> leq .)
    LOOP            reduce using rule 55 (comp -> leq .)
    WHILE           reduce using rule 55 (comp -> leq .)
    BOX             reduce using rule 55 (comp -> leq .)
    IF              reduce using rule 55 (comp -> leq .)
    MATCH           reduce using rule 55 (comp -> leq .)
    ID              reduce using rule 55 (comp -> leq .)
    NOT             reduce using rule 55 (comp -> leq .)
    AND             reduce using rule 55 (comp -> leq .)
    LITDEC          reduce using rule 55 (comp -> leq .)
    LITCHAR         reduce using rule 55 (comp -> leq .)
    LITBOOL         reduce using rule 55 (comp -> leq .)
    LITSTRING       reduce using rule 55 (comp -> leq .)
    COMMA           reduce using rule 55 (comp -> leq .)
    RBRACKET        reduce using rule 55 (comp -> leq .)


state 149

    (28) exp -> arr .

    RPAREN          reduce using rule 28 (exp -> arr .)
    EQU             reduce using rule 28 (exp -> arr .)
    PLUSEQUAL       reduce using rule 28 (exp -> arr .)
    SUBEQUAL        reduce using rule 28 (exp -> arr .)
    DIVEQUAL        reduce using rule 28 (exp -> arr .)
    TIMESEQUAL      reduce using rule 28 (exp -> arr .)
    MODEQUAL        reduce using rule 28 (exp -> arr .)
    ANDEQUAL        reduce using rule 28 (exp -> arr .)
    OREQUAL         reduce using rule 28 (exp -> arr .)
    LBRACKET        reduce using rule 28 (exp -> arr .)
    PERIOD          reduce using rule 28 (exp -> arr .)
    SEMICOLON       reduce using rule 28 (exp -> arr .)
    RSQUIGBRACKET   reduce using rule 28 (exp -> arr .)
    LPAREN          reduce using rule 28 (exp -> arr .)
    LOOP            reduce using rule 28 (exp -> arr .)
    WHILE           reduce using rule 28 (exp -> arr .)
    BOX             reduce using rule 28 (exp -> arr .)
    IF              reduce using rule 28 (exp -> arr .)
    MATCH           reduce using rule 28 (exp -> arr .)
    ID              reduce using rule 28 (exp -> arr .)
    SUB             reduce using rule 28 (exp -> arr .)
    NOT             reduce using rule 28 (exp -> arr .)
    AND             reduce using rule 28 (exp -> arr .)
    MUL             reduce using rule 28 (exp -> arr .)
    LITDEC          reduce using rule 28 (exp -> arr .)
    LITCHAR         reduce using rule 28 (exp -> arr .)
    LITBOOL         reduce using rule 28 (exp -> arr .)
    LITSTRING       reduce using rule 28 (exp -> arr .)
    COMMA           reduce using rule 28 (exp -> arr .)
    RBRACKET        reduce using rule 28 (exp -> arr .)


state 150

    (43) arith3 -> field_lookup .

    ADD             reduce using rule 43 (arith3 -> field_lookup .)
    SUB             reduce using rule 43 (arith3 -> field_lookup .)
    MUL             reduce using rule 43 (arith3 -> field_lookup .)
    DIV             reduce using rule 43 (arith3 -> field_lookup .)
    MODOP           reduce using rule 43 (arith3 -> field_lookup .)
    LESSTHAN        reduce using rule 43 (arith3 -> field_lookup .)
    LESSTHANOREQUAL reduce using rule 43 (arith3 -> field_lookup .)
    GREATERTHAN     reduce using rule 43 (arith3 -> field_lookup .)
    GREATERTHANOREQUAL reduce using rule 43 (arith3 -> field_lookup .)
    EQUALTO         reduce using rule 43 (arith3 -> field_lookup .)
    NOTEQUAL        reduce using rule 43 (arith3 -> field_lookup .)
    LOGICALOR       reduce using rule 43 (arith3 -> field_lookup .)
    LOGICALAND      reduce using rule 43 (arith3 -> field_lookup .)
    EQU             reduce using rule 43 (arith3 -> field_lookup .)
    PLUSEQUAL       reduce using rule 43 (arith3 -> field_lookup .)
    SUBEQUAL        reduce using rule 43 (arith3 -> field_lookup .)
    DIVEQUAL        reduce using rule 43 (arith3 -> field_lookup .)
    TIMESEQUAL      reduce using rule 43 (arith3 -> field_lookup .)
    MODEQUAL        reduce using rule 43 (arith3 -> field_lookup .)
    ANDEQUAL        reduce using rule 43 (arith3 -> field_lookup .)
    OREQUAL         reduce using rule 43 (arith3 -> field_lookup .)
    LBRACKET        reduce using rule 43 (arith3 -> field_lookup .)
    PERIOD          reduce using rule 43 (arith3 -> field_lookup .)
    SEMICOLON       reduce using rule 43 (arith3 -> field_lookup .)
    RSQUIGBRACKET   reduce using rule 43 (arith3 -> field_lookup .)
    RPAREN          reduce using rule 43 (arith3 -> field_lookup .)
    LPAREN          reduce using rule 43 (arith3 -> field_lookup .)
    LOOP            reduce using rule 43 (arith3 -> field_lookup .)
    WHILE           reduce using rule 43 (arith3 -> field_lookup .)
    BOX             reduce using rule 43 (arith3 -> field_lookup .)
    IF              reduce using rule 43 (arith3 -> field_lookup .)
    MATCH           reduce using rule 43 (arith3 -> field_lookup .)
    ID              reduce using rule 43 (arith3 -> field_lookup .)
    NOT             reduce using rule 43 (arith3 -> field_lookup .)
    AND             reduce using rule 43 (arith3 -> field_lookup .)
    LITDEC          reduce using rule 43 (arith3 -> field_lookup .)
    LITCHAR         reduce using rule 43 (arith3 -> field_lookup .)
    LITBOOL         reduce using rule 43 (arith3 -> field_lookup .)
    LITSTRING       reduce using rule 43 (arith3 -> field_lookup .)
    COMMA           reduce using rule 43 (arith3 -> field_lookup .)
    RBRACKET        reduce using rule 43 (arith3 -> field_lookup .)


state 151

    (12) stmt -> exp .
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

    SEMICOLON       reduce using rule 12 (stmt -> exp .)
    RSQUIGBRACKET   reduce using rule 12 (stmt -> exp .)
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216


state 152

    (29) exp -> arr_index .

    RPAREN          reduce using rule 29 (exp -> arr_index .)
    EQU             reduce using rule 29 (exp -> arr_index .)
    PLUSEQUAL       reduce using rule 29 (exp -> arr_index .)
    SUBEQUAL        reduce using rule 29 (exp -> arr_index .)
    DIVEQUAL        reduce using rule 29 (exp -> arr_index .)
    TIMESEQUAL      reduce using rule 29 (exp -> arr_index .)
    MODEQUAL        reduce using rule 29 (exp -> arr_index .)
    ANDEQUAL        reduce using rule 29 (exp -> arr_index .)
    OREQUAL         reduce using rule 29 (exp -> arr_index .)
    LBRACKET        reduce using rule 29 (exp -> arr_index .)
    PERIOD          reduce using rule 29 (exp -> arr_index .)
    SEMICOLON       reduce using rule 29 (exp -> arr_index .)
    RSQUIGBRACKET   reduce using rule 29 (exp -> arr_index .)
    LPAREN          reduce using rule 29 (exp -> arr_index .)
    LOOP            reduce using rule 29 (exp -> arr_index .)
    WHILE           reduce using rule 29 (exp -> arr_index .)
    BOX             reduce using rule 29 (exp -> arr_index .)
    IF              reduce using rule 29 (exp -> arr_index .)
    MATCH           reduce using rule 29 (exp -> arr_index .)
    ID              reduce using rule 29 (exp -> arr_index .)
    SUB             reduce using rule 29 (exp -> arr_index .)
    NOT             reduce using rule 29 (exp -> arr_index .)
    AND             reduce using rule 29 (exp -> arr_index .)
    MUL             reduce using rule 29 (exp -> arr_index .)
    LITDEC          reduce using rule 29 (exp -> arr_index .)
    LITCHAR         reduce using rule 29 (exp -> arr_index .)
    LITBOOL         reduce using rule 29 (exp -> arr_index .)
    LITSTRING       reduce using rule 29 (exp -> arr_index .)
    COMMA           reduce using rule 29 (exp -> arr_index .)
    RBRACKET        reduce using rule 29 (exp -> arr_index .)


state 153

    (57) comp -> geq .

    ADD             reduce using rule 57 (comp -> geq .)
    SUB             reduce using rule 57 (comp -> geq .)
    MUL             reduce using rule 57 (comp -> geq .)
    DIV             reduce using rule 57 (comp -> geq .)
    MODOP           reduce using rule 57 (comp -> geq .)
    LESSTHAN        reduce using rule 57 (comp -> geq .)
    LESSTHANOREQUAL reduce using rule 57 (comp -> geq .)
    GREATERTHAN     reduce using rule 57 (comp -> geq .)
    GREATERTHANOREQUAL reduce using rule 57 (comp -> geq .)
    EQUALTO         reduce using rule 57 (comp -> geq .)
    NOTEQUAL        reduce using rule 57 (comp -> geq .)
    LOGICALOR       reduce using rule 57 (comp -> geq .)
    LOGICALAND      reduce using rule 57 (comp -> geq .)
    EQU             reduce using rule 57 (comp -> geq .)
    PLUSEQUAL       reduce using rule 57 (comp -> geq .)
    SUBEQUAL        reduce using rule 57 (comp -> geq .)
    DIVEQUAL        reduce using rule 57 (comp -> geq .)
    TIMESEQUAL      reduce using rule 57 (comp -> geq .)
    MODEQUAL        reduce using rule 57 (comp -> geq .)
    ANDEQUAL        reduce using rule 57 (comp -> geq .)
    OREQUAL         reduce using rule 57 (comp -> geq .)
    LBRACKET        reduce using rule 57 (comp -> geq .)
    PERIOD          reduce using rule 57 (comp -> geq .)
    SEMICOLON       reduce using rule 57 (comp -> geq .)
    RSQUIGBRACKET   reduce using rule 57 (comp -> geq .)
    RPAREN          reduce using rule 57 (comp -> geq .)
    LPAREN          reduce using rule 57 (comp -> geq .)
    LOOP            reduce using rule 57 (comp -> geq .)
    WHILE           reduce using rule 57 (comp -> geq .)
    BOX             reduce using rule 57 (comp -> geq .)
    IF              reduce using rule 57 (comp -> geq .)
    MATCH           reduce using rule 57 (comp -> geq .)
    ID              reduce using rule 57 (comp -> geq .)
    NOT             reduce using rule 57 (comp -> geq .)
    AND             reduce using rule 57 (comp -> geq .)
    LITDEC          reduce using rule 57 (comp -> geq .)
    LITCHAR         reduce using rule 57 (comp -> geq .)
    LITBOOL         reduce using rule 57 (comp -> geq .)
    LITSTRING       reduce using rule 57 (comp -> geq .)
    COMMA           reduce using rule 57 (comp -> geq .)
    RBRACKET        reduce using rule 57 (comp -> geq .)


state 154

    (75) addr -> AND . arith4
    (76) addr -> AND . neg
    (79) addr_of_mut -> AND . MUT arith4
    (80) addr_of_mut -> AND . MUT neg
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (53) neg -> . SUB arith4
    (143) id -> . ID
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

    MUT             shift and go to state 221
    SUB             shift and go to state 156
    ID              shift and go to state 10
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

    ptr                            shift and go to state 145
    deref                          shift and go to state 167
    arith4                         shift and go to state 219
    lit                            shift and go to state 139
    addr_of_mut                    shift and go to state 168
    enum_con                       shift and go to state 133
    addr                           shift and go to state 127
    neg                            shift and go to state 220
    p_lit                          shift and go to state 116
    id                             shift and go to state 192

state 155

    (59) comp -> neq .

    ADD             reduce using rule 59 (comp -> neq .)
    SUB             reduce using rule 59 (comp -> neq .)
    MUL             reduce using rule 59 (comp -> neq .)
    DIV             reduce using rule 59 (comp -> neq .)
    MODOP           reduce using rule 59 (comp -> neq .)
    LESSTHAN        reduce using rule 59 (comp -> neq .)
    LESSTHANOREQUAL reduce using rule 59 (comp -> neq .)
    GREATERTHAN     reduce using rule 59 (comp -> neq .)
    GREATERTHANOREQUAL reduce using rule 59 (comp -> neq .)
    EQUALTO         reduce using rule 59 (comp -> neq .)
    NOTEQUAL        reduce using rule 59 (comp -> neq .)
    LOGICALOR       reduce using rule 59 (comp -> neq .)
    LOGICALAND      reduce using rule 59 (comp -> neq .)
    EQU             reduce using rule 59 (comp -> neq .)
    PLUSEQUAL       reduce using rule 59 (comp -> neq .)
    SUBEQUAL        reduce using rule 59 (comp -> neq .)
    DIVEQUAL        reduce using rule 59 (comp -> neq .)
    TIMESEQUAL      reduce using rule 59 (comp -> neq .)
    MODEQUAL        reduce using rule 59 (comp -> neq .)
    ANDEQUAL        reduce using rule 59 (comp -> neq .)
    OREQUAL         reduce using rule 59 (comp -> neq .)
    LBRACKET        reduce using rule 59 (comp -> neq .)
    PERIOD          reduce using rule 59 (comp -> neq .)
    SEMICOLON       reduce using rule 59 (comp -> neq .)
    RSQUIGBRACKET   reduce using rule 59 (comp -> neq .)
    RPAREN          reduce using rule 59 (comp -> neq .)
    LPAREN          reduce using rule 59 (comp -> neq .)
    LOOP            reduce using rule 59 (comp -> neq .)
    WHILE           reduce using rule 59 (comp -> neq .)
    BOX             reduce using rule 59 (comp -> neq .)
    IF              reduce using rule 59 (comp -> neq .)
    MATCH           reduce using rule 59 (comp -> neq .)
    ID              reduce using rule 59 (comp -> neq .)
    NOT             reduce using rule 59 (comp -> neq .)
    AND             reduce using rule 59 (comp -> neq .)
    LITDEC          reduce using rule 59 (comp -> neq .)
    LITCHAR         reduce using rule 59 (comp -> neq .)
    LITBOOL         reduce using rule 59 (comp -> neq .)
    LITSTRING       reduce using rule 59 (comp -> neq .)
    COMMA           reduce using rule 59 (comp -> neq .)
    RBRACKET        reduce using rule 59 (comp -> neq .)


state 156

    (53) neg -> SUB . arith4
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (143) id -> . ID
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

    ID              shift and go to state 10
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

    ptr                            shift and go to state 145
    deref                          shift and go to state 167
    arith4                         shift and go to state 222
    lit                            shift and go to state 139
    enum_con                       shift and go to state 133
    addr                           shift and go to state 127
    id                             shift and go to state 192
    p_lit                          shift and go to state 116
    addr_of_mut                    shift and go to state 168

state 157

    (58) comp -> eq .

    ADD             reduce using rule 58 (comp -> eq .)
    SUB             reduce using rule 58 (comp -> eq .)
    MUL             reduce using rule 58 (comp -> eq .)
    DIV             reduce using rule 58 (comp -> eq .)
    MODOP           reduce using rule 58 (comp -> eq .)
    LESSTHAN        reduce using rule 58 (comp -> eq .)
    LESSTHANOREQUAL reduce using rule 58 (comp -> eq .)
    GREATERTHAN     reduce using rule 58 (comp -> eq .)
    GREATERTHANOREQUAL reduce using rule 58 (comp -> eq .)
    EQUALTO         reduce using rule 58 (comp -> eq .)
    NOTEQUAL        reduce using rule 58 (comp -> eq .)
    LOGICALOR       reduce using rule 58 (comp -> eq .)
    LOGICALAND      reduce using rule 58 (comp -> eq .)
    EQU             reduce using rule 58 (comp -> eq .)
    PLUSEQUAL       reduce using rule 58 (comp -> eq .)
    SUBEQUAL        reduce using rule 58 (comp -> eq .)
    DIVEQUAL        reduce using rule 58 (comp -> eq .)
    TIMESEQUAL      reduce using rule 58 (comp -> eq .)
    MODEQUAL        reduce using rule 58 (comp -> eq .)
    ANDEQUAL        reduce using rule 58 (comp -> eq .)
    OREQUAL         reduce using rule 58 (comp -> eq .)
    LBRACKET        reduce using rule 58 (comp -> eq .)
    PERIOD          reduce using rule 58 (comp -> eq .)
    SEMICOLON       reduce using rule 58 (comp -> eq .)
    RSQUIGBRACKET   reduce using rule 58 (comp -> eq .)
    RPAREN          reduce using rule 58 (comp -> eq .)
    LPAREN          reduce using rule 58 (comp -> eq .)
    LOOP            reduce using rule 58 (comp -> eq .)
    WHILE           reduce using rule 58 (comp -> eq .)
    BOX             reduce using rule 58 (comp -> eq .)
    IF              reduce using rule 58 (comp -> eq .)
    MATCH           reduce using rule 58 (comp -> eq .)
    ID              reduce using rule 58 (comp -> eq .)
    NOT             reduce using rule 58 (comp -> eq .)
    AND             reduce using rule 58 (comp -> eq .)
    LITDEC          reduce using rule 58 (comp -> eq .)
    LITCHAR         reduce using rule 58 (comp -> eq .)
    LITBOOL         reduce using rule 58 (comp -> eq .)
    LITSTRING       reduce using rule 58 (comp -> eq .)
    COMMA           reduce using rule 58 (comp -> eq .)
    RBRACKET        reduce using rule 58 (comp -> eq .)


state 158

    (71) not -> NOT . arith1
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (143) id -> . ID
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    SUB             shift and go to state 156
    LPAREN          shift and go to state 223
    ID              shift and go to state 10
    NOT             shift and go to state 158
    PERIOD          reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    arith4                         shift and go to state 119
    comp                           shift and go to state 147
    add                            shift and go to state 131
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    box_new                        shift and go to state 146
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    field_lookup                   shift and go to state 150
    exp                            shift and go to state 225
    gt                             shift and go to state 125
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    addr_of_mut                    shift and go to state 168
    match                          shift and go to state 124
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    and                            shift and go to state 165
    arith3                         shift and go to state 161
    id                             shift and go to state 226
    mod                            shift and go to state 164
    arith1                         shift and go to state 224
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    or                             shift and go to state 170
    arr_index                      shift and go to state 152

state 159

    (124) arr -> LBRACKET . exps RBRACKET
    (15) exps -> . exps
    (16) exps -> .
    (17) exps -> . exp COMMA exps
    (18) exps -> . exp
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! reduce/reduce conflict for RBRACKET resolved using rule 16 (exps -> .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACKET        reduce using rule 16 (exps -> .)
    LPAREN          shift and go to state 121
    COMMA           reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]
  ! RBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 228
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    mul                            shift and go to state 143
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    loop                           shift and go to state 126
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168
    exps                           shift and go to state 227

state 160

    (34) arith1 -> arith2 .

    ADD             reduce using rule 34 (arith1 -> arith2 .)
    SUB             reduce using rule 34 (arith1 -> arith2 .)
    MUL             reduce using rule 34 (arith1 -> arith2 .)
    DIV             reduce using rule 34 (arith1 -> arith2 .)
    MODOP           reduce using rule 34 (arith1 -> arith2 .)
    LESSTHAN        reduce using rule 34 (arith1 -> arith2 .)
    LESSTHANOREQUAL reduce using rule 34 (arith1 -> arith2 .)
    GREATERTHAN     reduce using rule 34 (arith1 -> arith2 .)
    GREATERTHANOREQUAL reduce using rule 34 (arith1 -> arith2 .)
    EQUALTO         reduce using rule 34 (arith1 -> arith2 .)
    NOTEQUAL        reduce using rule 34 (arith1 -> arith2 .)
    LOGICALOR       reduce using rule 34 (arith1 -> arith2 .)
    LOGICALAND      reduce using rule 34 (arith1 -> arith2 .)
    EQU             reduce using rule 34 (arith1 -> arith2 .)
    PLUSEQUAL       reduce using rule 34 (arith1 -> arith2 .)
    SUBEQUAL        reduce using rule 34 (arith1 -> arith2 .)
    DIVEQUAL        reduce using rule 34 (arith1 -> arith2 .)
    TIMESEQUAL      reduce using rule 34 (arith1 -> arith2 .)
    MODEQUAL        reduce using rule 34 (arith1 -> arith2 .)
    ANDEQUAL        reduce using rule 34 (arith1 -> arith2 .)
    OREQUAL         reduce using rule 34 (arith1 -> arith2 .)
    LBRACKET        reduce using rule 34 (arith1 -> arith2 .)
    PERIOD          reduce using rule 34 (arith1 -> arith2 .)
    SEMICOLON       reduce using rule 34 (arith1 -> arith2 .)
    RSQUIGBRACKET   reduce using rule 34 (arith1 -> arith2 .)
    RPAREN          reduce using rule 34 (arith1 -> arith2 .)
    LPAREN          reduce using rule 34 (arith1 -> arith2 .)
    LOOP            reduce using rule 34 (arith1 -> arith2 .)
    WHILE           reduce using rule 34 (arith1 -> arith2 .)
    BOX             reduce using rule 34 (arith1 -> arith2 .)
    IF              reduce using rule 34 (arith1 -> arith2 .)
    MATCH           reduce using rule 34 (arith1 -> arith2 .)
    ID              reduce using rule 34 (arith1 -> arith2 .)
    NOT             reduce using rule 34 (arith1 -> arith2 .)
    AND             reduce using rule 34 (arith1 -> arith2 .)
    LITDEC          reduce using rule 34 (arith1 -> arith2 .)
    LITCHAR         reduce using rule 34 (arith1 -> arith2 .)
    LITBOOL         reduce using rule 34 (arith1 -> arith2 .)
    LITSTRING       reduce using rule 34 (arith1 -> arith2 .)
    COMMA           reduce using rule 34 (arith1 -> arith2 .)
    RBRACKET        reduce using rule 34 (arith1 -> arith2 .)


state 161

    (39) arith2 -> arith3 .

    ADD             reduce using rule 39 (arith2 -> arith3 .)
    SUB             reduce using rule 39 (arith2 -> arith3 .)
    MUL             reduce using rule 39 (arith2 -> arith3 .)
    DIV             reduce using rule 39 (arith2 -> arith3 .)
    MODOP           reduce using rule 39 (arith2 -> arith3 .)
    LESSTHAN        reduce using rule 39 (arith2 -> arith3 .)
    LESSTHANOREQUAL reduce using rule 39 (arith2 -> arith3 .)
    GREATERTHAN     reduce using rule 39 (arith2 -> arith3 .)
    GREATERTHANOREQUAL reduce using rule 39 (arith2 -> arith3 .)
    EQUALTO         reduce using rule 39 (arith2 -> arith3 .)
    NOTEQUAL        reduce using rule 39 (arith2 -> arith3 .)
    LOGICALOR       reduce using rule 39 (arith2 -> arith3 .)
    LOGICALAND      reduce using rule 39 (arith2 -> arith3 .)
    EQU             reduce using rule 39 (arith2 -> arith3 .)
    PLUSEQUAL       reduce using rule 39 (arith2 -> arith3 .)
    SUBEQUAL        reduce using rule 39 (arith2 -> arith3 .)
    DIVEQUAL        reduce using rule 39 (arith2 -> arith3 .)
    TIMESEQUAL      reduce using rule 39 (arith2 -> arith3 .)
    MODEQUAL        reduce using rule 39 (arith2 -> arith3 .)
    ANDEQUAL        reduce using rule 39 (arith2 -> arith3 .)
    OREQUAL         reduce using rule 39 (arith2 -> arith3 .)
    LBRACKET        reduce using rule 39 (arith2 -> arith3 .)
    PERIOD          reduce using rule 39 (arith2 -> arith3 .)
    SEMICOLON       reduce using rule 39 (arith2 -> arith3 .)
    RSQUIGBRACKET   reduce using rule 39 (arith2 -> arith3 .)
    RPAREN          reduce using rule 39 (arith2 -> arith3 .)
    LPAREN          reduce using rule 39 (arith2 -> arith3 .)
    LOOP            reduce using rule 39 (arith2 -> arith3 .)
    WHILE           reduce using rule 39 (arith2 -> arith3 .)
    BOX             reduce using rule 39 (arith2 -> arith3 .)
    IF              reduce using rule 39 (arith2 -> arith3 .)
    MATCH           reduce using rule 39 (arith2 -> arith3 .)
    ID              reduce using rule 39 (arith2 -> arith3 .)
    NOT             reduce using rule 39 (arith2 -> arith3 .)
    AND             reduce using rule 39 (arith2 -> arith3 .)
    LITDEC          reduce using rule 39 (arith2 -> arith3 .)
    LITCHAR         reduce using rule 39 (arith2 -> arith3 .)
    LITBOOL         reduce using rule 39 (arith2 -> arith3 .)
    LITSTRING       reduce using rule 39 (arith2 -> arith3 .)
    COMMA           reduce using rule 39 (arith2 -> arith3 .)
    RBRACKET        reduce using rule 39 (arith2 -> arith3 .)


state 162

    (95) while -> WHILE . LPAREN exp RPAREN block

    LPAREN          shift and go to state 229


state 163

    (186) arg_struct -> id . LSQUIGBRACKET body RSQUIGBRACKET
    (128) fn_call -> id . LPAREN fn_args RPAREN
    (45) arith4 -> id .
    (192) enum_con -> id . CLASSACCESS id

  ! shift/reduce conflict for LPAREN resolved as shift
    LSQUIGBRACKET   shift and go to state 230
    LPAREN          shift and go to state 231
    ADD             reduce using rule 45 (arith4 -> id .)
    SUB             reduce using rule 45 (arith4 -> id .)
    MUL             reduce using rule 45 (arith4 -> id .)
    DIV             reduce using rule 45 (arith4 -> id .)
    MODOP           reduce using rule 45 (arith4 -> id .)
    LESSTHAN        reduce using rule 45 (arith4 -> id .)
    LESSTHANOREQUAL reduce using rule 45 (arith4 -> id .)
    GREATERTHAN     reduce using rule 45 (arith4 -> id .)
    GREATERTHANOREQUAL reduce using rule 45 (arith4 -> id .)
    EQUALTO         reduce using rule 45 (arith4 -> id .)
    NOTEQUAL        reduce using rule 45 (arith4 -> id .)
    LOGICALOR       reduce using rule 45 (arith4 -> id .)
    LOGICALAND      reduce using rule 45 (arith4 -> id .)
    EQU             reduce using rule 45 (arith4 -> id .)
    PLUSEQUAL       reduce using rule 45 (arith4 -> id .)
    SUBEQUAL        reduce using rule 45 (arith4 -> id .)
    DIVEQUAL        reduce using rule 45 (arith4 -> id .)
    TIMESEQUAL      reduce using rule 45 (arith4 -> id .)
    MODEQUAL        reduce using rule 45 (arith4 -> id .)
    ANDEQUAL        reduce using rule 45 (arith4 -> id .)
    OREQUAL         reduce using rule 45 (arith4 -> id .)
    LBRACKET        reduce using rule 45 (arith4 -> id .)
    PERIOD          reduce using rule 45 (arith4 -> id .)
    SEMICOLON       reduce using rule 45 (arith4 -> id .)
    RSQUIGBRACKET   reduce using rule 45 (arith4 -> id .)
    RPAREN          reduce using rule 45 (arith4 -> id .)
    LOOP            reduce using rule 45 (arith4 -> id .)
    WHILE           reduce using rule 45 (arith4 -> id .)
    BOX             reduce using rule 45 (arith4 -> id .)
    IF              reduce using rule 45 (arith4 -> id .)
    MATCH           reduce using rule 45 (arith4 -> id .)
    ID              reduce using rule 45 (arith4 -> id .)
    NOT             reduce using rule 45 (arith4 -> id .)
    AND             reduce using rule 45 (arith4 -> id .)
    LITDEC          reduce using rule 45 (arith4 -> id .)
    LITCHAR         reduce using rule 45 (arith4 -> id .)
    LITBOOL         reduce using rule 45 (arith4 -> id .)
    LITSTRING       reduce using rule 45 (arith4 -> id .)
    COMMA           reduce using rule 45 (arith4 -> id .)
    RBRACKET        reduce using rule 45 (arith4 -> id .)
    CLASSACCESS     shift and go to state 232

  ! LPAREN          [ reduce using rule 45 (arith4 -> id .) ]


state 164

    (37) arith2 -> mod .

    ADD             reduce using rule 37 (arith2 -> mod .)
    SUB             reduce using rule 37 (arith2 -> mod .)
    MUL             reduce using rule 37 (arith2 -> mod .)
    DIV             reduce using rule 37 (arith2 -> mod .)
    MODOP           reduce using rule 37 (arith2 -> mod .)
    LESSTHAN        reduce using rule 37 (arith2 -> mod .)
    LESSTHANOREQUAL reduce using rule 37 (arith2 -> mod .)
    GREATERTHAN     reduce using rule 37 (arith2 -> mod .)
    GREATERTHANOREQUAL reduce using rule 37 (arith2 -> mod .)
    EQUALTO         reduce using rule 37 (arith2 -> mod .)
    NOTEQUAL        reduce using rule 37 (arith2 -> mod .)
    LOGICALOR       reduce using rule 37 (arith2 -> mod .)
    LOGICALAND      reduce using rule 37 (arith2 -> mod .)
    EQU             reduce using rule 37 (arith2 -> mod .)
    PLUSEQUAL       reduce using rule 37 (arith2 -> mod .)
    SUBEQUAL        reduce using rule 37 (arith2 -> mod .)
    DIVEQUAL        reduce using rule 37 (arith2 -> mod .)
    TIMESEQUAL      reduce using rule 37 (arith2 -> mod .)
    MODEQUAL        reduce using rule 37 (arith2 -> mod .)
    ANDEQUAL        reduce using rule 37 (arith2 -> mod .)
    OREQUAL         reduce using rule 37 (arith2 -> mod .)
    LBRACKET        reduce using rule 37 (arith2 -> mod .)
    PERIOD          reduce using rule 37 (arith2 -> mod .)
    SEMICOLON       reduce using rule 37 (arith2 -> mod .)
    RSQUIGBRACKET   reduce using rule 37 (arith2 -> mod .)
    RPAREN          reduce using rule 37 (arith2 -> mod .)
    LPAREN          reduce using rule 37 (arith2 -> mod .)
    LOOP            reduce using rule 37 (arith2 -> mod .)
    WHILE           reduce using rule 37 (arith2 -> mod .)
    BOX             reduce using rule 37 (arith2 -> mod .)
    IF              reduce using rule 37 (arith2 -> mod .)
    MATCH           reduce using rule 37 (arith2 -> mod .)
    ID              reduce using rule 37 (arith2 -> mod .)
    NOT             reduce using rule 37 (arith2 -> mod .)
    AND             reduce using rule 37 (arith2 -> mod .)
    LITDEC          reduce using rule 37 (arith2 -> mod .)
    LITCHAR         reduce using rule 37 (arith2 -> mod .)
    LITBOOL         reduce using rule 37 (arith2 -> mod .)
    LITSTRING       reduce using rule 37 (arith2 -> mod .)
    COMMA           reduce using rule 37 (arith2 -> mod .)
    RBRACKET        reduce using rule 37 (arith2 -> mod .)


state 165

    (61) comp -> and .

    ADD             reduce using rule 61 (comp -> and .)
    SUB             reduce using rule 61 (comp -> and .)
    MUL             reduce using rule 61 (comp -> and .)
    DIV             reduce using rule 61 (comp -> and .)
    MODOP           reduce using rule 61 (comp -> and .)
    LESSTHAN        reduce using rule 61 (comp -> and .)
    LESSTHANOREQUAL reduce using rule 61 (comp -> and .)
    GREATERTHAN     reduce using rule 61 (comp -> and .)
    GREATERTHANOREQUAL reduce using rule 61 (comp -> and .)
    EQUALTO         reduce using rule 61 (comp -> and .)
    NOTEQUAL        reduce using rule 61 (comp -> and .)
    LOGICALOR       reduce using rule 61 (comp -> and .)
    LOGICALAND      reduce using rule 61 (comp -> and .)
    EQU             reduce using rule 61 (comp -> and .)
    PLUSEQUAL       reduce using rule 61 (comp -> and .)
    SUBEQUAL        reduce using rule 61 (comp -> and .)
    DIVEQUAL        reduce using rule 61 (comp -> and .)
    TIMESEQUAL      reduce using rule 61 (comp -> and .)
    MODEQUAL        reduce using rule 61 (comp -> and .)
    ANDEQUAL        reduce using rule 61 (comp -> and .)
    OREQUAL         reduce using rule 61 (comp -> and .)
    LBRACKET        reduce using rule 61 (comp -> and .)
    PERIOD          reduce using rule 61 (comp -> and .)
    SEMICOLON       reduce using rule 61 (comp -> and .)
    RSQUIGBRACKET   reduce using rule 61 (comp -> and .)
    RPAREN          reduce using rule 61 (comp -> and .)
    LPAREN          reduce using rule 61 (comp -> and .)
    LOOP            reduce using rule 61 (comp -> and .)
    WHILE           reduce using rule 61 (comp -> and .)
    BOX             reduce using rule 61 (comp -> and .)
    IF              reduce using rule 61 (comp -> and .)
    MATCH           reduce using rule 61 (comp -> and .)
    ID              reduce using rule 61 (comp -> and .)
    NOT             reduce using rule 61 (comp -> and .)
    AND             reduce using rule 61 (comp -> and .)
    LITDEC          reduce using rule 61 (comp -> and .)
    LITCHAR         reduce using rule 61 (comp -> and .)
    LITBOOL         reduce using rule 61 (comp -> and .)
    LITSTRING       reduce using rule 61 (comp -> and .)
    COMMA           reduce using rule 61 (comp -> and .)
    RBRACKET        reduce using rule 61 (comp -> and .)


state 166

    (96) loop -> LOOP . block
    (183) block -> . LSQUIGBRACKET stmts RSQUIGBRACKET

    LSQUIGBRACKET   shift and go to state 91

    block                          shift and go to state 233

state 167

    (73) ptr -> deref .

    ADD             reduce using rule 73 (ptr -> deref .)
    SUB             reduce using rule 73 (ptr -> deref .)
    MUL             reduce using rule 73 (ptr -> deref .)
    DIV             reduce using rule 73 (ptr -> deref .)
    MODOP           reduce using rule 73 (ptr -> deref .)
    LESSTHAN        reduce using rule 73 (ptr -> deref .)
    LESSTHANOREQUAL reduce using rule 73 (ptr -> deref .)
    GREATERTHAN     reduce using rule 73 (ptr -> deref .)
    GREATERTHANOREQUAL reduce using rule 73 (ptr -> deref .)
    EQUALTO         reduce using rule 73 (ptr -> deref .)
    NOTEQUAL        reduce using rule 73 (ptr -> deref .)
    LOGICALOR       reduce using rule 73 (ptr -> deref .)
    LOGICALAND      reduce using rule 73 (ptr -> deref .)
    EQU             reduce using rule 73 (ptr -> deref .)
    PLUSEQUAL       reduce using rule 73 (ptr -> deref .)
    SUBEQUAL        reduce using rule 73 (ptr -> deref .)
    DIVEQUAL        reduce using rule 73 (ptr -> deref .)
    TIMESEQUAL      reduce using rule 73 (ptr -> deref .)
    MODEQUAL        reduce using rule 73 (ptr -> deref .)
    ANDEQUAL        reduce using rule 73 (ptr -> deref .)
    OREQUAL         reduce using rule 73 (ptr -> deref .)
    LBRACKET        reduce using rule 73 (ptr -> deref .)
    PERIOD          reduce using rule 73 (ptr -> deref .)
    SEMICOLON       reduce using rule 73 (ptr -> deref .)
    RSQUIGBRACKET   reduce using rule 73 (ptr -> deref .)
    RPAREN          reduce using rule 73 (ptr -> deref .)
    LPAREN          reduce using rule 73 (ptr -> deref .)
    LOOP            reduce using rule 73 (ptr -> deref .)
    WHILE           reduce using rule 73 (ptr -> deref .)
    BOX             reduce using rule 73 (ptr -> deref .)
    IF              reduce using rule 73 (ptr -> deref .)
    MATCH           reduce using rule 73 (ptr -> deref .)
    ID              reduce using rule 73 (ptr -> deref .)
    NOT             reduce using rule 73 (ptr -> deref .)
    AND             reduce using rule 73 (ptr -> deref .)
    LITDEC          reduce using rule 73 (ptr -> deref .)
    LITCHAR         reduce using rule 73 (ptr -> deref .)
    LITBOOL         reduce using rule 73 (ptr -> deref .)
    LITSTRING       reduce using rule 73 (ptr -> deref .)
    COMMA           reduce using rule 73 (ptr -> deref .)
    RBRACKET        reduce using rule 73 (ptr -> deref .)


state 168

    (74) ptr -> addr_of_mut .

    ADD             reduce using rule 74 (ptr -> addr_of_mut .)
    SUB             reduce using rule 74 (ptr -> addr_of_mut .)
    MUL             reduce using rule 74 (ptr -> addr_of_mut .)
    DIV             reduce using rule 74 (ptr -> addr_of_mut .)
    MODOP           reduce using rule 74 (ptr -> addr_of_mut .)
    LESSTHAN        reduce using rule 74 (ptr -> addr_of_mut .)
    LESSTHANOREQUAL reduce using rule 74 (ptr -> addr_of_mut .)
    GREATERTHAN     reduce using rule 74 (ptr -> addr_of_mut .)
    GREATERTHANOREQUAL reduce using rule 74 (ptr -> addr_of_mut .)
    EQUALTO         reduce using rule 74 (ptr -> addr_of_mut .)
    NOTEQUAL        reduce using rule 74 (ptr -> addr_of_mut .)
    LOGICALOR       reduce using rule 74 (ptr -> addr_of_mut .)
    LOGICALAND      reduce using rule 74 (ptr -> addr_of_mut .)
    EQU             reduce using rule 74 (ptr -> addr_of_mut .)
    PLUSEQUAL       reduce using rule 74 (ptr -> addr_of_mut .)
    SUBEQUAL        reduce using rule 74 (ptr -> addr_of_mut .)
    DIVEQUAL        reduce using rule 74 (ptr -> addr_of_mut .)
    TIMESEQUAL      reduce using rule 74 (ptr -> addr_of_mut .)
    MODEQUAL        reduce using rule 74 (ptr -> addr_of_mut .)
    ANDEQUAL        reduce using rule 74 (ptr -> addr_of_mut .)
    OREQUAL         reduce using rule 74 (ptr -> addr_of_mut .)
    LBRACKET        reduce using rule 74 (ptr -> addr_of_mut .)
    PERIOD          reduce using rule 74 (ptr -> addr_of_mut .)
    SEMICOLON       reduce using rule 74 (ptr -> addr_of_mut .)
    RSQUIGBRACKET   reduce using rule 74 (ptr -> addr_of_mut .)
    RPAREN          reduce using rule 74 (ptr -> addr_of_mut .)
    LPAREN          reduce using rule 74 (ptr -> addr_of_mut .)
    LOOP            reduce using rule 74 (ptr -> addr_of_mut .)
    WHILE           reduce using rule 74 (ptr -> addr_of_mut .)
    BOX             reduce using rule 74 (ptr -> addr_of_mut .)
    IF              reduce using rule 74 (ptr -> addr_of_mut .)
    MATCH           reduce using rule 74 (ptr -> addr_of_mut .)
    ID              reduce using rule 74 (ptr -> addr_of_mut .)
    NOT             reduce using rule 74 (ptr -> addr_of_mut .)
    AND             reduce using rule 74 (ptr -> addr_of_mut .)
    LITDEC          reduce using rule 74 (ptr -> addr_of_mut .)
    LITCHAR         reduce using rule 74 (ptr -> addr_of_mut .)
    LITBOOL         reduce using rule 74 (ptr -> addr_of_mut .)
    LITSTRING       reduce using rule 74 (ptr -> addr_of_mut .)
    COMMA           reduce using rule 74 (ptr -> addr_of_mut .)
    RBRACKET        reduce using rule 74 (ptr -> addr_of_mut .)


state 169

    (97) if -> IF . LPAREN exp RPAREN block

    LPAREN          shift and go to state 234


state 170

    (60) comp -> or .

    ADD             reduce using rule 60 (comp -> or .)
    SUB             reduce using rule 60 (comp -> or .)
    MUL             reduce using rule 60 (comp -> or .)
    DIV             reduce using rule 60 (comp -> or .)
    MODOP           reduce using rule 60 (comp -> or .)
    LESSTHAN        reduce using rule 60 (comp -> or .)
    LESSTHANOREQUAL reduce using rule 60 (comp -> or .)
    GREATERTHAN     reduce using rule 60 (comp -> or .)
    GREATERTHANOREQUAL reduce using rule 60 (comp -> or .)
    EQUALTO         reduce using rule 60 (comp -> or .)
    NOTEQUAL        reduce using rule 60 (comp -> or .)
    LOGICALOR       reduce using rule 60 (comp -> or .)
    LOGICALAND      reduce using rule 60 (comp -> or .)
    EQU             reduce using rule 60 (comp -> or .)
    PLUSEQUAL       reduce using rule 60 (comp -> or .)
    SUBEQUAL        reduce using rule 60 (comp -> or .)
    DIVEQUAL        reduce using rule 60 (comp -> or .)
    TIMESEQUAL      reduce using rule 60 (comp -> or .)
    MODEQUAL        reduce using rule 60 (comp -> or .)
    ANDEQUAL        reduce using rule 60 (comp -> or .)
    OREQUAL         reduce using rule 60 (comp -> or .)
    LBRACKET        reduce using rule 60 (comp -> or .)
    PERIOD          reduce using rule 60 (comp -> or .)
    SEMICOLON       reduce using rule 60 (comp -> or .)
    RSQUIGBRACKET   reduce using rule 60 (comp -> or .)
    RPAREN          reduce using rule 60 (comp -> or .)
    LPAREN          reduce using rule 60 (comp -> or .)
    LOOP            reduce using rule 60 (comp -> or .)
    WHILE           reduce using rule 60 (comp -> or .)
    BOX             reduce using rule 60 (comp -> or .)
    IF              reduce using rule 60 (comp -> or .)
    MATCH           reduce using rule 60 (comp -> or .)
    ID              reduce using rule 60 (comp -> or .)
    NOT             reduce using rule 60 (comp -> or .)
    AND             reduce using rule 60 (comp -> or .)
    LITDEC          reduce using rule 60 (comp -> or .)
    LITCHAR         reduce using rule 60 (comp -> or .)
    LITBOOL         reduce using rule 60 (comp -> or .)
    LITSTRING       reduce using rule 60 (comp -> or .)
    COMMA           reduce using rule 60 (comp -> or .)
    RBRACKET        reduce using rule 60 (comp -> or .)


state 171

    (127) function -> FN id LPAREN fn_params_seq RPAREN OBJECTACCESS type . block
    (183) block -> . LSQUIGBRACKET stmts RSQUIGBRACKET

    LSQUIGBRACKET   shift and go to state 91

    block                          shift and go to state 235

state 172

    (193) pat_enum -> pat_enum LPAREN pats RPAREN .

    LPAREN          reduce using rule 193 (pat_enum -> pat_enum LPAREN pats RPAREN .)
    COMMA           reduce using rule 193 (pat_enum -> pat_enum LPAREN pats RPAREN .)
    RSQUIGBRACKET   reduce using rule 193 (pat_enum -> pat_enum LPAREN pats RPAREN .)
    COLON           reduce using rule 193 (pat_enum -> pat_enum LPAREN pats RPAREN .)
    RBRACKET        reduce using rule 193 (pat_enum -> pat_enum LPAREN pats RPAREN .)
    RPAREN          reduce using rule 193 (pat_enum -> pat_enum LPAREN pats RPAREN .)
    EQU             reduce using rule 193 (pat_enum -> pat_enum LPAREN pats RPAREN .)
    SEMICOLON       reduce using rule 193 (pat_enum -> pat_enum LPAREN pats RPAREN .)
    OR              reduce using rule 193 (pat_enum -> pat_enum LPAREN pats RPAREN .)
    PIPE            reduce using rule 193 (pat_enum -> pat_enum LPAREN pats RPAREN .)


state 173

    (105) pats -> pat COMMA pats .

    RPAREN          reduce using rule 105 (pats -> pat COMMA pats .)
    RBRACKET        reduce using rule 105 (pats -> pat COMMA pats .)


state 174

    (120) pat_struct -> id LSQUIGBRACKET pat_fields RSQUIGBRACKET .

    COLON           reduce using rule 120 (pat_struct -> id LSQUIGBRACKET pat_fields RSQUIGBRACKET .)
    COMMA           reduce using rule 120 (pat_struct -> id LSQUIGBRACKET pat_fields RSQUIGBRACKET .)
    RSQUIGBRACKET   reduce using rule 120 (pat_struct -> id LSQUIGBRACKET pat_fields RSQUIGBRACKET .)
    OR              reduce using rule 120 (pat_struct -> id LSQUIGBRACKET pat_fields RSQUIGBRACKET .)
    PIPE            reduce using rule 120 (pat_struct -> id LSQUIGBRACKET pat_fields RSQUIGBRACKET .)
    RBRACKET        reduce using rule 120 (pat_struct -> id LSQUIGBRACKET pat_fields RSQUIGBRACKET .)
    EQU             reduce using rule 120 (pat_struct -> id LSQUIGBRACKET pat_fields RSQUIGBRACKET .)
    SEMICOLON       reduce using rule 120 (pat_struct -> id LSQUIGBRACKET pat_fields RSQUIGBRACKET .)
    RPAREN          reduce using rule 120 (pat_struct -> id LSQUIGBRACKET pat_fields RSQUIGBRACKET .)


state 175

    (121) pat_fields -> pat_field COMMA . pat_fields
    (121) pat_fields -> . pat_field COMMA pat_fields
    (122) pat_fields -> . pat_field
    (123) pat_field -> . id COLON pat
    (143) id -> . ID

    ID              shift and go to state 10

    pat_fields                     shift and go to state 236
    pat_field                      shift and go to state 102
    id                             shift and go to state 103

state 176

    (123) pat_field -> id COLON . pat
    (107) pat -> . p_lit
    (108) pat -> . LPAREN RPAREN
    (109) pat -> . WC
    (110) pat -> . SUB p_lit
    (111) pat -> . id
    (112) pat -> . REF id
    (113) pat -> . REF MUT id
    (114) pat -> . MUT id
    (115) pat -> . AND pat
    (116) pat -> . pat_arr
    (117) pat -> . pat_enum
    (118) pat -> . pat_struct
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (143) id -> . ID
    (119) pat_arr -> . LBRACKET pats RBRACKET
    (193) pat_enum -> . pat_enum LPAREN pats RPAREN
    (194) pat_enum -> . id CLASSACCESS id
    (120) pat_struct -> . id LSQUIGBRACKET pat_fields RSQUIGBRACKET

    LPAREN          shift and go to state 29
    WC              shift and go to state 36
    SUB             shift and go to state 34
    REF             shift and go to state 32
    MUT             shift and go to state 33
    AND             shift and go to state 30
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40
    ID              shift and go to state 10
    LBRACKET        shift and go to state 41

    pat_arr                        shift and go to state 37
    pat                            shift and go to state 237
    id                             shift and go to state 43
    pat_struct                     shift and go to state 42
    p_lit                          shift and go to state 26
    pat_enum                       shift and go to state 35

state 177

    (176) box -> BOX LESSTHAN type . GREATERTHAN

    GREATERTHAN     shift and go to state 238


state 178

    (169) type -> AND MUT type .

    LSQUIGBRACKET   reduce using rule 169 (type -> AND MUT type .)
    COMMA           reduce using rule 169 (type -> AND MUT type .)
    ID              reduce using rule 169 (type -> AND MUT type .)
    RSQUIGBRACKET   reduce using rule 169 (type -> AND MUT type .)
    RPAREN          reduce using rule 169 (type -> AND MUT type .)
    RBRACKET        reduce using rule 169 (type -> AND MUT type .)
    SEMICOLON       reduce using rule 169 (type -> AND MUT type .)
    GREATERTHAN     reduce using rule 169 (type -> AND MUT type .)
    EQU             reduce using rule 169 (type -> AND MUT type .)


state 179

    (174) type_arr -> LBRACKET type SEMICOLON . p_lit RBRACKET
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING

    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

    p_lit                          shift and go to state 239

state 180

    (173) type_arr -> LBRACKET type RBRACKET .

    EQU             reduce using rule 173 (type_arr -> LBRACKET type RBRACKET .)
    SEMICOLON       reduce using rule 173 (type_arr -> LBRACKET type RBRACKET .)
    RSQUIGBRACKET   reduce using rule 173 (type_arr -> LBRACKET type RBRACKET .)
    RBRACKET        reduce using rule 173 (type_arr -> LBRACKET type RBRACKET .)
    COMMA           reduce using rule 173 (type_arr -> LBRACKET type RBRACKET .)
    ID              reduce using rule 173 (type_arr -> LBRACKET type RBRACKET .)
    RPAREN          reduce using rule 173 (type_arr -> LBRACKET type RBRACKET .)
    LSQUIGBRACKET   reduce using rule 173 (type_arr -> LBRACKET type RBRACKET .)
    GREATERTHAN     reduce using rule 173 (type_arr -> LBRACKET type RBRACKET .)


state 181

    (150) types -> type COMMA types .

    RPAREN          reduce using rule 150 (types -> type COMMA types .)


state 182

    (177) box_new -> BOX CLASSACCESS . NEW LPAREN exp RPAREN

    NEW             shift and go to state 240


state 183

    (90) let -> LET pat . COLON type EQU exp
    (91) let -> LET pat . COLON type
    (92) let -> LET pat . EQU exp
    (93) let -> LET pat .

    COLON           shift and go to state 242
    EQU             shift and go to state 241
    SEMICOLON       reduce using rule 93 (let -> LET pat .)
    RSQUIGBRACKET   reduce using rule 93 (let -> LET pat .)


state 184

    (40) arith3 -> LPAREN arith1 . RPAREN
    (20) exp -> arith1 .
    (48) add -> arith1 . ADD arith1
    (49) sub -> arith1 . SUB arith1
    (50) mul -> arith1 . MUL arith1
    (51) div -> arith1 . DIV arith1
    (52) mod -> arith1 . MODOP arith1
    (63) lt -> arith1 . LESSTHAN arith1
    (64) leq -> arith1 . LESSTHANOREQUAL arith1
    (65) gt -> arith1 . GREATERTHAN arith1
    (66) geq -> arith1 . GREATERTHANOREQUAL arith1
    (67) eq -> arith1 . EQUALTO arith1
    (68) neq -> arith1 . NOTEQUAL arith1
    (69) or -> arith1 . LOGICALOR arith1
    (70) and -> arith1 . LOGICALAND arith1

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 243
    EQU             reduce using rule 20 (exp -> arith1 .)
    PLUSEQUAL       reduce using rule 20 (exp -> arith1 .)
    SUBEQUAL        reduce using rule 20 (exp -> arith1 .)
    DIVEQUAL        reduce using rule 20 (exp -> arith1 .)
    TIMESEQUAL      reduce using rule 20 (exp -> arith1 .)
    MODEQUAL        reduce using rule 20 (exp -> arith1 .)
    ANDEQUAL        reduce using rule 20 (exp -> arith1 .)
    OREQUAL         reduce using rule 20 (exp -> arith1 .)
    LBRACKET        reduce using rule 20 (exp -> arith1 .)
    PERIOD          reduce using rule 20 (exp -> arith1 .)
    ADD             shift and go to state 204
    SUB             shift and go to state 195
    MUL             shift and go to state 199
    DIV             shift and go to state 197
    MODOP           shift and go to state 205
    LESSTHAN        shift and go to state 202
    LESSTHANOREQUAL shift and go to state 201
    GREATERTHAN     shift and go to state 194
    GREATERTHANOREQUAL shift and go to state 198
    EQUALTO         shift and go to state 206
    NOTEQUAL        shift and go to state 203
    LOGICALOR       shift and go to state 196
    LOGICALAND      shift and go to state 200

  ! RPAREN          [ reduce using rule 20 (exp -> arith1 .) ]


state 185

    (19) exp -> LPAREN exp . RPAREN
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

    RPAREN          shift and go to state 244
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216


state 186

    (81) unit -> LPAREN RPAREN .

    PERIOD          reduce using rule 81 (unit -> LPAREN RPAREN .)
    EQU             reduce using rule 81 (unit -> LPAREN RPAREN .)
    PLUSEQUAL       reduce using rule 81 (unit -> LPAREN RPAREN .)
    SUBEQUAL        reduce using rule 81 (unit -> LPAREN RPAREN .)
    DIVEQUAL        reduce using rule 81 (unit -> LPAREN RPAREN .)
    TIMESEQUAL      reduce using rule 81 (unit -> LPAREN RPAREN .)
    MODEQUAL        reduce using rule 81 (unit -> LPAREN RPAREN .)
    ANDEQUAL        reduce using rule 81 (unit -> LPAREN RPAREN .)
    OREQUAL         reduce using rule 81 (unit -> LPAREN RPAREN .)
    LBRACKET        reduce using rule 81 (unit -> LPAREN RPAREN .)
    SEMICOLON       reduce using rule 81 (unit -> LPAREN RPAREN .)
    RSQUIGBRACKET   reduce using rule 81 (unit -> LPAREN RPAREN .)
    RPAREN          reduce using rule 81 (unit -> LPAREN RPAREN .)
    LPAREN          reduce using rule 81 (unit -> LPAREN RPAREN .)
    LOOP            reduce using rule 81 (unit -> LPAREN RPAREN .)
    WHILE           reduce using rule 81 (unit -> LPAREN RPAREN .)
    BOX             reduce using rule 81 (unit -> LPAREN RPAREN .)
    IF              reduce using rule 81 (unit -> LPAREN RPAREN .)
    MATCH           reduce using rule 81 (unit -> LPAREN RPAREN .)
    ID              reduce using rule 81 (unit -> LPAREN RPAREN .)
    SUB             reduce using rule 81 (unit -> LPAREN RPAREN .)
    NOT             reduce using rule 81 (unit -> LPAREN RPAREN .)
    AND             reduce using rule 81 (unit -> LPAREN RPAREN .)
    MUL             reduce using rule 81 (unit -> LPAREN RPAREN .)
    LITDEC          reduce using rule 81 (unit -> LPAREN RPAREN .)
    LITCHAR         reduce using rule 81 (unit -> LPAREN RPAREN .)
    LITBOOL         reduce using rule 81 (unit -> LPAREN RPAREN .)
    LITSTRING       reduce using rule 81 (unit -> LPAREN RPAREN .)
    COMMA           reduce using rule 81 (unit -> LPAREN RPAREN .)
    RBRACKET        reduce using rule 81 (unit -> LPAREN RPAREN .)


state 187

    (8) stmts -> stmt SEMICOLON . stmts
    (8) stmts -> . stmt SEMICOLON stmts
    (9) stmts -> . stmt
    (10) stmts -> .
    (11) stmt -> . return
    (12) stmt -> . exp
    (13) stmt -> . let
    (14) stmt -> . function
    (184) return -> . RETURN
    (185) return -> . return exp
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (90) let -> . LET pat COLON type EQU exp
    (91) let -> . LET pat COLON type
    (92) let -> . LET pat EQU exp
    (93) let -> . LET pat
    (126) function -> . FN id LPAREN fn_params_seq RPAREN block
    (127) function -> . FN id LPAREN fn_params_seq RPAREN OBJECTACCESS type block
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! reduce/reduce conflict for RSQUIGBRACKET resolved using rule 10 (stmts -> .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    RSQUIGBRACKET   reduce using rule 10 (stmts -> .)
    RETURN          shift and go to state 120
    LPAREN          shift and go to state 121
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    SEMICOLON       reduce using rule 31 (exp -> .)
    LET             shift and go to state 118
    FN              shift and go to state 4
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]
  ! RSQUIGBRACKET   [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    arith3                         shift and go to state 161
    let                            shift and go to state 115
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    stmt                           shift and go to state 123
    match                          shift and go to state 124
    exp                            shift and go to state 151
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    return                         shift and go to state 132
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    mul                            shift and go to state 143
    function                       shift and go to state 135
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    loop                           shift and go to state 126
    gt                             shift and go to state 125
    stmts                          shift and go to state 245
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 188

    (185) return -> return exp .
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

  ! shift/reduce conflict for EQU resolved as shift
  ! shift/reduce conflict for PLUSEQUAL resolved as shift
  ! shift/reduce conflict for SUBEQUAL resolved as shift
  ! shift/reduce conflict for DIVEQUAL resolved as shift
  ! shift/reduce conflict for TIMESEQUAL resolved as shift
  ! shift/reduce conflict for MODEQUAL resolved as shift
  ! shift/reduce conflict for ANDEQUAL resolved as shift
  ! shift/reduce conflict for OREQUAL resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PERIOD resolved as shift
    LPAREN          reduce using rule 185 (return -> return exp .)
    LOOP            reduce using rule 185 (return -> return exp .)
    WHILE           reduce using rule 185 (return -> return exp .)
    BOX             reduce using rule 185 (return -> return exp .)
    IF              reduce using rule 185 (return -> return exp .)
    MATCH           reduce using rule 185 (return -> return exp .)
    ID              reduce using rule 185 (return -> return exp .)
    SUB             reduce using rule 185 (return -> return exp .)
    NOT             reduce using rule 185 (return -> return exp .)
    AND             reduce using rule 185 (return -> return exp .)
    MUL             reduce using rule 185 (return -> return exp .)
    LITDEC          reduce using rule 185 (return -> return exp .)
    LITCHAR         reduce using rule 185 (return -> return exp .)
    LITBOOL         reduce using rule 185 (return -> return exp .)
    LITSTRING       reduce using rule 185 (return -> return exp .)
    SEMICOLON       reduce using rule 185 (return -> return exp .)
    RSQUIGBRACKET   reduce using rule 185 (return -> return exp .)
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216

  ! LBRACKET        [ reduce using rule 185 (return -> return exp .) ]
  ! EQU             [ reduce using rule 185 (return -> return exp .) ]
  ! PLUSEQUAL       [ reduce using rule 185 (return -> return exp .) ]
  ! SUBEQUAL        [ reduce using rule 185 (return -> return exp .) ]
  ! DIVEQUAL        [ reduce using rule 185 (return -> return exp .) ]
  ! TIMESEQUAL      [ reduce using rule 185 (return -> return exp .) ]
  ! MODEQUAL        [ reduce using rule 185 (return -> return exp .) ]
  ! ANDEQUAL        [ reduce using rule 185 (return -> return exp .) ]
  ! OREQUAL         [ reduce using rule 185 (return -> return exp .) ]
  ! PERIOD          [ reduce using rule 185 (return -> return exp .) ]


state 189

    (191) enum_con -> enum_con LPAREN . exps RPAREN
    (15) exps -> . exps
    (16) exps -> .
    (17) exps -> . exp COMMA exps
    (18) exps -> . exp
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! reduce/reduce conflict for RPAREN resolved using rule 16 (exps -> .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    RPAREN          reduce using rule 16 (exps -> .)
    LPAREN          shift and go to state 121
    COMMA           reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]
  ! RPAREN          [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 228
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    mul                            shift and go to state 143
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    loop                           shift and go to state 126
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168
    exps                           shift and go to state 246

state 190

    (99) match -> MATCH LPAREN . exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    LPAREN          shift and go to state 121
    RPAREN          reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 247
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    mul                            shift and go to state 143
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    loop                           shift and go to state 126
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 191

    (77) deref -> MUL arith4 .

    ADD             reduce using rule 77 (deref -> MUL arith4 .)
    SUB             reduce using rule 77 (deref -> MUL arith4 .)
    MUL             reduce using rule 77 (deref -> MUL arith4 .)
    DIV             reduce using rule 77 (deref -> MUL arith4 .)
    MODOP           reduce using rule 77 (deref -> MUL arith4 .)
    LESSTHAN        reduce using rule 77 (deref -> MUL arith4 .)
    LESSTHANOREQUAL reduce using rule 77 (deref -> MUL arith4 .)
    GREATERTHAN     reduce using rule 77 (deref -> MUL arith4 .)
    GREATERTHANOREQUAL reduce using rule 77 (deref -> MUL arith4 .)
    EQUALTO         reduce using rule 77 (deref -> MUL arith4 .)
    NOTEQUAL        reduce using rule 77 (deref -> MUL arith4 .)
    LOGICALOR       reduce using rule 77 (deref -> MUL arith4 .)
    LOGICALAND      reduce using rule 77 (deref -> MUL arith4 .)
    EQU             reduce using rule 77 (deref -> MUL arith4 .)
    PLUSEQUAL       reduce using rule 77 (deref -> MUL arith4 .)
    SUBEQUAL        reduce using rule 77 (deref -> MUL arith4 .)
    DIVEQUAL        reduce using rule 77 (deref -> MUL arith4 .)
    TIMESEQUAL      reduce using rule 77 (deref -> MUL arith4 .)
    MODEQUAL        reduce using rule 77 (deref -> MUL arith4 .)
    ANDEQUAL        reduce using rule 77 (deref -> MUL arith4 .)
    OREQUAL         reduce using rule 77 (deref -> MUL arith4 .)
    LBRACKET        reduce using rule 77 (deref -> MUL arith4 .)
    PERIOD          reduce using rule 77 (deref -> MUL arith4 .)
    SEMICOLON       reduce using rule 77 (deref -> MUL arith4 .)
    RSQUIGBRACKET   reduce using rule 77 (deref -> MUL arith4 .)
    RPAREN          reduce using rule 77 (deref -> MUL arith4 .)
    LPAREN          reduce using rule 77 (deref -> MUL arith4 .)
    LOOP            reduce using rule 77 (deref -> MUL arith4 .)
    WHILE           reduce using rule 77 (deref -> MUL arith4 .)
    BOX             reduce using rule 77 (deref -> MUL arith4 .)
    IF              reduce using rule 77 (deref -> MUL arith4 .)
    MATCH           reduce using rule 77 (deref -> MUL arith4 .)
    ID              reduce using rule 77 (deref -> MUL arith4 .)
    NOT             reduce using rule 77 (deref -> MUL arith4 .)
    AND             reduce using rule 77 (deref -> MUL arith4 .)
    LITDEC          reduce using rule 77 (deref -> MUL arith4 .)
    LITCHAR         reduce using rule 77 (deref -> MUL arith4 .)
    LITBOOL         reduce using rule 77 (deref -> MUL arith4 .)
    LITSTRING       reduce using rule 77 (deref -> MUL arith4 .)
    COMMA           reduce using rule 77 (deref -> MUL arith4 .)
    RBRACKET        reduce using rule 77 (deref -> MUL arith4 .)


state 192

    (45) arith4 -> id .
    (192) enum_con -> id . CLASSACCESS id

    ADD             reduce using rule 45 (arith4 -> id .)
    SUB             reduce using rule 45 (arith4 -> id .)
    MUL             reduce using rule 45 (arith4 -> id .)
    DIV             reduce using rule 45 (arith4 -> id .)
    MODOP           reduce using rule 45 (arith4 -> id .)
    LESSTHAN        reduce using rule 45 (arith4 -> id .)
    LESSTHANOREQUAL reduce using rule 45 (arith4 -> id .)
    GREATERTHAN     reduce using rule 45 (arith4 -> id .)
    GREATERTHANOREQUAL reduce using rule 45 (arith4 -> id .)
    EQUALTO         reduce using rule 45 (arith4 -> id .)
    NOTEQUAL        reduce using rule 45 (arith4 -> id .)
    LOGICALOR       reduce using rule 45 (arith4 -> id .)
    LOGICALAND      reduce using rule 45 (arith4 -> id .)
    EQU             reduce using rule 45 (arith4 -> id .)
    PLUSEQUAL       reduce using rule 45 (arith4 -> id .)
    SUBEQUAL        reduce using rule 45 (arith4 -> id .)
    DIVEQUAL        reduce using rule 45 (arith4 -> id .)
    TIMESEQUAL      reduce using rule 45 (arith4 -> id .)
    MODEQUAL        reduce using rule 45 (arith4 -> id .)
    ANDEQUAL        reduce using rule 45 (arith4 -> id .)
    OREQUAL         reduce using rule 45 (arith4 -> id .)
    LBRACKET        reduce using rule 45 (arith4 -> id .)
    PERIOD          reduce using rule 45 (arith4 -> id .)
    SEMICOLON       reduce using rule 45 (arith4 -> id .)
    RSQUIGBRACKET   reduce using rule 45 (arith4 -> id .)
    RPAREN          reduce using rule 45 (arith4 -> id .)
    LPAREN          reduce using rule 45 (arith4 -> id .)
    LOOP            reduce using rule 45 (arith4 -> id .)
    WHILE           reduce using rule 45 (arith4 -> id .)
    BOX             reduce using rule 45 (arith4 -> id .)
    IF              reduce using rule 45 (arith4 -> id .)
    MATCH           reduce using rule 45 (arith4 -> id .)
    ID              reduce using rule 45 (arith4 -> id .)
    NOT             reduce using rule 45 (arith4 -> id .)
    AND             reduce using rule 45 (arith4 -> id .)
    LITDEC          reduce using rule 45 (arith4 -> id .)
    LITCHAR         reduce using rule 45 (arith4 -> id .)
    LITBOOL         reduce using rule 45 (arith4 -> id .)
    LITSTRING       reduce using rule 45 (arith4 -> id .)
    COMMA           reduce using rule 45 (arith4 -> id .)
    RBRACKET        reduce using rule 45 (arith4 -> id .)
    CLASSACCESS     shift and go to state 232


state 193

    (78) deref -> MUL neg .

    ADD             reduce using rule 78 (deref -> MUL neg .)
    SUB             reduce using rule 78 (deref -> MUL neg .)
    MUL             reduce using rule 78 (deref -> MUL neg .)
    DIV             reduce using rule 78 (deref -> MUL neg .)
    MODOP           reduce using rule 78 (deref -> MUL neg .)
    LESSTHAN        reduce using rule 78 (deref -> MUL neg .)
    LESSTHANOREQUAL reduce using rule 78 (deref -> MUL neg .)
    GREATERTHAN     reduce using rule 78 (deref -> MUL neg .)
    GREATERTHANOREQUAL reduce using rule 78 (deref -> MUL neg .)
    EQUALTO         reduce using rule 78 (deref -> MUL neg .)
    NOTEQUAL        reduce using rule 78 (deref -> MUL neg .)
    LOGICALOR       reduce using rule 78 (deref -> MUL neg .)
    LOGICALAND      reduce using rule 78 (deref -> MUL neg .)
    EQU             reduce using rule 78 (deref -> MUL neg .)
    PLUSEQUAL       reduce using rule 78 (deref -> MUL neg .)
    SUBEQUAL        reduce using rule 78 (deref -> MUL neg .)
    DIVEQUAL        reduce using rule 78 (deref -> MUL neg .)
    TIMESEQUAL      reduce using rule 78 (deref -> MUL neg .)
    MODEQUAL        reduce using rule 78 (deref -> MUL neg .)
    ANDEQUAL        reduce using rule 78 (deref -> MUL neg .)
    OREQUAL         reduce using rule 78 (deref -> MUL neg .)
    LBRACKET        reduce using rule 78 (deref -> MUL neg .)
    PERIOD          reduce using rule 78 (deref -> MUL neg .)
    SEMICOLON       reduce using rule 78 (deref -> MUL neg .)
    RSQUIGBRACKET   reduce using rule 78 (deref -> MUL neg .)
    RPAREN          reduce using rule 78 (deref -> MUL neg .)
    LPAREN          reduce using rule 78 (deref -> MUL neg .)
    LOOP            reduce using rule 78 (deref -> MUL neg .)
    WHILE           reduce using rule 78 (deref -> MUL neg .)
    BOX             reduce using rule 78 (deref -> MUL neg .)
    IF              reduce using rule 78 (deref -> MUL neg .)
    MATCH           reduce using rule 78 (deref -> MUL neg .)
    ID              reduce using rule 78 (deref -> MUL neg .)
    NOT             reduce using rule 78 (deref -> MUL neg .)
    AND             reduce using rule 78 (deref -> MUL neg .)
    LITDEC          reduce using rule 78 (deref -> MUL neg .)
    LITCHAR         reduce using rule 78 (deref -> MUL neg .)
    LITBOOL         reduce using rule 78 (deref -> MUL neg .)
    LITSTRING       reduce using rule 78 (deref -> MUL neg .)
    COMMA           reduce using rule 78 (deref -> MUL neg .)
    RBRACKET        reduce using rule 78 (deref -> MUL neg .)


state 194

    (65) gt -> arith1 GREATERTHAN . arith1
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (143) id -> . ID
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    SUB             shift and go to state 156
    LPAREN          shift and go to state 223
    ID              shift and go to state 10
    NOT             shift and go to state 158
    PERIOD          reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    arith4                         shift and go to state 119
    comp                           shift and go to state 147
    add                            shift and go to state 131
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    box_new                        shift and go to state 146
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    field_lookup                   shift and go to state 150
    exp                            shift and go to state 225
    gt                             shift and go to state 125
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    addr_of_mut                    shift and go to state 168
    match                          shift and go to state 124
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    and                            shift and go to state 165
    arith3                         shift and go to state 161
    id                             shift and go to state 226
    mod                            shift and go to state 164
    arith1                         shift and go to state 248
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    or                             shift and go to state 170
    arr_index                      shift and go to state 152

state 195

    (49) sub -> arith1 SUB . arith1
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (143) id -> . ID
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    SUB             shift and go to state 156
    LPAREN          shift and go to state 223
    ID              shift and go to state 10
    NOT             shift and go to state 158
    PERIOD          reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    arith4                         shift and go to state 119
    comp                           shift and go to state 147
    add                            shift and go to state 131
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    box_new                        shift and go to state 146
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    field_lookup                   shift and go to state 150
    exp                            shift and go to state 225
    gt                             shift and go to state 125
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    addr_of_mut                    shift and go to state 168
    match                          shift and go to state 124
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    and                            shift and go to state 165
    arith3                         shift and go to state 161
    id                             shift and go to state 226
    mod                            shift and go to state 164
    arith1                         shift and go to state 249
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    or                             shift and go to state 170
    arr_index                      shift and go to state 152

state 196

    (69) or -> arith1 LOGICALOR . arith1
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (143) id -> . ID
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    SUB             shift and go to state 156
    LPAREN          shift and go to state 223
    ID              shift and go to state 10
    NOT             shift and go to state 158
    PERIOD          reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    arith4                         shift and go to state 119
    comp                           shift and go to state 147
    add                            shift and go to state 131
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    box_new                        shift and go to state 146
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    field_lookup                   shift and go to state 150
    exp                            shift and go to state 225
    gt                             shift and go to state 125
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    addr_of_mut                    shift and go to state 168
    match                          shift and go to state 124
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    and                            shift and go to state 165
    arith3                         shift and go to state 161
    id                             shift and go to state 226
    mod                            shift and go to state 164
    arith1                         shift and go to state 250
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    or                             shift and go to state 170
    arr_index                      shift and go to state 152

state 197

    (51) div -> arith1 DIV . arith1
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (143) id -> . ID
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    SUB             shift and go to state 156
    LPAREN          shift and go to state 223
    ID              shift and go to state 10
    NOT             shift and go to state 158
    PERIOD          reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    arith4                         shift and go to state 119
    comp                           shift and go to state 147
    add                            shift and go to state 131
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    box_new                        shift and go to state 146
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    field_lookup                   shift and go to state 150
    exp                            shift and go to state 225
    gt                             shift and go to state 125
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    addr_of_mut                    shift and go to state 168
    match                          shift and go to state 124
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    and                            shift and go to state 165
    arith3                         shift and go to state 161
    id                             shift and go to state 226
    mod                            shift and go to state 164
    arith1                         shift and go to state 251
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    or                             shift and go to state 170
    arr_index                      shift and go to state 152

state 198

    (66) geq -> arith1 GREATERTHANOREQUAL . arith1
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (143) id -> . ID
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    SUB             shift and go to state 156
    LPAREN          shift and go to state 223
    ID              shift and go to state 10
    NOT             shift and go to state 158
    PERIOD          reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    arith4                         shift and go to state 119
    comp                           shift and go to state 147
    add                            shift and go to state 131
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    box_new                        shift and go to state 146
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    field_lookup                   shift and go to state 150
    exp                            shift and go to state 225
    gt                             shift and go to state 125
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    addr_of_mut                    shift and go to state 168
    match                          shift and go to state 124
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    and                            shift and go to state 165
    arith3                         shift and go to state 161
    id                             shift and go to state 226
    mod                            shift and go to state 164
    arith1                         shift and go to state 252
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    or                             shift and go to state 170
    arr_index                      shift and go to state 152

state 199

    (50) mul -> arith1 MUL . arith1
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (143) id -> . ID
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    SUB             shift and go to state 156
    LPAREN          shift and go to state 223
    ID              shift and go to state 10
    NOT             shift and go to state 158
    PERIOD          reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    arith4                         shift and go to state 119
    comp                           shift and go to state 147
    add                            shift and go to state 131
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    box_new                        shift and go to state 146
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    field_lookup                   shift and go to state 150
    exp                            shift and go to state 225
    gt                             shift and go to state 125
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    addr_of_mut                    shift and go to state 168
    match                          shift and go to state 124
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    and                            shift and go to state 165
    arith3                         shift and go to state 161
    id                             shift and go to state 226
    mod                            shift and go to state 164
    arith1                         shift and go to state 253
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    or                             shift and go to state 170
    arr_index                      shift and go to state 152

state 200

    (70) and -> arith1 LOGICALAND . arith1
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (143) id -> . ID
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    SUB             shift and go to state 156
    LPAREN          shift and go to state 223
    ID              shift and go to state 10
    NOT             shift and go to state 158
    PERIOD          reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    arith4                         shift and go to state 119
    comp                           shift and go to state 147
    add                            shift and go to state 131
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    box_new                        shift and go to state 146
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    field_lookup                   shift and go to state 150
    exp                            shift and go to state 225
    gt                             shift and go to state 125
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    addr_of_mut                    shift and go to state 168
    match                          shift and go to state 124
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    and                            shift and go to state 165
    arith3                         shift and go to state 161
    id                             shift and go to state 226
    mod                            shift and go to state 164
    arith1                         shift and go to state 254
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    or                             shift and go to state 170
    arr_index                      shift and go to state 152

state 201

    (64) leq -> arith1 LESSTHANOREQUAL . arith1
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (143) id -> . ID
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    SUB             shift and go to state 156
    LPAREN          shift and go to state 223
    ID              shift and go to state 10
    NOT             shift and go to state 158
    PERIOD          reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    arith4                         shift and go to state 119
    comp                           shift and go to state 147
    add                            shift and go to state 131
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    box_new                        shift and go to state 146
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    field_lookup                   shift and go to state 150
    exp                            shift and go to state 225
    gt                             shift and go to state 125
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    addr_of_mut                    shift and go to state 168
    match                          shift and go to state 124
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    and                            shift and go to state 165
    arith3                         shift and go to state 161
    id                             shift and go to state 226
    mod                            shift and go to state 164
    arith1                         shift and go to state 255
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    or                             shift and go to state 170
    arr_index                      shift and go to state 152

state 202

    (63) lt -> arith1 LESSTHAN . arith1
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (143) id -> . ID
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    SUB             shift and go to state 156
    LPAREN          shift and go to state 223
    ID              shift and go to state 10
    NOT             shift and go to state 158
    PERIOD          reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    arith4                         shift and go to state 119
    comp                           shift and go to state 147
    add                            shift and go to state 131
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    box_new                        shift and go to state 146
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    field_lookup                   shift and go to state 150
    exp                            shift and go to state 225
    gt                             shift and go to state 125
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    addr_of_mut                    shift and go to state 168
    match                          shift and go to state 124
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    and                            shift and go to state 165
    arith3                         shift and go to state 161
    id                             shift and go to state 226
    mod                            shift and go to state 164
    arith1                         shift and go to state 256
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    or                             shift and go to state 170
    arr_index                      shift and go to state 152

state 203

    (68) neq -> arith1 NOTEQUAL . arith1
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (143) id -> . ID
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    SUB             shift and go to state 156
    LPAREN          shift and go to state 223
    ID              shift and go to state 10
    NOT             shift and go to state 158
    PERIOD          reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    arith4                         shift and go to state 119
    comp                           shift and go to state 147
    add                            shift and go to state 131
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    box_new                        shift and go to state 146
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    field_lookup                   shift and go to state 150
    exp                            shift and go to state 225
    gt                             shift and go to state 125
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    addr_of_mut                    shift and go to state 168
    match                          shift and go to state 124
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    and                            shift and go to state 165
    arith3                         shift and go to state 161
    id                             shift and go to state 226
    mod                            shift and go to state 164
    arith1                         shift and go to state 257
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    or                             shift and go to state 170
    arr_index                      shift and go to state 152

state 204

    (48) add -> arith1 ADD . arith1
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (143) id -> . ID
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    SUB             shift and go to state 156
    LPAREN          shift and go to state 223
    ID              shift and go to state 10
    NOT             shift and go to state 158
    PERIOD          reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    arith4                         shift and go to state 119
    comp                           shift and go to state 147
    add                            shift and go to state 131
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    box_new                        shift and go to state 146
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    field_lookup                   shift and go to state 150
    exp                            shift and go to state 225
    gt                             shift and go to state 125
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    addr_of_mut                    shift and go to state 168
    match                          shift and go to state 124
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    and                            shift and go to state 165
    arith3                         shift and go to state 161
    id                             shift and go to state 226
    mod                            shift and go to state 164
    arith1                         shift and go to state 258
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    or                             shift and go to state 170
    arr_index                      shift and go to state 152

state 205

    (52) mod -> arith1 MODOP . arith1
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (143) id -> . ID
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    SUB             shift and go to state 156
    LPAREN          shift and go to state 223
    ID              shift and go to state 10
    NOT             shift and go to state 158
    PERIOD          reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    arith4                         shift and go to state 119
    comp                           shift and go to state 147
    add                            shift and go to state 131
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    box_new                        shift and go to state 146
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    field_lookup                   shift and go to state 150
    exp                            shift and go to state 225
    gt                             shift and go to state 125
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    addr_of_mut                    shift and go to state 168
    match                          shift and go to state 124
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    and                            shift and go to state 165
    arith3                         shift and go to state 161
    id                             shift and go to state 226
    mod                            shift and go to state 164
    arith1                         shift and go to state 259
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    or                             shift and go to state 170
    arr_index                      shift and go to state 152

state 206

    (67) eq -> arith1 EQUALTO . arith1
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (143) id -> . ID
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    SUB             shift and go to state 156
    LPAREN          shift and go to state 223
    ID              shift and go to state 10
    NOT             shift and go to state 158
    PERIOD          reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    arith4                         shift and go to state 119
    comp                           shift and go to state 147
    add                            shift and go to state 131
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    box_new                        shift and go to state 146
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    field_lookup                   shift and go to state 150
    exp                            shift and go to state 225
    gt                             shift and go to state 125
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    addr_of_mut                    shift and go to state 168
    match                          shift and go to state 124
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    and                            shift and go to state 165
    arith3                         shift and go to state 161
    id                             shift and go to state 226
    mod                            shift and go to state 164
    arith1                         shift and go to state 260
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    or                             shift and go to state 170
    arr_index                      shift and go to state 152

state 207

    (98) if -> if ELSE . block
    (183) block -> . LSQUIGBRACKET stmts RSQUIGBRACKET

    LSQUIGBRACKET   shift and go to state 91

    block                          shift and go to state 261

state 208

    (183) block -> LSQUIGBRACKET stmts RSQUIGBRACKET .

    FN              reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    STRUCT          reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    ENUM            reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    $end            reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    SEMICOLON       reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    RSQUIGBRACKET   reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    EQU             reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    PLUSEQUAL       reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    SUBEQUAL        reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    DIVEQUAL        reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    TIMESEQUAL      reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    MODEQUAL        reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    ANDEQUAL        reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    OREQUAL         reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    LBRACKET        reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    PERIOD          reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    RPAREN          reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    LPAREN          reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    LOOP            reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    WHILE           reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    BOX             reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    IF              reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    MATCH           reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    ID              reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    SUB             reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    NOT             reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    AND             reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    MUL             reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    LITDEC          reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    LITCHAR         reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    LITBOOL         reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    LITSTRING       reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    COMMA           reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    RBRACKET        reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)
    ELSE            reduce using rule 183 (block -> LSQUIGBRACKET stmts RSQUIGBRACKET .)


state 209

    (89) assign -> exp OREQUAL . exp
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for BOX resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for MATCH resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for LITDEC resolved as shift
  ! shift/reduce conflict for LITCHAR resolved as shift
  ! shift/reduce conflict for LITBOOL resolved as shift
  ! shift/reduce conflict for LITSTRING resolved as shift
    LPAREN          shift and go to state 121
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    SEMICOLON       reduce using rule 31 (exp -> .)
    RSQUIGBRACKET   reduce using rule 31 (exp -> .)
    RPAREN          reduce using rule 31 (exp -> .)
    COMMA           reduce using rule 31 (exp -> .)
    RBRACKET        reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]
  ! LPAREN          [ reduce using rule 31 (exp -> .) ]
  ! LOOP            [ reduce using rule 31 (exp -> .) ]
  ! WHILE           [ reduce using rule 31 (exp -> .) ]
  ! BOX             [ reduce using rule 31 (exp -> .) ]
  ! IF              [ reduce using rule 31 (exp -> .) ]
  ! MATCH           [ reduce using rule 31 (exp -> .) ]
  ! ID              [ reduce using rule 31 (exp -> .) ]
  ! SUB             [ reduce using rule 31 (exp -> .) ]
  ! NOT             [ reduce using rule 31 (exp -> .) ]
  ! AND             [ reduce using rule 31 (exp -> .) ]
  ! MUL             [ reduce using rule 31 (exp -> .) ]
  ! LITDEC          [ reduce using rule 31 (exp -> .) ]
  ! LITCHAR         [ reduce using rule 31 (exp -> .) ]
  ! LITBOOL         [ reduce using rule 31 (exp -> .) ]
  ! LITSTRING       [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 262
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 210

    (88) assign -> exp ANDEQUAL . exp
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for BOX resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for MATCH resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for LITDEC resolved as shift
  ! shift/reduce conflict for LITCHAR resolved as shift
  ! shift/reduce conflict for LITBOOL resolved as shift
  ! shift/reduce conflict for LITSTRING resolved as shift
    LPAREN          shift and go to state 121
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    SEMICOLON       reduce using rule 31 (exp -> .)
    RSQUIGBRACKET   reduce using rule 31 (exp -> .)
    RPAREN          reduce using rule 31 (exp -> .)
    COMMA           reduce using rule 31 (exp -> .)
    RBRACKET        reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]
  ! LPAREN          [ reduce using rule 31 (exp -> .) ]
  ! LOOP            [ reduce using rule 31 (exp -> .) ]
  ! WHILE           [ reduce using rule 31 (exp -> .) ]
  ! BOX             [ reduce using rule 31 (exp -> .) ]
  ! IF              [ reduce using rule 31 (exp -> .) ]
  ! MATCH           [ reduce using rule 31 (exp -> .) ]
  ! ID              [ reduce using rule 31 (exp -> .) ]
  ! SUB             [ reduce using rule 31 (exp -> .) ]
  ! NOT             [ reduce using rule 31 (exp -> .) ]
  ! AND             [ reduce using rule 31 (exp -> .) ]
  ! MUL             [ reduce using rule 31 (exp -> .) ]
  ! LITDEC          [ reduce using rule 31 (exp -> .) ]
  ! LITCHAR         [ reduce using rule 31 (exp -> .) ]
  ! LITBOOL         [ reduce using rule 31 (exp -> .) ]
  ! LITSTRING       [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 263
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 211

    (85) assign -> exp DIVEQUAL . exp
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for BOX resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for MATCH resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for LITDEC resolved as shift
  ! shift/reduce conflict for LITCHAR resolved as shift
  ! shift/reduce conflict for LITBOOL resolved as shift
  ! shift/reduce conflict for LITSTRING resolved as shift
    LPAREN          shift and go to state 121
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    SEMICOLON       reduce using rule 31 (exp -> .)
    RSQUIGBRACKET   reduce using rule 31 (exp -> .)
    RPAREN          reduce using rule 31 (exp -> .)
    COMMA           reduce using rule 31 (exp -> .)
    RBRACKET        reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]
  ! LPAREN          [ reduce using rule 31 (exp -> .) ]
  ! LOOP            [ reduce using rule 31 (exp -> .) ]
  ! WHILE           [ reduce using rule 31 (exp -> .) ]
  ! BOX             [ reduce using rule 31 (exp -> .) ]
  ! IF              [ reduce using rule 31 (exp -> .) ]
  ! MATCH           [ reduce using rule 31 (exp -> .) ]
  ! ID              [ reduce using rule 31 (exp -> .) ]
  ! SUB             [ reduce using rule 31 (exp -> .) ]
  ! NOT             [ reduce using rule 31 (exp -> .) ]
  ! AND             [ reduce using rule 31 (exp -> .) ]
  ! MUL             [ reduce using rule 31 (exp -> .) ]
  ! LITDEC          [ reduce using rule 31 (exp -> .) ]
  ! LITCHAR         [ reduce using rule 31 (exp -> .) ]
  ! LITBOOL         [ reduce using rule 31 (exp -> .) ]
  ! LITSTRING       [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 264
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 212

    (87) assign -> exp MODEQUAL . exp
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for BOX resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for MATCH resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for LITDEC resolved as shift
  ! shift/reduce conflict for LITCHAR resolved as shift
  ! shift/reduce conflict for LITBOOL resolved as shift
  ! shift/reduce conflict for LITSTRING resolved as shift
    LPAREN          shift and go to state 121
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    SEMICOLON       reduce using rule 31 (exp -> .)
    RSQUIGBRACKET   reduce using rule 31 (exp -> .)
    RPAREN          reduce using rule 31 (exp -> .)
    COMMA           reduce using rule 31 (exp -> .)
    RBRACKET        reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]
  ! LPAREN          [ reduce using rule 31 (exp -> .) ]
  ! LOOP            [ reduce using rule 31 (exp -> .) ]
  ! WHILE           [ reduce using rule 31 (exp -> .) ]
  ! BOX             [ reduce using rule 31 (exp -> .) ]
  ! IF              [ reduce using rule 31 (exp -> .) ]
  ! MATCH           [ reduce using rule 31 (exp -> .) ]
  ! ID              [ reduce using rule 31 (exp -> .) ]
  ! SUB             [ reduce using rule 31 (exp -> .) ]
  ! NOT             [ reduce using rule 31 (exp -> .) ]
  ! AND             [ reduce using rule 31 (exp -> .) ]
  ! MUL             [ reduce using rule 31 (exp -> .) ]
  ! LITDEC          [ reduce using rule 31 (exp -> .) ]
  ! LITCHAR         [ reduce using rule 31 (exp -> .) ]
  ! LITBOOL         [ reduce using rule 31 (exp -> .) ]
  ! LITSTRING       [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 265
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 213

    (86) assign -> exp TIMESEQUAL . exp
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for BOX resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for MATCH resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for LITDEC resolved as shift
  ! shift/reduce conflict for LITCHAR resolved as shift
  ! shift/reduce conflict for LITBOOL resolved as shift
  ! shift/reduce conflict for LITSTRING resolved as shift
    LPAREN          shift and go to state 121
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    SEMICOLON       reduce using rule 31 (exp -> .)
    RSQUIGBRACKET   reduce using rule 31 (exp -> .)
    RPAREN          reduce using rule 31 (exp -> .)
    COMMA           reduce using rule 31 (exp -> .)
    RBRACKET        reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]
  ! LPAREN          [ reduce using rule 31 (exp -> .) ]
  ! LOOP            [ reduce using rule 31 (exp -> .) ]
  ! WHILE           [ reduce using rule 31 (exp -> .) ]
  ! BOX             [ reduce using rule 31 (exp -> .) ]
  ! IF              [ reduce using rule 31 (exp -> .) ]
  ! MATCH           [ reduce using rule 31 (exp -> .) ]
  ! ID              [ reduce using rule 31 (exp -> .) ]
  ! SUB             [ reduce using rule 31 (exp -> .) ]
  ! NOT             [ reduce using rule 31 (exp -> .) ]
  ! AND             [ reduce using rule 31 (exp -> .) ]
  ! MUL             [ reduce using rule 31 (exp -> .) ]
  ! LITDEC          [ reduce using rule 31 (exp -> .) ]
  ! LITCHAR         [ reduce using rule 31 (exp -> .) ]
  ! LITBOOL         [ reduce using rule 31 (exp -> .) ]
  ! LITSTRING       [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 266
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 214

    (83) assign -> exp PLUSEQUAL . exp
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for BOX resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for MATCH resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for LITDEC resolved as shift
  ! shift/reduce conflict for LITCHAR resolved as shift
  ! shift/reduce conflict for LITBOOL resolved as shift
  ! shift/reduce conflict for LITSTRING resolved as shift
    LPAREN          shift and go to state 121
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    SEMICOLON       reduce using rule 31 (exp -> .)
    RSQUIGBRACKET   reduce using rule 31 (exp -> .)
    RPAREN          reduce using rule 31 (exp -> .)
    COMMA           reduce using rule 31 (exp -> .)
    RBRACKET        reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]
  ! LPAREN          [ reduce using rule 31 (exp -> .) ]
  ! LOOP            [ reduce using rule 31 (exp -> .) ]
  ! WHILE           [ reduce using rule 31 (exp -> .) ]
  ! BOX             [ reduce using rule 31 (exp -> .) ]
  ! IF              [ reduce using rule 31 (exp -> .) ]
  ! MATCH           [ reduce using rule 31 (exp -> .) ]
  ! ID              [ reduce using rule 31 (exp -> .) ]
  ! SUB             [ reduce using rule 31 (exp -> .) ]
  ! NOT             [ reduce using rule 31 (exp -> .) ]
  ! AND             [ reduce using rule 31 (exp -> .) ]
  ! MUL             [ reduce using rule 31 (exp -> .) ]
  ! LITDEC          [ reduce using rule 31 (exp -> .) ]
  ! LITCHAR         [ reduce using rule 31 (exp -> .) ]
  ! LITBOOL         [ reduce using rule 31 (exp -> .) ]
  ! LITSTRING       [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 267
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 215

    (82) assign -> exp EQU . exp
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for BOX resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for MATCH resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for LITDEC resolved as shift
  ! shift/reduce conflict for LITCHAR resolved as shift
  ! shift/reduce conflict for LITBOOL resolved as shift
  ! shift/reduce conflict for LITSTRING resolved as shift
    LPAREN          shift and go to state 121
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    SEMICOLON       reduce using rule 31 (exp -> .)
    RSQUIGBRACKET   reduce using rule 31 (exp -> .)
    RPAREN          reduce using rule 31 (exp -> .)
    COMMA           reduce using rule 31 (exp -> .)
    RBRACKET        reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]
  ! LPAREN          [ reduce using rule 31 (exp -> .) ]
  ! LOOP            [ reduce using rule 31 (exp -> .) ]
  ! WHILE           [ reduce using rule 31 (exp -> .) ]
  ! BOX             [ reduce using rule 31 (exp -> .) ]
  ! IF              [ reduce using rule 31 (exp -> .) ]
  ! MATCH           [ reduce using rule 31 (exp -> .) ]
  ! ID              [ reduce using rule 31 (exp -> .) ]
  ! SUB             [ reduce using rule 31 (exp -> .) ]
  ! NOT             [ reduce using rule 31 (exp -> .) ]
  ! AND             [ reduce using rule 31 (exp -> .) ]
  ! MUL             [ reduce using rule 31 (exp -> .) ]
  ! LITDEC          [ reduce using rule 31 (exp -> .) ]
  ! LITCHAR         [ reduce using rule 31 (exp -> .) ]
  ! LITBOOL         [ reduce using rule 31 (exp -> .) ]
  ! LITSTRING       [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 268
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 216

    (94) field_lookup -> exp PERIOD . id
    (143) id -> . ID

    ID              shift and go to state 10

    id                             shift and go to state 269

state 217

    (125) arr_index -> exp LBRACKET . exp RBRACKET
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    LPAREN          shift and go to state 121
    RBRACKET        reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 270
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 218

    (84) assign -> exp SUBEQUAL . exp
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LOOP resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for BOX resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for MATCH resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for SUB resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for MUL resolved as shift
  ! shift/reduce conflict for LITDEC resolved as shift
  ! shift/reduce conflict for LITCHAR resolved as shift
  ! shift/reduce conflict for LITBOOL resolved as shift
  ! shift/reduce conflict for LITSTRING resolved as shift
    LPAREN          shift and go to state 121
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    SEMICOLON       reduce using rule 31 (exp -> .)
    RSQUIGBRACKET   reduce using rule 31 (exp -> .)
    RPAREN          reduce using rule 31 (exp -> .)
    COMMA           reduce using rule 31 (exp -> .)
    RBRACKET        reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]
  ! LPAREN          [ reduce using rule 31 (exp -> .) ]
  ! LOOP            [ reduce using rule 31 (exp -> .) ]
  ! WHILE           [ reduce using rule 31 (exp -> .) ]
  ! BOX             [ reduce using rule 31 (exp -> .) ]
  ! IF              [ reduce using rule 31 (exp -> .) ]
  ! MATCH           [ reduce using rule 31 (exp -> .) ]
  ! ID              [ reduce using rule 31 (exp -> .) ]
  ! SUB             [ reduce using rule 31 (exp -> .) ]
  ! NOT             [ reduce using rule 31 (exp -> .) ]
  ! AND             [ reduce using rule 31 (exp -> .) ]
  ! MUL             [ reduce using rule 31 (exp -> .) ]
  ! LITDEC          [ reduce using rule 31 (exp -> .) ]
  ! LITCHAR         [ reduce using rule 31 (exp -> .) ]
  ! LITBOOL         [ reduce using rule 31 (exp -> .) ]
  ! LITSTRING       [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 271
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 219

    (75) addr -> AND arith4 .

    ADD             reduce using rule 75 (addr -> AND arith4 .)
    SUB             reduce using rule 75 (addr -> AND arith4 .)
    MUL             reduce using rule 75 (addr -> AND arith4 .)
    DIV             reduce using rule 75 (addr -> AND arith4 .)
    MODOP           reduce using rule 75 (addr -> AND arith4 .)
    LESSTHAN        reduce using rule 75 (addr -> AND arith4 .)
    LESSTHANOREQUAL reduce using rule 75 (addr -> AND arith4 .)
    GREATERTHAN     reduce using rule 75 (addr -> AND arith4 .)
    GREATERTHANOREQUAL reduce using rule 75 (addr -> AND arith4 .)
    EQUALTO         reduce using rule 75 (addr -> AND arith4 .)
    NOTEQUAL        reduce using rule 75 (addr -> AND arith4 .)
    LOGICALOR       reduce using rule 75 (addr -> AND arith4 .)
    LOGICALAND      reduce using rule 75 (addr -> AND arith4 .)
    RBRACKET        reduce using rule 75 (addr -> AND arith4 .)
    EQU             reduce using rule 75 (addr -> AND arith4 .)
    PLUSEQUAL       reduce using rule 75 (addr -> AND arith4 .)
    SUBEQUAL        reduce using rule 75 (addr -> AND arith4 .)
    DIVEQUAL        reduce using rule 75 (addr -> AND arith4 .)
    TIMESEQUAL      reduce using rule 75 (addr -> AND arith4 .)
    MODEQUAL        reduce using rule 75 (addr -> AND arith4 .)
    ANDEQUAL        reduce using rule 75 (addr -> AND arith4 .)
    OREQUAL         reduce using rule 75 (addr -> AND arith4 .)
    LBRACKET        reduce using rule 75 (addr -> AND arith4 .)
    PERIOD          reduce using rule 75 (addr -> AND arith4 .)
    SEMICOLON       reduce using rule 75 (addr -> AND arith4 .)
    RSQUIGBRACKET   reduce using rule 75 (addr -> AND arith4 .)
    RPAREN          reduce using rule 75 (addr -> AND arith4 .)
    LPAREN          reduce using rule 75 (addr -> AND arith4 .)
    LOOP            reduce using rule 75 (addr -> AND arith4 .)
    WHILE           reduce using rule 75 (addr -> AND arith4 .)
    BOX             reduce using rule 75 (addr -> AND arith4 .)
    IF              reduce using rule 75 (addr -> AND arith4 .)
    MATCH           reduce using rule 75 (addr -> AND arith4 .)
    ID              reduce using rule 75 (addr -> AND arith4 .)
    NOT             reduce using rule 75 (addr -> AND arith4 .)
    AND             reduce using rule 75 (addr -> AND arith4 .)
    LITDEC          reduce using rule 75 (addr -> AND arith4 .)
    LITCHAR         reduce using rule 75 (addr -> AND arith4 .)
    LITBOOL         reduce using rule 75 (addr -> AND arith4 .)
    LITSTRING       reduce using rule 75 (addr -> AND arith4 .)
    COMMA           reduce using rule 75 (addr -> AND arith4 .)


state 220

    (76) addr -> AND neg .

    ADD             reduce using rule 76 (addr -> AND neg .)
    SUB             reduce using rule 76 (addr -> AND neg .)
    MUL             reduce using rule 76 (addr -> AND neg .)
    DIV             reduce using rule 76 (addr -> AND neg .)
    MODOP           reduce using rule 76 (addr -> AND neg .)
    LESSTHAN        reduce using rule 76 (addr -> AND neg .)
    LESSTHANOREQUAL reduce using rule 76 (addr -> AND neg .)
    GREATERTHAN     reduce using rule 76 (addr -> AND neg .)
    GREATERTHANOREQUAL reduce using rule 76 (addr -> AND neg .)
    EQUALTO         reduce using rule 76 (addr -> AND neg .)
    NOTEQUAL        reduce using rule 76 (addr -> AND neg .)
    LOGICALOR       reduce using rule 76 (addr -> AND neg .)
    LOGICALAND      reduce using rule 76 (addr -> AND neg .)
    RBRACKET        reduce using rule 76 (addr -> AND neg .)
    EQU             reduce using rule 76 (addr -> AND neg .)
    PLUSEQUAL       reduce using rule 76 (addr -> AND neg .)
    SUBEQUAL        reduce using rule 76 (addr -> AND neg .)
    DIVEQUAL        reduce using rule 76 (addr -> AND neg .)
    TIMESEQUAL      reduce using rule 76 (addr -> AND neg .)
    MODEQUAL        reduce using rule 76 (addr -> AND neg .)
    ANDEQUAL        reduce using rule 76 (addr -> AND neg .)
    OREQUAL         reduce using rule 76 (addr -> AND neg .)
    LBRACKET        reduce using rule 76 (addr -> AND neg .)
    PERIOD          reduce using rule 76 (addr -> AND neg .)
    SEMICOLON       reduce using rule 76 (addr -> AND neg .)
    RSQUIGBRACKET   reduce using rule 76 (addr -> AND neg .)
    RPAREN          reduce using rule 76 (addr -> AND neg .)
    LPAREN          reduce using rule 76 (addr -> AND neg .)
    LOOP            reduce using rule 76 (addr -> AND neg .)
    WHILE           reduce using rule 76 (addr -> AND neg .)
    BOX             reduce using rule 76 (addr -> AND neg .)
    IF              reduce using rule 76 (addr -> AND neg .)
    MATCH           reduce using rule 76 (addr -> AND neg .)
    ID              reduce using rule 76 (addr -> AND neg .)
    NOT             reduce using rule 76 (addr -> AND neg .)
    AND             reduce using rule 76 (addr -> AND neg .)
    LITDEC          reduce using rule 76 (addr -> AND neg .)
    LITCHAR         reduce using rule 76 (addr -> AND neg .)
    LITBOOL         reduce using rule 76 (addr -> AND neg .)
    LITSTRING       reduce using rule 76 (addr -> AND neg .)
    COMMA           reduce using rule 76 (addr -> AND neg .)


state 221

    (79) addr_of_mut -> AND MUT . arith4
    (80) addr_of_mut -> AND MUT . neg
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (53) neg -> . SUB arith4
    (143) id -> . ID
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

    SUB             shift and go to state 156
    ID              shift and go to state 10
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

    ptr                            shift and go to state 145
    deref                          shift and go to state 167
    arith4                         shift and go to state 272
    lit                            shift and go to state 139
    addr_of_mut                    shift and go to state 168
    enum_con                       shift and go to state 133
    addr                           shift and go to state 127
    neg                            shift and go to state 273
    p_lit                          shift and go to state 116
    id                             shift and go to state 192

state 222

    (53) neg -> SUB arith4 .

    ADD             reduce using rule 53 (neg -> SUB arith4 .)
    SUB             reduce using rule 53 (neg -> SUB arith4 .)
    MUL             reduce using rule 53 (neg -> SUB arith4 .)
    DIV             reduce using rule 53 (neg -> SUB arith4 .)
    MODOP           reduce using rule 53 (neg -> SUB arith4 .)
    LESSTHAN        reduce using rule 53 (neg -> SUB arith4 .)
    LESSTHANOREQUAL reduce using rule 53 (neg -> SUB arith4 .)
    GREATERTHAN     reduce using rule 53 (neg -> SUB arith4 .)
    GREATERTHANOREQUAL reduce using rule 53 (neg -> SUB arith4 .)
    EQUALTO         reduce using rule 53 (neg -> SUB arith4 .)
    NOTEQUAL        reduce using rule 53 (neg -> SUB arith4 .)
    LOGICALOR       reduce using rule 53 (neg -> SUB arith4 .)
    LOGICALAND      reduce using rule 53 (neg -> SUB arith4 .)
    EQU             reduce using rule 53 (neg -> SUB arith4 .)
    PLUSEQUAL       reduce using rule 53 (neg -> SUB arith4 .)
    SUBEQUAL        reduce using rule 53 (neg -> SUB arith4 .)
    DIVEQUAL        reduce using rule 53 (neg -> SUB arith4 .)
    TIMESEQUAL      reduce using rule 53 (neg -> SUB arith4 .)
    MODEQUAL        reduce using rule 53 (neg -> SUB arith4 .)
    ANDEQUAL        reduce using rule 53 (neg -> SUB arith4 .)
    OREQUAL         reduce using rule 53 (neg -> SUB arith4 .)
    LBRACKET        reduce using rule 53 (neg -> SUB arith4 .)
    PERIOD          reduce using rule 53 (neg -> SUB arith4 .)
    SEMICOLON       reduce using rule 53 (neg -> SUB arith4 .)
    RSQUIGBRACKET   reduce using rule 53 (neg -> SUB arith4 .)
    RPAREN          reduce using rule 53 (neg -> SUB arith4 .)
    LPAREN          reduce using rule 53 (neg -> SUB arith4 .)
    LOOP            reduce using rule 53 (neg -> SUB arith4 .)
    WHILE           reduce using rule 53 (neg -> SUB arith4 .)
    BOX             reduce using rule 53 (neg -> SUB arith4 .)
    IF              reduce using rule 53 (neg -> SUB arith4 .)
    MATCH           reduce using rule 53 (neg -> SUB arith4 .)
    ID              reduce using rule 53 (neg -> SUB arith4 .)
    NOT             reduce using rule 53 (neg -> SUB arith4 .)
    AND             reduce using rule 53 (neg -> SUB arith4 .)
    LITDEC          reduce using rule 53 (neg -> SUB arith4 .)
    LITCHAR         reduce using rule 53 (neg -> SUB arith4 .)
    LITBOOL         reduce using rule 53 (neg -> SUB arith4 .)
    LITSTRING       reduce using rule 53 (neg -> SUB arith4 .)
    COMMA           reduce using rule 53 (neg -> SUB arith4 .)
    RBRACKET        reduce using rule 53 (neg -> SUB arith4 .)


state 223

    (40) arith3 -> LPAREN . arith1 RPAREN
    (19) exp -> LPAREN . exp RPAREN
    (81) unit -> LPAREN . RPAREN
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (143) id -> . ID
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for RPAREN resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
    RPAREN          shift and go to state 186
    LPAREN          shift and go to state 121
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    SUB             shift and go to state 156
    ID              shift and go to state 10
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! RPAREN          [ reduce using rule 31 (exp -> .) ]
  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 185
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    mul                            shift and go to state 143
    not                            shift and go to state 134
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 184
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    loop                           shift and go to state 126
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 224

    (71) not -> NOT arith1 .
    (48) add -> arith1 . ADD arith1
    (49) sub -> arith1 . SUB arith1
    (50) mul -> arith1 . MUL arith1
    (51) div -> arith1 . DIV arith1
    (52) mod -> arith1 . MODOP arith1
    (63) lt -> arith1 . LESSTHAN arith1
    (64) leq -> arith1 . LESSTHANOREQUAL arith1
    (65) gt -> arith1 . GREATERTHAN arith1
    (66) geq -> arith1 . GREATERTHANOREQUAL arith1
    (67) eq -> arith1 . EQUALTO arith1
    (68) neq -> arith1 . NOTEQUAL arith1
    (69) or -> arith1 . LOGICALOR arith1
    (70) and -> arith1 . LOGICALAND arith1
    (20) exp -> arith1 .

  ! reduce/reduce conflict for PERIOD resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for EQU resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for PLUSEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for SUBEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for DIVEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for TIMESEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for MODEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for ANDEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for OREQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 20 (exp -> arith1 .)
    LESSTHAN        reduce using rule 71 (not -> NOT arith1 .)
    LESSTHANOREQUAL reduce using rule 71 (not -> NOT arith1 .)
    GREATERTHAN     reduce using rule 71 (not -> NOT arith1 .)
    GREATERTHANOREQUAL reduce using rule 71 (not -> NOT arith1 .)
    EQUALTO         reduce using rule 71 (not -> NOT arith1 .)
    NOTEQUAL        reduce using rule 71 (not -> NOT arith1 .)
    LOGICALOR       reduce using rule 71 (not -> NOT arith1 .)
    LOGICALAND      reduce using rule 71 (not -> NOT arith1 .)
    RPAREN          reduce using rule 71 (not -> NOT arith1 .)
    SEMICOLON       reduce using rule 71 (not -> NOT arith1 .)
    RSQUIGBRACKET   reduce using rule 71 (not -> NOT arith1 .)
    LPAREN          reduce using rule 71 (not -> NOT arith1 .)
    LOOP            reduce using rule 71 (not -> NOT arith1 .)
    WHILE           reduce using rule 71 (not -> NOT arith1 .)
    BOX             reduce using rule 71 (not -> NOT arith1 .)
    IF              reduce using rule 71 (not -> NOT arith1 .)
    MATCH           reduce using rule 71 (not -> NOT arith1 .)
    ID              reduce using rule 71 (not -> NOT arith1 .)
    NOT             reduce using rule 71 (not -> NOT arith1 .)
    AND             reduce using rule 71 (not -> NOT arith1 .)
    LITDEC          reduce using rule 71 (not -> NOT arith1 .)
    LITCHAR         reduce using rule 71 (not -> NOT arith1 .)
    LITBOOL         reduce using rule 71 (not -> NOT arith1 .)
    LITSTRING       reduce using rule 71 (not -> NOT arith1 .)
    COMMA           reduce using rule 71 (not -> NOT arith1 .)
    RBRACKET        reduce using rule 71 (not -> NOT arith1 .)
    ADD             shift and go to state 204
    SUB             shift and go to state 195
    MUL             shift and go to state 199
    DIV             shift and go to state 197
    MODOP           shift and go to state 205
    PERIOD          reduce using rule 20 (exp -> arith1 .)
    EQU             reduce using rule 20 (exp -> arith1 .)
    PLUSEQUAL       reduce using rule 20 (exp -> arith1 .)
    SUBEQUAL        reduce using rule 20 (exp -> arith1 .)
    DIVEQUAL        reduce using rule 20 (exp -> arith1 .)
    TIMESEQUAL      reduce using rule 20 (exp -> arith1 .)
    MODEQUAL        reduce using rule 20 (exp -> arith1 .)
    ANDEQUAL        reduce using rule 20 (exp -> arith1 .)
    OREQUAL         reduce using rule 20 (exp -> arith1 .)
    LBRACKET        reduce using rule 20 (exp -> arith1 .)

  ! ADD             [ reduce using rule 71 (not -> NOT arith1 .) ]
  ! SUB             [ reduce using rule 71 (not -> NOT arith1 .) ]
  ! MUL             [ reduce using rule 71 (not -> NOT arith1 .) ]
  ! DIV             [ reduce using rule 71 (not -> NOT arith1 .) ]
  ! MODOP           [ reduce using rule 71 (not -> NOT arith1 .) ]
  ! EQU             [ reduce using rule 71 (not -> NOT arith1 .) ]
  ! PLUSEQUAL       [ reduce using rule 71 (not -> NOT arith1 .) ]
  ! SUBEQUAL        [ reduce using rule 71 (not -> NOT arith1 .) ]
  ! DIVEQUAL        [ reduce using rule 71 (not -> NOT arith1 .) ]
  ! TIMESEQUAL      [ reduce using rule 71 (not -> NOT arith1 .) ]
  ! MODEQUAL        [ reduce using rule 71 (not -> NOT arith1 .) ]
  ! ANDEQUAL        [ reduce using rule 71 (not -> NOT arith1 .) ]
  ! OREQUAL         [ reduce using rule 71 (not -> NOT arith1 .) ]
  ! LBRACKET        [ reduce using rule 71 (not -> NOT arith1 .) ]
  ! PERIOD          [ reduce using rule 71 (not -> NOT arith1 .) ]
  ! LESSTHAN        [ shift and go to state 202 ]
  ! LESSTHANOREQUAL [ shift and go to state 201 ]
  ! GREATERTHAN     [ shift and go to state 194 ]
  ! GREATERTHANOREQUAL [ shift and go to state 198 ]
  ! EQUALTO         [ shift and go to state 206 ]
  ! NOTEQUAL        [ shift and go to state 203 ]
  ! LOGICALOR       [ shift and go to state 196 ]
  ! LOGICALAND      [ shift and go to state 200 ]


state 225

    (94) field_lookup -> exp . PERIOD id
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET

    PERIOD          shift and go to state 216
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217


state 226

    (128) fn_call -> id . LPAREN fn_args RPAREN
    (45) arith4 -> id .
    (186) arg_struct -> id . LSQUIGBRACKET body RSQUIGBRACKET
    (192) enum_con -> id . CLASSACCESS id

  ! shift/reduce conflict for LPAREN resolved as shift
    LPAREN          shift and go to state 231
    ADD             reduce using rule 45 (arith4 -> id .)
    SUB             reduce using rule 45 (arith4 -> id .)
    MUL             reduce using rule 45 (arith4 -> id .)
    DIV             reduce using rule 45 (arith4 -> id .)
    MODOP           reduce using rule 45 (arith4 -> id .)
    LESSTHAN        reduce using rule 45 (arith4 -> id .)
    LESSTHANOREQUAL reduce using rule 45 (arith4 -> id .)
    GREATERTHAN     reduce using rule 45 (arith4 -> id .)
    GREATERTHANOREQUAL reduce using rule 45 (arith4 -> id .)
    EQUALTO         reduce using rule 45 (arith4 -> id .)
    NOTEQUAL        reduce using rule 45 (arith4 -> id .)
    LOGICALOR       reduce using rule 45 (arith4 -> id .)
    LOGICALAND      reduce using rule 45 (arith4 -> id .)
    EQU             reduce using rule 45 (arith4 -> id .)
    PLUSEQUAL       reduce using rule 45 (arith4 -> id .)
    SUBEQUAL        reduce using rule 45 (arith4 -> id .)
    DIVEQUAL        reduce using rule 45 (arith4 -> id .)
    TIMESEQUAL      reduce using rule 45 (arith4 -> id .)
    MODEQUAL        reduce using rule 45 (arith4 -> id .)
    ANDEQUAL        reduce using rule 45 (arith4 -> id .)
    OREQUAL         reduce using rule 45 (arith4 -> id .)
    LBRACKET        reduce using rule 45 (arith4 -> id .)
    PERIOD          reduce using rule 45 (arith4 -> id .)
    SEMICOLON       reduce using rule 45 (arith4 -> id .)
    RSQUIGBRACKET   reduce using rule 45 (arith4 -> id .)
    RPAREN          reduce using rule 45 (arith4 -> id .)
    LOOP            reduce using rule 45 (arith4 -> id .)
    WHILE           reduce using rule 45 (arith4 -> id .)
    BOX             reduce using rule 45 (arith4 -> id .)
    IF              reduce using rule 45 (arith4 -> id .)
    MATCH           reduce using rule 45 (arith4 -> id .)
    ID              reduce using rule 45 (arith4 -> id .)
    NOT             reduce using rule 45 (arith4 -> id .)
    AND             reduce using rule 45 (arith4 -> id .)
    LITDEC          reduce using rule 45 (arith4 -> id .)
    LITCHAR         reduce using rule 45 (arith4 -> id .)
    LITBOOL         reduce using rule 45 (arith4 -> id .)
    LITSTRING       reduce using rule 45 (arith4 -> id .)
    COMMA           reduce using rule 45 (arith4 -> id .)
    RBRACKET        reduce using rule 45 (arith4 -> id .)
    LSQUIGBRACKET   shift and go to state 230
    CLASSACCESS     shift and go to state 232

  ! LPAREN          [ reduce using rule 45 (arith4 -> id .) ]


state 227

    (124) arr -> LBRACKET exps . RBRACKET
    (15) exps -> exps .

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 274

  ! RBRACKET        [ reduce using rule 15 (exps -> exps .) ]


state 228

    (17) exps -> exp . COMMA exps
    (18) exps -> exp .
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

    COMMA           shift and go to state 275
    RBRACKET        reduce using rule 18 (exps -> exp .)
    RPAREN          reduce using rule 18 (exps -> exp .)
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216


state 229

    (95) while -> WHILE LPAREN . exp RPAREN block
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    LPAREN          shift and go to state 121
    RPAREN          reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 276
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    mul                            shift and go to state 143
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    loop                           shift and go to state 126
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 230

    (186) arg_struct -> id LSQUIGBRACKET . body RSQUIGBRACKET
    (187) body -> . param_arg body
    (188) body -> . param_arg
    (189) param_arg -> . param_arg COMMA
    (190) param_arg -> . id COLON exp
    (143) id -> . ID

    ID              shift and go to state 10

    body                           shift and go to state 277
    id                             shift and go to state 279
    param_arg                      shift and go to state 278

state 231

    (128) fn_call -> id LPAREN . fn_args RPAREN
    (129) fn_args -> . fn_arg fn_args
    (130) fn_args -> .
    (131) fn_arg -> . fn_arg COMMA
    (132) fn_arg -> . lit
    (133) fn_arg -> . id
    (134) fn_arg -> . box_new
    (135) fn_arg -> . fn_call
    (136) fn_arg -> . arg_struct
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (143) id -> . ID
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

    RPAREN          reduce using rule 130 (fn_args -> .)
    ID              shift and go to state 10
    BOX             shift and go to state 117
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

    arg_struct                     shift and go to state 280
    fn_args                        shift and go to state 281
    box_new                        shift and go to state 282
    id                             shift and go to state 283
    p_lit                          shift and go to state 116
    fn_call                        shift and go to state 285
    lit                            shift and go to state 284
    enum_con                       shift and go to state 133
    fn_arg                         shift and go to state 286

state 232

    (192) enum_con -> id CLASSACCESS . id
    (143) id -> . ID

    ID              shift and go to state 10

    id                             shift and go to state 287

state 233

    (96) loop -> LOOP block .

    PERIOD          reduce using rule 96 (loop -> LOOP block .)
    EQU             reduce using rule 96 (loop -> LOOP block .)
    PLUSEQUAL       reduce using rule 96 (loop -> LOOP block .)
    SUBEQUAL        reduce using rule 96 (loop -> LOOP block .)
    DIVEQUAL        reduce using rule 96 (loop -> LOOP block .)
    TIMESEQUAL      reduce using rule 96 (loop -> LOOP block .)
    MODEQUAL        reduce using rule 96 (loop -> LOOP block .)
    ANDEQUAL        reduce using rule 96 (loop -> LOOP block .)
    OREQUAL         reduce using rule 96 (loop -> LOOP block .)
    LBRACKET        reduce using rule 96 (loop -> LOOP block .)
    COMMA           reduce using rule 96 (loop -> LOOP block .)
    RPAREN          reduce using rule 96 (loop -> LOOP block .)
    SEMICOLON       reduce using rule 96 (loop -> LOOP block .)
    RSQUIGBRACKET   reduce using rule 96 (loop -> LOOP block .)
    LPAREN          reduce using rule 96 (loop -> LOOP block .)
    LOOP            reduce using rule 96 (loop -> LOOP block .)
    WHILE           reduce using rule 96 (loop -> LOOP block .)
    BOX             reduce using rule 96 (loop -> LOOP block .)
    IF              reduce using rule 96 (loop -> LOOP block .)
    MATCH           reduce using rule 96 (loop -> LOOP block .)
    ID              reduce using rule 96 (loop -> LOOP block .)
    SUB             reduce using rule 96 (loop -> LOOP block .)
    NOT             reduce using rule 96 (loop -> LOOP block .)
    AND             reduce using rule 96 (loop -> LOOP block .)
    MUL             reduce using rule 96 (loop -> LOOP block .)
    LITDEC          reduce using rule 96 (loop -> LOOP block .)
    LITCHAR         reduce using rule 96 (loop -> LOOP block .)
    LITBOOL         reduce using rule 96 (loop -> LOOP block .)
    LITSTRING       reduce using rule 96 (loop -> LOOP block .)
    RBRACKET        reduce using rule 96 (loop -> LOOP block .)


state 234

    (97) if -> IF LPAREN . exp RPAREN block
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    LPAREN          shift and go to state 121
    RPAREN          reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 288
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    mul                            shift and go to state 143
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    loop                           shift and go to state 126
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 235

    (127) function -> FN id LPAREN fn_params_seq RPAREN OBJECTACCESS type block .

    SEMICOLON       reduce using rule 127 (function -> FN id LPAREN fn_params_seq RPAREN OBJECTACCESS type block .)
    RSQUIGBRACKET   reduce using rule 127 (function -> FN id LPAREN fn_params_seq RPAREN OBJECTACCESS type block .)
    FN              reduce using rule 127 (function -> FN id LPAREN fn_params_seq RPAREN OBJECTACCESS type block .)
    STRUCT          reduce using rule 127 (function -> FN id LPAREN fn_params_seq RPAREN OBJECTACCESS type block .)
    ENUM            reduce using rule 127 (function -> FN id LPAREN fn_params_seq RPAREN OBJECTACCESS type block .)
    $end            reduce using rule 127 (function -> FN id LPAREN fn_params_seq RPAREN OBJECTACCESS type block .)


state 236

    (121) pat_fields -> pat_field COMMA pat_fields .

    RSQUIGBRACKET   reduce using rule 121 (pat_fields -> pat_field COMMA pat_fields .)


state 237

    (123) pat_field -> id COLON pat .

    COMMA           reduce using rule 123 (pat_field -> id COLON pat .)
    RSQUIGBRACKET   reduce using rule 123 (pat_field -> id COLON pat .)


state 238

    (176) box -> BOX LESSTHAN type GREATERTHAN .

    LSQUIGBRACKET   reduce using rule 176 (box -> BOX LESSTHAN type GREATERTHAN .)
    EQU             reduce using rule 176 (box -> BOX LESSTHAN type GREATERTHAN .)
    SEMICOLON       reduce using rule 176 (box -> BOX LESSTHAN type GREATERTHAN .)
    RSQUIGBRACKET   reduce using rule 176 (box -> BOX LESSTHAN type GREATERTHAN .)
    COMMA           reduce using rule 176 (box -> BOX LESSTHAN type GREATERTHAN .)
    ID              reduce using rule 176 (box -> BOX LESSTHAN type GREATERTHAN .)
    RPAREN          reduce using rule 176 (box -> BOX LESSTHAN type GREATERTHAN .)
    RBRACKET        reduce using rule 176 (box -> BOX LESSTHAN type GREATERTHAN .)
    GREATERTHAN     reduce using rule 176 (box -> BOX LESSTHAN type GREATERTHAN .)


state 239

    (174) type_arr -> LBRACKET type SEMICOLON p_lit . RBRACKET

    RBRACKET        shift and go to state 289


state 240

    (177) box_new -> BOX CLASSACCESS NEW . LPAREN exp RPAREN

    LPAREN          shift and go to state 290


state 241

    (92) let -> LET pat EQU . exp
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    LPAREN          shift and go to state 121
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    SEMICOLON       reduce using rule 31 (exp -> .)
    RSQUIGBRACKET   reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 291
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    mul                            shift and go to state 143
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    loop                           shift and go to state 126
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 242

    (90) let -> LET pat COLON . type EQU exp
    (91) let -> LET pat COLON . type
    (152) type -> . BOOL
    (153) type -> . UEIGHT
    (154) type -> . USIXTEEN
    (155) type -> . UTHREETWO
    (156) type -> . USIXFOUR
    (157) type -> . IEIGHT
    (158) type -> . ISIXTEEN
    (159) type -> . ITHREETWO
    (160) type -> . ISIXFOUR
    (161) type -> . FTHREETWO
    (162) type -> . FSIXFOUR
    (163) type -> . CHAR
    (164) type -> . STR
    (165) type -> . box
    (166) type -> . NOT
    (167) type -> . type_ref
    (168) type -> . id
    (169) type -> . AND MUT type
    (170) type -> . type_arr
    (171) type -> . LPAREN RPAREN
    (172) type -> .
    (176) box -> . BOX LESSTHAN type GREATERTHAN
    (175) type_ref -> . AND type
    (143) id -> . ID
    (173) type_arr -> . LBRACKET type RBRACKET
    (174) type_arr -> . LBRACKET type SEMICOLON p_lit RBRACKET

    BOOL            shift and go to state 72
    UEIGHT          shift and go to state 70
    USIXTEEN        shift and go to state 79
    UTHREETWO       shift and go to state 83
    USIXFOUR        shift and go to state 85
    IEIGHT          shift and go to state 76
    ISIXTEEN        shift and go to state 88
    ITHREETWO       shift and go to state 74
    ISIXFOUR        shift and go to state 73
    FTHREETWO       shift and go to state 80
    FSIXFOUR        shift and go to state 75
    CHAR            shift and go to state 67
    STR             shift and go to state 81
    NOT             shift and go to state 86
    AND             shift and go to state 71
    LPAREN          shift and go to state 78
    EQU             reduce using rule 172 (type -> .)
    SEMICOLON       reduce using rule 172 (type -> .)
    RSQUIGBRACKET   reduce using rule 172 (type -> .)
    BOX             shift and go to state 69
    ID              shift and go to state 10
    LBRACKET        shift and go to state 87

    box                            shift and go to state 82
    type_ref                       shift and go to state 84
    type                           shift and go to state 292
    type_arr                       shift and go to state 68
    id                             shift and go to state 66

state 243

    (40) arith3 -> LPAREN arith1 RPAREN .

    ADD             reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    SUB             reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    MUL             reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    DIV             reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    MODOP           reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    LESSTHAN        reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    LESSTHANOREQUAL reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    GREATERTHAN     reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    GREATERTHANOREQUAL reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    EQUALTO         reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    NOTEQUAL        reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    LOGICALOR       reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    LOGICALAND      reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    EQU             reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    PLUSEQUAL       reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    SUBEQUAL        reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    DIVEQUAL        reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    TIMESEQUAL      reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    MODEQUAL        reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    ANDEQUAL        reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    OREQUAL         reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    LBRACKET        reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    PERIOD          reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    SEMICOLON       reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    RSQUIGBRACKET   reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    RPAREN          reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    LPAREN          reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    LOOP            reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    WHILE           reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    BOX             reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    IF              reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    MATCH           reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    ID              reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    NOT             reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    AND             reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    LITDEC          reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    LITCHAR         reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    LITBOOL         reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    LITSTRING       reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    COMMA           reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)
    RBRACKET        reduce using rule 40 (arith3 -> LPAREN arith1 RPAREN .)


state 244

    (19) exp -> LPAREN exp RPAREN .

    RPAREN          reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    EQU             reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    PLUSEQUAL       reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    SUBEQUAL        reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    DIVEQUAL        reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    TIMESEQUAL      reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    MODEQUAL        reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    ANDEQUAL        reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    OREQUAL         reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    LBRACKET        reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    PERIOD          reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    RSQUIGBRACKET   reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    LPAREN          reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    LOOP            reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    WHILE           reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    BOX             reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    IF              reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    MATCH           reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    ID              reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    SUB             reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    NOT             reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    AND             reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    MUL             reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    LITDEC          reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    LITCHAR         reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    LITBOOL         reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    LITSTRING       reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    COMMA           reduce using rule 19 (exp -> LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 19 (exp -> LPAREN exp RPAREN .)


state 245

    (8) stmts -> stmt SEMICOLON stmts .

    RSQUIGBRACKET   reduce using rule 8 (stmts -> stmt SEMICOLON stmts .)


state 246

    (191) enum_con -> enum_con LPAREN exps . RPAREN
    (15) exps -> exps .

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 293

  ! RPAREN          [ reduce using rule 15 (exps -> exps .) ]


state 247

    (99) match -> MATCH LPAREN exp . RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

    RPAREN          shift and go to state 294
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216


state 248

    (65) gt -> arith1 GREATERTHAN arith1 .
    (48) add -> arith1 . ADD arith1
    (49) sub -> arith1 . SUB arith1
    (50) mul -> arith1 . MUL arith1
    (51) div -> arith1 . DIV arith1
    (52) mod -> arith1 . MODOP arith1
    (63) lt -> arith1 . LESSTHAN arith1
    (64) leq -> arith1 . LESSTHANOREQUAL arith1
    (65) gt -> arith1 . GREATERTHAN arith1
    (66) geq -> arith1 . GREATERTHANOREQUAL arith1
    (67) eq -> arith1 . EQUALTO arith1
    (68) neq -> arith1 . NOTEQUAL arith1
    (69) or -> arith1 . LOGICALOR arith1
    (70) and -> arith1 . LOGICALAND arith1
    (20) exp -> arith1 .

  ! reduce/reduce conflict for PERIOD resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for EQU resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for PLUSEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for SUBEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for DIVEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for TIMESEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for MODEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for ANDEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for OREQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 20 (exp -> arith1 .)
    LESSTHAN        reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    LESSTHANOREQUAL reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    GREATERTHAN     reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    GREATERTHANOREQUAL reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    EQUALTO         reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    NOTEQUAL        reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    LOGICALOR       reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    LOGICALAND      reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    COMMA           reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    RBRACKET        reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    SEMICOLON       reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    RSQUIGBRACKET   reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    RPAREN          reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    LPAREN          reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    LOOP            reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    WHILE           reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    BOX             reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    IF              reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    MATCH           reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    ID              reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    NOT             reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    AND             reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    LITDEC          reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    LITCHAR         reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    LITBOOL         reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    LITSTRING       reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .)
    ADD             shift and go to state 204
    SUB             shift and go to state 195
    MUL             shift and go to state 199
    DIV             shift and go to state 197
    MODOP           shift and go to state 205
    PERIOD          reduce using rule 20 (exp -> arith1 .)
    EQU             reduce using rule 20 (exp -> arith1 .)
    PLUSEQUAL       reduce using rule 20 (exp -> arith1 .)
    SUBEQUAL        reduce using rule 20 (exp -> arith1 .)
    DIVEQUAL        reduce using rule 20 (exp -> arith1 .)
    TIMESEQUAL      reduce using rule 20 (exp -> arith1 .)
    MODEQUAL        reduce using rule 20 (exp -> arith1 .)
    ANDEQUAL        reduce using rule 20 (exp -> arith1 .)
    OREQUAL         reduce using rule 20 (exp -> arith1 .)
    LBRACKET        reduce using rule 20 (exp -> arith1 .)

  ! ADD             [ reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .) ]
  ! SUB             [ reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .) ]
  ! MUL             [ reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .) ]
  ! DIV             [ reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .) ]
  ! MODOP           [ reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .) ]
  ! EQU             [ reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .) ]
  ! PLUSEQUAL       [ reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .) ]
  ! SUBEQUAL        [ reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .) ]
  ! DIVEQUAL        [ reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .) ]
  ! TIMESEQUAL      [ reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .) ]
  ! MODEQUAL        [ reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .) ]
  ! ANDEQUAL        [ reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .) ]
  ! OREQUAL         [ reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .) ]
  ! LBRACKET        [ reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .) ]
  ! PERIOD          [ reduce using rule 65 (gt -> arith1 GREATERTHAN arith1 .) ]
  ! LESSTHAN        [ shift and go to state 202 ]
  ! LESSTHANOREQUAL [ shift and go to state 201 ]
  ! GREATERTHAN     [ shift and go to state 194 ]
  ! GREATERTHANOREQUAL [ shift and go to state 198 ]
  ! EQUALTO         [ shift and go to state 206 ]
  ! NOTEQUAL        [ shift and go to state 203 ]
  ! LOGICALOR       [ shift and go to state 196 ]
  ! LOGICALAND      [ shift and go to state 200 ]


state 249

    (49) sub -> arith1 SUB arith1 .
    (48) add -> arith1 . ADD arith1
    (49) sub -> arith1 . SUB arith1
    (50) mul -> arith1 . MUL arith1
    (51) div -> arith1 . DIV arith1
    (52) mod -> arith1 . MODOP arith1
    (63) lt -> arith1 . LESSTHAN arith1
    (64) leq -> arith1 . LESSTHANOREQUAL arith1
    (65) gt -> arith1 . GREATERTHAN arith1
    (66) geq -> arith1 . GREATERTHANOREQUAL arith1
    (67) eq -> arith1 . EQUALTO arith1
    (68) neq -> arith1 . NOTEQUAL arith1
    (69) or -> arith1 . LOGICALOR arith1
    (70) and -> arith1 . LOGICALAND arith1
    (20) exp -> arith1 .

  ! reduce/reduce conflict for PERIOD resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for EQU resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for PLUSEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for SUBEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for DIVEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for TIMESEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for MODEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for ANDEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for OREQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 20 (exp -> arith1 .)
    ADD             reduce using rule 49 (sub -> arith1 SUB arith1 .)
    SUB             reduce using rule 49 (sub -> arith1 SUB arith1 .)
    LESSTHAN        reduce using rule 49 (sub -> arith1 SUB arith1 .)
    LESSTHANOREQUAL reduce using rule 49 (sub -> arith1 SUB arith1 .)
    GREATERTHAN     reduce using rule 49 (sub -> arith1 SUB arith1 .)
    GREATERTHANOREQUAL reduce using rule 49 (sub -> arith1 SUB arith1 .)
    EQUALTO         reduce using rule 49 (sub -> arith1 SUB arith1 .)
    NOTEQUAL        reduce using rule 49 (sub -> arith1 SUB arith1 .)
    LOGICALOR       reduce using rule 49 (sub -> arith1 SUB arith1 .)
    LOGICALAND      reduce using rule 49 (sub -> arith1 SUB arith1 .)
    COMMA           reduce using rule 49 (sub -> arith1 SUB arith1 .)
    RBRACKET        reduce using rule 49 (sub -> arith1 SUB arith1 .)
    RPAREN          reduce using rule 49 (sub -> arith1 SUB arith1 .)
    SEMICOLON       reduce using rule 49 (sub -> arith1 SUB arith1 .)
    RSQUIGBRACKET   reduce using rule 49 (sub -> arith1 SUB arith1 .)
    LPAREN          reduce using rule 49 (sub -> arith1 SUB arith1 .)
    LOOP            reduce using rule 49 (sub -> arith1 SUB arith1 .)
    WHILE           reduce using rule 49 (sub -> arith1 SUB arith1 .)
    BOX             reduce using rule 49 (sub -> arith1 SUB arith1 .)
    IF              reduce using rule 49 (sub -> arith1 SUB arith1 .)
    MATCH           reduce using rule 49 (sub -> arith1 SUB arith1 .)
    ID              reduce using rule 49 (sub -> arith1 SUB arith1 .)
    NOT             reduce using rule 49 (sub -> arith1 SUB arith1 .)
    AND             reduce using rule 49 (sub -> arith1 SUB arith1 .)
    LITDEC          reduce using rule 49 (sub -> arith1 SUB arith1 .)
    LITCHAR         reduce using rule 49 (sub -> arith1 SUB arith1 .)
    LITBOOL         reduce using rule 49 (sub -> arith1 SUB arith1 .)
    LITSTRING       reduce using rule 49 (sub -> arith1 SUB arith1 .)
    MUL             shift and go to state 199
    DIV             shift and go to state 197
    MODOP           shift and go to state 205
    PERIOD          reduce using rule 20 (exp -> arith1 .)
    EQU             reduce using rule 20 (exp -> arith1 .)
    PLUSEQUAL       reduce using rule 20 (exp -> arith1 .)
    SUBEQUAL        reduce using rule 20 (exp -> arith1 .)
    DIVEQUAL        reduce using rule 20 (exp -> arith1 .)
    TIMESEQUAL      reduce using rule 20 (exp -> arith1 .)
    MODEQUAL        reduce using rule 20 (exp -> arith1 .)
    ANDEQUAL        reduce using rule 20 (exp -> arith1 .)
    OREQUAL         reduce using rule 20 (exp -> arith1 .)
    LBRACKET        reduce using rule 20 (exp -> arith1 .)

  ! MUL             [ reduce using rule 49 (sub -> arith1 SUB arith1 .) ]
  ! DIV             [ reduce using rule 49 (sub -> arith1 SUB arith1 .) ]
  ! MODOP           [ reduce using rule 49 (sub -> arith1 SUB arith1 .) ]
  ! EQU             [ reduce using rule 49 (sub -> arith1 SUB arith1 .) ]
  ! PLUSEQUAL       [ reduce using rule 49 (sub -> arith1 SUB arith1 .) ]
  ! SUBEQUAL        [ reduce using rule 49 (sub -> arith1 SUB arith1 .) ]
  ! DIVEQUAL        [ reduce using rule 49 (sub -> arith1 SUB arith1 .) ]
  ! TIMESEQUAL      [ reduce using rule 49 (sub -> arith1 SUB arith1 .) ]
  ! MODEQUAL        [ reduce using rule 49 (sub -> arith1 SUB arith1 .) ]
  ! ANDEQUAL        [ reduce using rule 49 (sub -> arith1 SUB arith1 .) ]
  ! OREQUAL         [ reduce using rule 49 (sub -> arith1 SUB arith1 .) ]
  ! LBRACKET        [ reduce using rule 49 (sub -> arith1 SUB arith1 .) ]
  ! PERIOD          [ reduce using rule 49 (sub -> arith1 SUB arith1 .) ]
  ! ADD             [ shift and go to state 204 ]
  ! SUB             [ shift and go to state 195 ]
  ! LESSTHAN        [ shift and go to state 202 ]
  ! LESSTHANOREQUAL [ shift and go to state 201 ]
  ! GREATERTHAN     [ shift and go to state 194 ]
  ! GREATERTHANOREQUAL [ shift and go to state 198 ]
  ! EQUALTO         [ shift and go to state 206 ]
  ! NOTEQUAL        [ shift and go to state 203 ]
  ! LOGICALOR       [ shift and go to state 196 ]
  ! LOGICALAND      [ shift and go to state 200 ]


state 250

    (69) or -> arith1 LOGICALOR arith1 .
    (48) add -> arith1 . ADD arith1
    (49) sub -> arith1 . SUB arith1
    (50) mul -> arith1 . MUL arith1
    (51) div -> arith1 . DIV arith1
    (52) mod -> arith1 . MODOP arith1
    (63) lt -> arith1 . LESSTHAN arith1
    (64) leq -> arith1 . LESSTHANOREQUAL arith1
    (65) gt -> arith1 . GREATERTHAN arith1
    (66) geq -> arith1 . GREATERTHANOREQUAL arith1
    (67) eq -> arith1 . EQUALTO arith1
    (68) neq -> arith1 . NOTEQUAL arith1
    (69) or -> arith1 . LOGICALOR arith1
    (70) and -> arith1 . LOGICALAND arith1
    (20) exp -> arith1 .

  ! reduce/reduce conflict for PERIOD resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for EQU resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for PLUSEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for SUBEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for DIVEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for TIMESEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for MODEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for ANDEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for OREQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 20 (exp -> arith1 .)
    LOGICALOR       reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    SEMICOLON       reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    RSQUIGBRACKET   reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    RPAREN          reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    LPAREN          reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    LOOP            reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    WHILE           reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    BOX             reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    IF              reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    MATCH           reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    ID              reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    NOT             reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    AND             reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    LITDEC          reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    LITCHAR         reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    LITBOOL         reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    LITSTRING       reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    COMMA           reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    RBRACKET        reduce using rule 69 (or -> arith1 LOGICALOR arith1 .)
    ADD             shift and go to state 204
    SUB             shift and go to state 195
    MUL             shift and go to state 199
    DIV             shift and go to state 197
    MODOP           shift and go to state 205
    LESSTHAN        shift and go to state 202
    LESSTHANOREQUAL shift and go to state 201
    GREATERTHAN     shift and go to state 194
    GREATERTHANOREQUAL shift and go to state 198
    EQUALTO         shift and go to state 206
    NOTEQUAL        shift and go to state 203
    LOGICALAND      shift and go to state 200
    PERIOD          reduce using rule 20 (exp -> arith1 .)
    EQU             reduce using rule 20 (exp -> arith1 .)
    PLUSEQUAL       reduce using rule 20 (exp -> arith1 .)
    SUBEQUAL        reduce using rule 20 (exp -> arith1 .)
    DIVEQUAL        reduce using rule 20 (exp -> arith1 .)
    TIMESEQUAL      reduce using rule 20 (exp -> arith1 .)
    MODEQUAL        reduce using rule 20 (exp -> arith1 .)
    ANDEQUAL        reduce using rule 20 (exp -> arith1 .)
    OREQUAL         reduce using rule 20 (exp -> arith1 .)
    LBRACKET        reduce using rule 20 (exp -> arith1 .)

  ! ADD             [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! SUB             [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! MUL             [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! DIV             [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! MODOP           [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! LESSTHAN        [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! LESSTHANOREQUAL [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! GREATERTHAN     [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! GREATERTHANOREQUAL [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! EQUALTO         [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! NOTEQUAL        [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! LOGICALAND      [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! EQU             [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! PLUSEQUAL       [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! SUBEQUAL        [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! DIVEQUAL        [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! TIMESEQUAL      [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! MODEQUAL        [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! ANDEQUAL        [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! OREQUAL         [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! LBRACKET        [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! PERIOD          [ reduce using rule 69 (or -> arith1 LOGICALOR arith1 .) ]
  ! LOGICALOR       [ shift and go to state 196 ]


state 251

    (51) div -> arith1 DIV arith1 .
    (48) add -> arith1 . ADD arith1
    (49) sub -> arith1 . SUB arith1
    (50) mul -> arith1 . MUL arith1
    (51) div -> arith1 . DIV arith1
    (52) mod -> arith1 . MODOP arith1
    (63) lt -> arith1 . LESSTHAN arith1
    (64) leq -> arith1 . LESSTHANOREQUAL arith1
    (65) gt -> arith1 . GREATERTHAN arith1
    (66) geq -> arith1 . GREATERTHANOREQUAL arith1
    (67) eq -> arith1 . EQUALTO arith1
    (68) neq -> arith1 . NOTEQUAL arith1
    (69) or -> arith1 . LOGICALOR arith1
    (70) and -> arith1 . LOGICALAND arith1
    (20) exp -> arith1 .

  ! reduce/reduce conflict for PERIOD resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for EQU resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for PLUSEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for SUBEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for DIVEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for TIMESEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for MODEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for ANDEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for OREQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 20 (exp -> arith1 .)
    ADD             reduce using rule 51 (div -> arith1 DIV arith1 .)
    SUB             reduce using rule 51 (div -> arith1 DIV arith1 .)
    MUL             reduce using rule 51 (div -> arith1 DIV arith1 .)
    DIV             reduce using rule 51 (div -> arith1 DIV arith1 .)
    MODOP           reduce using rule 51 (div -> arith1 DIV arith1 .)
    LESSTHAN        reduce using rule 51 (div -> arith1 DIV arith1 .)
    LESSTHANOREQUAL reduce using rule 51 (div -> arith1 DIV arith1 .)
    GREATERTHAN     reduce using rule 51 (div -> arith1 DIV arith1 .)
    GREATERTHANOREQUAL reduce using rule 51 (div -> arith1 DIV arith1 .)
    EQUALTO         reduce using rule 51 (div -> arith1 DIV arith1 .)
    NOTEQUAL        reduce using rule 51 (div -> arith1 DIV arith1 .)
    LOGICALOR       reduce using rule 51 (div -> arith1 DIV arith1 .)
    LOGICALAND      reduce using rule 51 (div -> arith1 DIV arith1 .)
    SEMICOLON       reduce using rule 51 (div -> arith1 DIV arith1 .)
    RSQUIGBRACKET   reduce using rule 51 (div -> arith1 DIV arith1 .)
    RPAREN          reduce using rule 51 (div -> arith1 DIV arith1 .)
    LPAREN          reduce using rule 51 (div -> arith1 DIV arith1 .)
    LOOP            reduce using rule 51 (div -> arith1 DIV arith1 .)
    WHILE           reduce using rule 51 (div -> arith1 DIV arith1 .)
    BOX             reduce using rule 51 (div -> arith1 DIV arith1 .)
    IF              reduce using rule 51 (div -> arith1 DIV arith1 .)
    MATCH           reduce using rule 51 (div -> arith1 DIV arith1 .)
    ID              reduce using rule 51 (div -> arith1 DIV arith1 .)
    NOT             reduce using rule 51 (div -> arith1 DIV arith1 .)
    AND             reduce using rule 51 (div -> arith1 DIV arith1 .)
    LITDEC          reduce using rule 51 (div -> arith1 DIV arith1 .)
    LITCHAR         reduce using rule 51 (div -> arith1 DIV arith1 .)
    LITBOOL         reduce using rule 51 (div -> arith1 DIV arith1 .)
    LITSTRING       reduce using rule 51 (div -> arith1 DIV arith1 .)
    COMMA           reduce using rule 51 (div -> arith1 DIV arith1 .)
    RBRACKET        reduce using rule 51 (div -> arith1 DIV arith1 .)
    PERIOD          reduce using rule 20 (exp -> arith1 .)
    EQU             reduce using rule 20 (exp -> arith1 .)
    PLUSEQUAL       reduce using rule 20 (exp -> arith1 .)
    SUBEQUAL        reduce using rule 20 (exp -> arith1 .)
    DIVEQUAL        reduce using rule 20 (exp -> arith1 .)
    TIMESEQUAL      reduce using rule 20 (exp -> arith1 .)
    MODEQUAL        reduce using rule 20 (exp -> arith1 .)
    ANDEQUAL        reduce using rule 20 (exp -> arith1 .)
    OREQUAL         reduce using rule 20 (exp -> arith1 .)
    LBRACKET        reduce using rule 20 (exp -> arith1 .)

  ! EQU             [ reduce using rule 51 (div -> arith1 DIV arith1 .) ]
  ! PLUSEQUAL       [ reduce using rule 51 (div -> arith1 DIV arith1 .) ]
  ! SUBEQUAL        [ reduce using rule 51 (div -> arith1 DIV arith1 .) ]
  ! DIVEQUAL        [ reduce using rule 51 (div -> arith1 DIV arith1 .) ]
  ! TIMESEQUAL      [ reduce using rule 51 (div -> arith1 DIV arith1 .) ]
  ! MODEQUAL        [ reduce using rule 51 (div -> arith1 DIV arith1 .) ]
  ! ANDEQUAL        [ reduce using rule 51 (div -> arith1 DIV arith1 .) ]
  ! OREQUAL         [ reduce using rule 51 (div -> arith1 DIV arith1 .) ]
  ! LBRACKET        [ reduce using rule 51 (div -> arith1 DIV arith1 .) ]
  ! PERIOD          [ reduce using rule 51 (div -> arith1 DIV arith1 .) ]
  ! ADD             [ shift and go to state 204 ]
  ! SUB             [ shift and go to state 195 ]
  ! MUL             [ shift and go to state 199 ]
  ! DIV             [ shift and go to state 197 ]
  ! MODOP           [ shift and go to state 205 ]
  ! LESSTHAN        [ shift and go to state 202 ]
  ! LESSTHANOREQUAL [ shift and go to state 201 ]
  ! GREATERTHAN     [ shift and go to state 194 ]
  ! GREATERTHANOREQUAL [ shift and go to state 198 ]
  ! EQUALTO         [ shift and go to state 206 ]
  ! NOTEQUAL        [ shift and go to state 203 ]
  ! LOGICALOR       [ shift and go to state 196 ]
  ! LOGICALAND      [ shift and go to state 200 ]


state 252

    (66) geq -> arith1 GREATERTHANOREQUAL arith1 .
    (48) add -> arith1 . ADD arith1
    (49) sub -> arith1 . SUB arith1
    (50) mul -> arith1 . MUL arith1
    (51) div -> arith1 . DIV arith1
    (52) mod -> arith1 . MODOP arith1
    (63) lt -> arith1 . LESSTHAN arith1
    (64) leq -> arith1 . LESSTHANOREQUAL arith1
    (65) gt -> arith1 . GREATERTHAN arith1
    (66) geq -> arith1 . GREATERTHANOREQUAL arith1
    (67) eq -> arith1 . EQUALTO arith1
    (68) neq -> arith1 . NOTEQUAL arith1
    (69) or -> arith1 . LOGICALOR arith1
    (70) and -> arith1 . LOGICALAND arith1
    (20) exp -> arith1 .

  ! reduce/reduce conflict for PERIOD resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for EQU resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for PLUSEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for SUBEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for DIVEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for TIMESEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for MODEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for ANDEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for OREQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 20 (exp -> arith1 .)
    LESSTHAN        reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    LESSTHANOREQUAL reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    GREATERTHAN     reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    GREATERTHANOREQUAL reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    EQUALTO         reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    NOTEQUAL        reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    LOGICALOR       reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    LOGICALAND      reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    SEMICOLON       reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    RSQUIGBRACKET   reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    RPAREN          reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    LPAREN          reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    LOOP            reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    WHILE           reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    BOX             reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    IF              reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    MATCH           reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    ID              reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    NOT             reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    AND             reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    LITDEC          reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    LITCHAR         reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    LITBOOL         reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    LITSTRING       reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    COMMA           reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    RBRACKET        reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .)
    ADD             shift and go to state 204
    SUB             shift and go to state 195
    MUL             shift and go to state 199
    DIV             shift and go to state 197
    MODOP           shift and go to state 205
    PERIOD          reduce using rule 20 (exp -> arith1 .)
    EQU             reduce using rule 20 (exp -> arith1 .)
    PLUSEQUAL       reduce using rule 20 (exp -> arith1 .)
    SUBEQUAL        reduce using rule 20 (exp -> arith1 .)
    DIVEQUAL        reduce using rule 20 (exp -> arith1 .)
    TIMESEQUAL      reduce using rule 20 (exp -> arith1 .)
    MODEQUAL        reduce using rule 20 (exp -> arith1 .)
    ANDEQUAL        reduce using rule 20 (exp -> arith1 .)
    OREQUAL         reduce using rule 20 (exp -> arith1 .)
    LBRACKET        reduce using rule 20 (exp -> arith1 .)

  ! ADD             [ reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .) ]
  ! SUB             [ reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .) ]
  ! MUL             [ reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .) ]
  ! DIV             [ reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .) ]
  ! MODOP           [ reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .) ]
  ! EQU             [ reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .) ]
  ! PLUSEQUAL       [ reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .) ]
  ! SUBEQUAL        [ reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .) ]
  ! DIVEQUAL        [ reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .) ]
  ! TIMESEQUAL      [ reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .) ]
  ! MODEQUAL        [ reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .) ]
  ! ANDEQUAL        [ reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .) ]
  ! OREQUAL         [ reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .) ]
  ! LBRACKET        [ reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .) ]
  ! PERIOD          [ reduce using rule 66 (geq -> arith1 GREATERTHANOREQUAL arith1 .) ]
  ! LESSTHAN        [ shift and go to state 202 ]
  ! LESSTHANOREQUAL [ shift and go to state 201 ]
  ! GREATERTHAN     [ shift and go to state 194 ]
  ! GREATERTHANOREQUAL [ shift and go to state 198 ]
  ! EQUALTO         [ shift and go to state 206 ]
  ! NOTEQUAL        [ shift and go to state 203 ]
  ! LOGICALOR       [ shift and go to state 196 ]
  ! LOGICALAND      [ shift and go to state 200 ]


state 253

    (50) mul -> arith1 MUL arith1 .
    (48) add -> arith1 . ADD arith1
    (49) sub -> arith1 . SUB arith1
    (50) mul -> arith1 . MUL arith1
    (51) div -> arith1 . DIV arith1
    (52) mod -> arith1 . MODOP arith1
    (63) lt -> arith1 . LESSTHAN arith1
    (64) leq -> arith1 . LESSTHANOREQUAL arith1
    (65) gt -> arith1 . GREATERTHAN arith1
    (66) geq -> arith1 . GREATERTHANOREQUAL arith1
    (67) eq -> arith1 . EQUALTO arith1
    (68) neq -> arith1 . NOTEQUAL arith1
    (69) or -> arith1 . LOGICALOR arith1
    (70) and -> arith1 . LOGICALAND arith1
    (20) exp -> arith1 .

  ! reduce/reduce conflict for PERIOD resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for EQU resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for PLUSEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for SUBEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for DIVEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for TIMESEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for MODEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for ANDEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for OREQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 20 (exp -> arith1 .)
    ADD             reduce using rule 50 (mul -> arith1 MUL arith1 .)
    SUB             reduce using rule 50 (mul -> arith1 MUL arith1 .)
    MUL             reduce using rule 50 (mul -> arith1 MUL arith1 .)
    DIV             reduce using rule 50 (mul -> arith1 MUL arith1 .)
    MODOP           reduce using rule 50 (mul -> arith1 MUL arith1 .)
    LESSTHAN        reduce using rule 50 (mul -> arith1 MUL arith1 .)
    LESSTHANOREQUAL reduce using rule 50 (mul -> arith1 MUL arith1 .)
    GREATERTHAN     reduce using rule 50 (mul -> arith1 MUL arith1 .)
    GREATERTHANOREQUAL reduce using rule 50 (mul -> arith1 MUL arith1 .)
    EQUALTO         reduce using rule 50 (mul -> arith1 MUL arith1 .)
    NOTEQUAL        reduce using rule 50 (mul -> arith1 MUL arith1 .)
    LOGICALOR       reduce using rule 50 (mul -> arith1 MUL arith1 .)
    LOGICALAND      reduce using rule 50 (mul -> arith1 MUL arith1 .)
    SEMICOLON       reduce using rule 50 (mul -> arith1 MUL arith1 .)
    RSQUIGBRACKET   reduce using rule 50 (mul -> arith1 MUL arith1 .)
    RPAREN          reduce using rule 50 (mul -> arith1 MUL arith1 .)
    LPAREN          reduce using rule 50 (mul -> arith1 MUL arith1 .)
    LOOP            reduce using rule 50 (mul -> arith1 MUL arith1 .)
    WHILE           reduce using rule 50 (mul -> arith1 MUL arith1 .)
    BOX             reduce using rule 50 (mul -> arith1 MUL arith1 .)
    IF              reduce using rule 50 (mul -> arith1 MUL arith1 .)
    MATCH           reduce using rule 50 (mul -> arith1 MUL arith1 .)
    ID              reduce using rule 50 (mul -> arith1 MUL arith1 .)
    NOT             reduce using rule 50 (mul -> arith1 MUL arith1 .)
    AND             reduce using rule 50 (mul -> arith1 MUL arith1 .)
    LITDEC          reduce using rule 50 (mul -> arith1 MUL arith1 .)
    LITCHAR         reduce using rule 50 (mul -> arith1 MUL arith1 .)
    LITBOOL         reduce using rule 50 (mul -> arith1 MUL arith1 .)
    LITSTRING       reduce using rule 50 (mul -> arith1 MUL arith1 .)
    COMMA           reduce using rule 50 (mul -> arith1 MUL arith1 .)
    RBRACKET        reduce using rule 50 (mul -> arith1 MUL arith1 .)
    PERIOD          reduce using rule 20 (exp -> arith1 .)
    EQU             reduce using rule 20 (exp -> arith1 .)
    PLUSEQUAL       reduce using rule 20 (exp -> arith1 .)
    SUBEQUAL        reduce using rule 20 (exp -> arith1 .)
    DIVEQUAL        reduce using rule 20 (exp -> arith1 .)
    TIMESEQUAL      reduce using rule 20 (exp -> arith1 .)
    MODEQUAL        reduce using rule 20 (exp -> arith1 .)
    ANDEQUAL        reduce using rule 20 (exp -> arith1 .)
    OREQUAL         reduce using rule 20 (exp -> arith1 .)
    LBRACKET        reduce using rule 20 (exp -> arith1 .)

  ! EQU             [ reduce using rule 50 (mul -> arith1 MUL arith1 .) ]
  ! PLUSEQUAL       [ reduce using rule 50 (mul -> arith1 MUL arith1 .) ]
  ! SUBEQUAL        [ reduce using rule 50 (mul -> arith1 MUL arith1 .) ]
  ! DIVEQUAL        [ reduce using rule 50 (mul -> arith1 MUL arith1 .) ]
  ! TIMESEQUAL      [ reduce using rule 50 (mul -> arith1 MUL arith1 .) ]
  ! MODEQUAL        [ reduce using rule 50 (mul -> arith1 MUL arith1 .) ]
  ! ANDEQUAL        [ reduce using rule 50 (mul -> arith1 MUL arith1 .) ]
  ! OREQUAL         [ reduce using rule 50 (mul -> arith1 MUL arith1 .) ]
  ! LBRACKET        [ reduce using rule 50 (mul -> arith1 MUL arith1 .) ]
  ! PERIOD          [ reduce using rule 50 (mul -> arith1 MUL arith1 .) ]
  ! ADD             [ shift and go to state 204 ]
  ! SUB             [ shift and go to state 195 ]
  ! MUL             [ shift and go to state 199 ]
  ! DIV             [ shift and go to state 197 ]
  ! MODOP           [ shift and go to state 205 ]
  ! LESSTHAN        [ shift and go to state 202 ]
  ! LESSTHANOREQUAL [ shift and go to state 201 ]
  ! GREATERTHAN     [ shift and go to state 194 ]
  ! GREATERTHANOREQUAL [ shift and go to state 198 ]
  ! EQUALTO         [ shift and go to state 206 ]
  ! NOTEQUAL        [ shift and go to state 203 ]
  ! LOGICALOR       [ shift and go to state 196 ]
  ! LOGICALAND      [ shift and go to state 200 ]


state 254

    (70) and -> arith1 LOGICALAND arith1 .
    (48) add -> arith1 . ADD arith1
    (49) sub -> arith1 . SUB arith1
    (50) mul -> arith1 . MUL arith1
    (51) div -> arith1 . DIV arith1
    (52) mod -> arith1 . MODOP arith1
    (63) lt -> arith1 . LESSTHAN arith1
    (64) leq -> arith1 . LESSTHANOREQUAL arith1
    (65) gt -> arith1 . GREATERTHAN arith1
    (66) geq -> arith1 . GREATERTHANOREQUAL arith1
    (67) eq -> arith1 . EQUALTO arith1
    (68) neq -> arith1 . NOTEQUAL arith1
    (69) or -> arith1 . LOGICALOR arith1
    (70) and -> arith1 . LOGICALAND arith1
    (20) exp -> arith1 .

  ! reduce/reduce conflict for PERIOD resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for EQU resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for PLUSEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for SUBEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for DIVEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for TIMESEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for MODEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for ANDEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for OREQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 20 (exp -> arith1 .)
    LOGICALOR       reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    LOGICALAND      reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    SEMICOLON       reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    RSQUIGBRACKET   reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    RPAREN          reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    LPAREN          reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    LOOP            reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    WHILE           reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    BOX             reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    IF              reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    MATCH           reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    ID              reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    NOT             reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    AND             reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    LITDEC          reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    LITCHAR         reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    LITBOOL         reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    LITSTRING       reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    COMMA           reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    RBRACKET        reduce using rule 70 (and -> arith1 LOGICALAND arith1 .)
    ADD             shift and go to state 204
    SUB             shift and go to state 195
    MUL             shift and go to state 199
    DIV             shift and go to state 197
    MODOP           shift and go to state 205
    LESSTHAN        shift and go to state 202
    LESSTHANOREQUAL shift and go to state 201
    GREATERTHAN     shift and go to state 194
    GREATERTHANOREQUAL shift and go to state 198
    EQUALTO         shift and go to state 206
    NOTEQUAL        shift and go to state 203
    PERIOD          reduce using rule 20 (exp -> arith1 .)
    EQU             reduce using rule 20 (exp -> arith1 .)
    PLUSEQUAL       reduce using rule 20 (exp -> arith1 .)
    SUBEQUAL        reduce using rule 20 (exp -> arith1 .)
    DIVEQUAL        reduce using rule 20 (exp -> arith1 .)
    TIMESEQUAL      reduce using rule 20 (exp -> arith1 .)
    MODEQUAL        reduce using rule 20 (exp -> arith1 .)
    ANDEQUAL        reduce using rule 20 (exp -> arith1 .)
    OREQUAL         reduce using rule 20 (exp -> arith1 .)
    LBRACKET        reduce using rule 20 (exp -> arith1 .)

  ! ADD             [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! SUB             [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! MUL             [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! DIV             [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! MODOP           [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! LESSTHAN        [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! LESSTHANOREQUAL [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! GREATERTHAN     [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! GREATERTHANOREQUAL [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! EQUALTO         [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! NOTEQUAL        [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! EQU             [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! PLUSEQUAL       [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! SUBEQUAL        [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! DIVEQUAL        [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! TIMESEQUAL      [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! MODEQUAL        [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! ANDEQUAL        [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! OREQUAL         [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! LBRACKET        [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! PERIOD          [ reduce using rule 70 (and -> arith1 LOGICALAND arith1 .) ]
  ! LOGICALOR       [ shift and go to state 196 ]
  ! LOGICALAND      [ shift and go to state 200 ]


state 255

    (64) leq -> arith1 LESSTHANOREQUAL arith1 .
    (48) add -> arith1 . ADD arith1
    (49) sub -> arith1 . SUB arith1
    (50) mul -> arith1 . MUL arith1
    (51) div -> arith1 . DIV arith1
    (52) mod -> arith1 . MODOP arith1
    (63) lt -> arith1 . LESSTHAN arith1
    (64) leq -> arith1 . LESSTHANOREQUAL arith1
    (65) gt -> arith1 . GREATERTHAN arith1
    (66) geq -> arith1 . GREATERTHANOREQUAL arith1
    (67) eq -> arith1 . EQUALTO arith1
    (68) neq -> arith1 . NOTEQUAL arith1
    (69) or -> arith1 . LOGICALOR arith1
    (70) and -> arith1 . LOGICALAND arith1
    (20) exp -> arith1 .

  ! reduce/reduce conflict for PERIOD resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for EQU resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for PLUSEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for SUBEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for DIVEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for TIMESEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for MODEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for ANDEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for OREQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 20 (exp -> arith1 .)
    LESSTHAN        reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    LESSTHANOREQUAL reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    GREATERTHAN     reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    GREATERTHANOREQUAL reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    EQUALTO         reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    NOTEQUAL        reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    LOGICALOR       reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    LOGICALAND      reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    SEMICOLON       reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    RSQUIGBRACKET   reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    RPAREN          reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    LPAREN          reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    LOOP            reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    WHILE           reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    BOX             reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    IF              reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    MATCH           reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    ID              reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    NOT             reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    AND             reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    LITDEC          reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    LITCHAR         reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    LITBOOL         reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    LITSTRING       reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    COMMA           reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    RBRACKET        reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .)
    ADD             shift and go to state 204
    SUB             shift and go to state 195
    MUL             shift and go to state 199
    DIV             shift and go to state 197
    MODOP           shift and go to state 205
    PERIOD          reduce using rule 20 (exp -> arith1 .)
    EQU             reduce using rule 20 (exp -> arith1 .)
    PLUSEQUAL       reduce using rule 20 (exp -> arith1 .)
    SUBEQUAL        reduce using rule 20 (exp -> arith1 .)
    DIVEQUAL        reduce using rule 20 (exp -> arith1 .)
    TIMESEQUAL      reduce using rule 20 (exp -> arith1 .)
    MODEQUAL        reduce using rule 20 (exp -> arith1 .)
    ANDEQUAL        reduce using rule 20 (exp -> arith1 .)
    OREQUAL         reduce using rule 20 (exp -> arith1 .)
    LBRACKET        reduce using rule 20 (exp -> arith1 .)

  ! ADD             [ reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .) ]
  ! SUB             [ reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .) ]
  ! MUL             [ reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .) ]
  ! DIV             [ reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .) ]
  ! MODOP           [ reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .) ]
  ! EQU             [ reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .) ]
  ! PLUSEQUAL       [ reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .) ]
  ! SUBEQUAL        [ reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .) ]
  ! DIVEQUAL        [ reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .) ]
  ! TIMESEQUAL      [ reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .) ]
  ! MODEQUAL        [ reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .) ]
  ! ANDEQUAL        [ reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .) ]
  ! OREQUAL         [ reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .) ]
  ! LBRACKET        [ reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .) ]
  ! PERIOD          [ reduce using rule 64 (leq -> arith1 LESSTHANOREQUAL arith1 .) ]
  ! LESSTHAN        [ shift and go to state 202 ]
  ! LESSTHANOREQUAL [ shift and go to state 201 ]
  ! GREATERTHAN     [ shift and go to state 194 ]
  ! GREATERTHANOREQUAL [ shift and go to state 198 ]
  ! EQUALTO         [ shift and go to state 206 ]
  ! NOTEQUAL        [ shift and go to state 203 ]
  ! LOGICALOR       [ shift and go to state 196 ]
  ! LOGICALAND      [ shift and go to state 200 ]


state 256

    (63) lt -> arith1 LESSTHAN arith1 .
    (48) add -> arith1 . ADD arith1
    (49) sub -> arith1 . SUB arith1
    (50) mul -> arith1 . MUL arith1
    (51) div -> arith1 . DIV arith1
    (52) mod -> arith1 . MODOP arith1
    (63) lt -> arith1 . LESSTHAN arith1
    (64) leq -> arith1 . LESSTHANOREQUAL arith1
    (65) gt -> arith1 . GREATERTHAN arith1
    (66) geq -> arith1 . GREATERTHANOREQUAL arith1
    (67) eq -> arith1 . EQUALTO arith1
    (68) neq -> arith1 . NOTEQUAL arith1
    (69) or -> arith1 . LOGICALOR arith1
    (70) and -> arith1 . LOGICALAND arith1
    (20) exp -> arith1 .

  ! reduce/reduce conflict for PERIOD resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for EQU resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for PLUSEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for SUBEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for DIVEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for TIMESEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for MODEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for ANDEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for OREQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 20 (exp -> arith1 .)
    RPAREN          reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    LESSTHAN        reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    LESSTHANOREQUAL reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    GREATERTHAN     reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    GREATERTHANOREQUAL reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    EQUALTO         reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    NOTEQUAL        reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    LOGICALOR       reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    LOGICALAND      reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    SEMICOLON       reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    RSQUIGBRACKET   reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    LPAREN          reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    LOOP            reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    WHILE           reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    BOX             reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    IF              reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    MATCH           reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    ID              reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    NOT             reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    AND             reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    LITDEC          reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    LITCHAR         reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    LITBOOL         reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    LITSTRING       reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    COMMA           reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    RBRACKET        reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .)
    ADD             shift and go to state 204
    SUB             shift and go to state 195
    MUL             shift and go to state 199
    DIV             shift and go to state 197
    MODOP           shift and go to state 205
    PERIOD          reduce using rule 20 (exp -> arith1 .)
    EQU             reduce using rule 20 (exp -> arith1 .)
    PLUSEQUAL       reduce using rule 20 (exp -> arith1 .)
    SUBEQUAL        reduce using rule 20 (exp -> arith1 .)
    DIVEQUAL        reduce using rule 20 (exp -> arith1 .)
    TIMESEQUAL      reduce using rule 20 (exp -> arith1 .)
    MODEQUAL        reduce using rule 20 (exp -> arith1 .)
    ANDEQUAL        reduce using rule 20 (exp -> arith1 .)
    OREQUAL         reduce using rule 20 (exp -> arith1 .)
    LBRACKET        reduce using rule 20 (exp -> arith1 .)

  ! ADD             [ reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .) ]
  ! SUB             [ reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .) ]
  ! MUL             [ reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .) ]
  ! DIV             [ reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .) ]
  ! MODOP           [ reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .) ]
  ! EQU             [ reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .) ]
  ! PLUSEQUAL       [ reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .) ]
  ! SUBEQUAL        [ reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .) ]
  ! DIVEQUAL        [ reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .) ]
  ! TIMESEQUAL      [ reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .) ]
  ! MODEQUAL        [ reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .) ]
  ! ANDEQUAL        [ reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .) ]
  ! OREQUAL         [ reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .) ]
  ! LBRACKET        [ reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .) ]
  ! PERIOD          [ reduce using rule 63 (lt -> arith1 LESSTHAN arith1 .) ]
  ! LESSTHAN        [ shift and go to state 202 ]
  ! LESSTHANOREQUAL [ shift and go to state 201 ]
  ! GREATERTHAN     [ shift and go to state 194 ]
  ! GREATERTHANOREQUAL [ shift and go to state 198 ]
  ! EQUALTO         [ shift and go to state 206 ]
  ! NOTEQUAL        [ shift and go to state 203 ]
  ! LOGICALOR       [ shift and go to state 196 ]
  ! LOGICALAND      [ shift and go to state 200 ]


state 257

    (68) neq -> arith1 NOTEQUAL arith1 .
    (48) add -> arith1 . ADD arith1
    (49) sub -> arith1 . SUB arith1
    (50) mul -> arith1 . MUL arith1
    (51) div -> arith1 . DIV arith1
    (52) mod -> arith1 . MODOP arith1
    (63) lt -> arith1 . LESSTHAN arith1
    (64) leq -> arith1 . LESSTHANOREQUAL arith1
    (65) gt -> arith1 . GREATERTHAN arith1
    (66) geq -> arith1 . GREATERTHANOREQUAL arith1
    (67) eq -> arith1 . EQUALTO arith1
    (68) neq -> arith1 . NOTEQUAL arith1
    (69) or -> arith1 . LOGICALOR arith1
    (70) and -> arith1 . LOGICALAND arith1
    (20) exp -> arith1 .

  ! reduce/reduce conflict for PERIOD resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for EQU resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for PLUSEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for SUBEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for DIVEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for TIMESEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for MODEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for ANDEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for OREQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 20 (exp -> arith1 .)
    LESSTHAN        reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    LESSTHANOREQUAL reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    GREATERTHAN     reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    GREATERTHANOREQUAL reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    EQUALTO         reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    NOTEQUAL        reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    LOGICALOR       reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    LOGICALAND      reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    SEMICOLON       reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    RSQUIGBRACKET   reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    RPAREN          reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    LPAREN          reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    LOOP            reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    WHILE           reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    BOX             reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    IF              reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    MATCH           reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    ID              reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    NOT             reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    AND             reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    LITDEC          reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    LITCHAR         reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    LITBOOL         reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    LITSTRING       reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    COMMA           reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    RBRACKET        reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .)
    ADD             shift and go to state 204
    SUB             shift and go to state 195
    MUL             shift and go to state 199
    DIV             shift and go to state 197
    MODOP           shift and go to state 205
    PERIOD          reduce using rule 20 (exp -> arith1 .)
    EQU             reduce using rule 20 (exp -> arith1 .)
    PLUSEQUAL       reduce using rule 20 (exp -> arith1 .)
    SUBEQUAL        reduce using rule 20 (exp -> arith1 .)
    DIVEQUAL        reduce using rule 20 (exp -> arith1 .)
    TIMESEQUAL      reduce using rule 20 (exp -> arith1 .)
    MODEQUAL        reduce using rule 20 (exp -> arith1 .)
    ANDEQUAL        reduce using rule 20 (exp -> arith1 .)
    OREQUAL         reduce using rule 20 (exp -> arith1 .)
    LBRACKET        reduce using rule 20 (exp -> arith1 .)

  ! ADD             [ reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .) ]
  ! SUB             [ reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .) ]
  ! MUL             [ reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .) ]
  ! DIV             [ reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .) ]
  ! MODOP           [ reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .) ]
  ! EQU             [ reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .) ]
  ! PLUSEQUAL       [ reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .) ]
  ! SUBEQUAL        [ reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .) ]
  ! DIVEQUAL        [ reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .) ]
  ! TIMESEQUAL      [ reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .) ]
  ! MODEQUAL        [ reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .) ]
  ! ANDEQUAL        [ reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .) ]
  ! OREQUAL         [ reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .) ]
  ! LBRACKET        [ reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .) ]
  ! PERIOD          [ reduce using rule 68 (neq -> arith1 NOTEQUAL arith1 .) ]
  ! LESSTHAN        [ shift and go to state 202 ]
  ! LESSTHANOREQUAL [ shift and go to state 201 ]
  ! GREATERTHAN     [ shift and go to state 194 ]
  ! GREATERTHANOREQUAL [ shift and go to state 198 ]
  ! EQUALTO         [ shift and go to state 206 ]
  ! NOTEQUAL        [ shift and go to state 203 ]
  ! LOGICALOR       [ shift and go to state 196 ]
  ! LOGICALAND      [ shift and go to state 200 ]


state 258

    (48) add -> arith1 ADD arith1 .
    (48) add -> arith1 . ADD arith1
    (49) sub -> arith1 . SUB arith1
    (50) mul -> arith1 . MUL arith1
    (51) div -> arith1 . DIV arith1
    (52) mod -> arith1 . MODOP arith1
    (63) lt -> arith1 . LESSTHAN arith1
    (64) leq -> arith1 . LESSTHANOREQUAL arith1
    (65) gt -> arith1 . GREATERTHAN arith1
    (66) geq -> arith1 . GREATERTHANOREQUAL arith1
    (67) eq -> arith1 . EQUALTO arith1
    (68) neq -> arith1 . NOTEQUAL arith1
    (69) or -> arith1 . LOGICALOR arith1
    (70) and -> arith1 . LOGICALAND arith1
    (20) exp -> arith1 .

  ! reduce/reduce conflict for PERIOD resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for EQU resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for PLUSEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for SUBEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for DIVEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for TIMESEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for MODEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for ANDEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for OREQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 20 (exp -> arith1 .)
    ADD             reduce using rule 48 (add -> arith1 ADD arith1 .)
    SUB             reduce using rule 48 (add -> arith1 ADD arith1 .)
    LESSTHAN        reduce using rule 48 (add -> arith1 ADD arith1 .)
    LESSTHANOREQUAL reduce using rule 48 (add -> arith1 ADD arith1 .)
    GREATERTHAN     reduce using rule 48 (add -> arith1 ADD arith1 .)
    GREATERTHANOREQUAL reduce using rule 48 (add -> arith1 ADD arith1 .)
    EQUALTO         reduce using rule 48 (add -> arith1 ADD arith1 .)
    NOTEQUAL        reduce using rule 48 (add -> arith1 ADD arith1 .)
    LOGICALOR       reduce using rule 48 (add -> arith1 ADD arith1 .)
    LOGICALAND      reduce using rule 48 (add -> arith1 ADD arith1 .)
    LPAREN          reduce using rule 48 (add -> arith1 ADD arith1 .)
    LOOP            reduce using rule 48 (add -> arith1 ADD arith1 .)
    WHILE           reduce using rule 48 (add -> arith1 ADD arith1 .)
    BOX             reduce using rule 48 (add -> arith1 ADD arith1 .)
    IF              reduce using rule 48 (add -> arith1 ADD arith1 .)
    MATCH           reduce using rule 48 (add -> arith1 ADD arith1 .)
    ID              reduce using rule 48 (add -> arith1 ADD arith1 .)
    NOT             reduce using rule 48 (add -> arith1 ADD arith1 .)
    AND             reduce using rule 48 (add -> arith1 ADD arith1 .)
    LITDEC          reduce using rule 48 (add -> arith1 ADD arith1 .)
    LITCHAR         reduce using rule 48 (add -> arith1 ADD arith1 .)
    LITBOOL         reduce using rule 48 (add -> arith1 ADD arith1 .)
    LITSTRING       reduce using rule 48 (add -> arith1 ADD arith1 .)
    SEMICOLON       reduce using rule 48 (add -> arith1 ADD arith1 .)
    RSQUIGBRACKET   reduce using rule 48 (add -> arith1 ADD arith1 .)
    RPAREN          reduce using rule 48 (add -> arith1 ADD arith1 .)
    COMMA           reduce using rule 48 (add -> arith1 ADD arith1 .)
    RBRACKET        reduce using rule 48 (add -> arith1 ADD arith1 .)
    MUL             shift and go to state 199
    DIV             shift and go to state 197
    MODOP           shift and go to state 205
    PERIOD          reduce using rule 20 (exp -> arith1 .)
    EQU             reduce using rule 20 (exp -> arith1 .)
    PLUSEQUAL       reduce using rule 20 (exp -> arith1 .)
    SUBEQUAL        reduce using rule 20 (exp -> arith1 .)
    DIVEQUAL        reduce using rule 20 (exp -> arith1 .)
    TIMESEQUAL      reduce using rule 20 (exp -> arith1 .)
    MODEQUAL        reduce using rule 20 (exp -> arith1 .)
    ANDEQUAL        reduce using rule 20 (exp -> arith1 .)
    OREQUAL         reduce using rule 20 (exp -> arith1 .)
    LBRACKET        reduce using rule 20 (exp -> arith1 .)

  ! MUL             [ reduce using rule 48 (add -> arith1 ADD arith1 .) ]
  ! DIV             [ reduce using rule 48 (add -> arith1 ADD arith1 .) ]
  ! MODOP           [ reduce using rule 48 (add -> arith1 ADD arith1 .) ]
  ! EQU             [ reduce using rule 48 (add -> arith1 ADD arith1 .) ]
  ! PLUSEQUAL       [ reduce using rule 48 (add -> arith1 ADD arith1 .) ]
  ! SUBEQUAL        [ reduce using rule 48 (add -> arith1 ADD arith1 .) ]
  ! DIVEQUAL        [ reduce using rule 48 (add -> arith1 ADD arith1 .) ]
  ! TIMESEQUAL      [ reduce using rule 48 (add -> arith1 ADD arith1 .) ]
  ! MODEQUAL        [ reduce using rule 48 (add -> arith1 ADD arith1 .) ]
  ! ANDEQUAL        [ reduce using rule 48 (add -> arith1 ADD arith1 .) ]
  ! OREQUAL         [ reduce using rule 48 (add -> arith1 ADD arith1 .) ]
  ! LBRACKET        [ reduce using rule 48 (add -> arith1 ADD arith1 .) ]
  ! PERIOD          [ reduce using rule 48 (add -> arith1 ADD arith1 .) ]
  ! ADD             [ shift and go to state 204 ]
  ! SUB             [ shift and go to state 195 ]
  ! LESSTHAN        [ shift and go to state 202 ]
  ! LESSTHANOREQUAL [ shift and go to state 201 ]
  ! GREATERTHAN     [ shift and go to state 194 ]
  ! GREATERTHANOREQUAL [ shift and go to state 198 ]
  ! EQUALTO         [ shift and go to state 206 ]
  ! NOTEQUAL        [ shift and go to state 203 ]
  ! LOGICALOR       [ shift and go to state 196 ]
  ! LOGICALAND      [ shift and go to state 200 ]


state 259

    (52) mod -> arith1 MODOP arith1 .
    (48) add -> arith1 . ADD arith1
    (49) sub -> arith1 . SUB arith1
    (50) mul -> arith1 . MUL arith1
    (51) div -> arith1 . DIV arith1
    (52) mod -> arith1 . MODOP arith1
    (63) lt -> arith1 . LESSTHAN arith1
    (64) leq -> arith1 . LESSTHANOREQUAL arith1
    (65) gt -> arith1 . GREATERTHAN arith1
    (66) geq -> arith1 . GREATERTHANOREQUAL arith1
    (67) eq -> arith1 . EQUALTO arith1
    (68) neq -> arith1 . NOTEQUAL arith1
    (69) or -> arith1 . LOGICALOR arith1
    (70) and -> arith1 . LOGICALAND arith1
    (20) exp -> arith1 .

  ! reduce/reduce conflict for PERIOD resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for EQU resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for PLUSEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for SUBEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for DIVEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for TIMESEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for MODEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for ANDEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for OREQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 20 (exp -> arith1 .)
    ADD             reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    SUB             reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    MUL             reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    DIV             reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    MODOP           reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    LESSTHAN        reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    LESSTHANOREQUAL reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    GREATERTHAN     reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    GREATERTHANOREQUAL reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    EQUALTO         reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    NOTEQUAL        reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    LOGICALOR       reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    LOGICALAND      reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    SEMICOLON       reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    RSQUIGBRACKET   reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    RPAREN          reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    LPAREN          reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    LOOP            reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    WHILE           reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    BOX             reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    IF              reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    MATCH           reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    ID              reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    NOT             reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    AND             reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    LITDEC          reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    LITCHAR         reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    LITBOOL         reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    LITSTRING       reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    COMMA           reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    RBRACKET        reduce using rule 52 (mod -> arith1 MODOP arith1 .)
    PERIOD          reduce using rule 20 (exp -> arith1 .)
    EQU             reduce using rule 20 (exp -> arith1 .)
    PLUSEQUAL       reduce using rule 20 (exp -> arith1 .)
    SUBEQUAL        reduce using rule 20 (exp -> arith1 .)
    DIVEQUAL        reduce using rule 20 (exp -> arith1 .)
    TIMESEQUAL      reduce using rule 20 (exp -> arith1 .)
    MODEQUAL        reduce using rule 20 (exp -> arith1 .)
    ANDEQUAL        reduce using rule 20 (exp -> arith1 .)
    OREQUAL         reduce using rule 20 (exp -> arith1 .)
    LBRACKET        reduce using rule 20 (exp -> arith1 .)

  ! EQU             [ reduce using rule 52 (mod -> arith1 MODOP arith1 .) ]
  ! PLUSEQUAL       [ reduce using rule 52 (mod -> arith1 MODOP arith1 .) ]
  ! SUBEQUAL        [ reduce using rule 52 (mod -> arith1 MODOP arith1 .) ]
  ! DIVEQUAL        [ reduce using rule 52 (mod -> arith1 MODOP arith1 .) ]
  ! TIMESEQUAL      [ reduce using rule 52 (mod -> arith1 MODOP arith1 .) ]
  ! MODEQUAL        [ reduce using rule 52 (mod -> arith1 MODOP arith1 .) ]
  ! ANDEQUAL        [ reduce using rule 52 (mod -> arith1 MODOP arith1 .) ]
  ! OREQUAL         [ reduce using rule 52 (mod -> arith1 MODOP arith1 .) ]
  ! LBRACKET        [ reduce using rule 52 (mod -> arith1 MODOP arith1 .) ]
  ! PERIOD          [ reduce using rule 52 (mod -> arith1 MODOP arith1 .) ]
  ! ADD             [ shift and go to state 204 ]
  ! SUB             [ shift and go to state 195 ]
  ! MUL             [ shift and go to state 199 ]
  ! DIV             [ shift and go to state 197 ]
  ! MODOP           [ shift and go to state 205 ]
  ! LESSTHAN        [ shift and go to state 202 ]
  ! LESSTHANOREQUAL [ shift and go to state 201 ]
  ! GREATERTHAN     [ shift and go to state 194 ]
  ! GREATERTHANOREQUAL [ shift and go to state 198 ]
  ! EQUALTO         [ shift and go to state 206 ]
  ! NOTEQUAL        [ shift and go to state 203 ]
  ! LOGICALOR       [ shift and go to state 196 ]
  ! LOGICALAND      [ shift and go to state 200 ]


state 260

    (67) eq -> arith1 EQUALTO arith1 .
    (48) add -> arith1 . ADD arith1
    (49) sub -> arith1 . SUB arith1
    (50) mul -> arith1 . MUL arith1
    (51) div -> arith1 . DIV arith1
    (52) mod -> arith1 . MODOP arith1
    (63) lt -> arith1 . LESSTHAN arith1
    (64) leq -> arith1 . LESSTHANOREQUAL arith1
    (65) gt -> arith1 . GREATERTHAN arith1
    (66) geq -> arith1 . GREATERTHANOREQUAL arith1
    (67) eq -> arith1 . EQUALTO arith1
    (68) neq -> arith1 . NOTEQUAL arith1
    (69) or -> arith1 . LOGICALOR arith1
    (70) and -> arith1 . LOGICALAND arith1
    (20) exp -> arith1 .

  ! reduce/reduce conflict for PERIOD resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for EQU resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for PLUSEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for SUBEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for DIVEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for TIMESEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for MODEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for ANDEQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for OREQUAL resolved using rule 20 (exp -> arith1 .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 20 (exp -> arith1 .)
    LESSTHAN        reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    LESSTHANOREQUAL reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    GREATERTHAN     reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    GREATERTHANOREQUAL reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    EQUALTO         reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    NOTEQUAL        reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    LOGICALOR       reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    LOGICALAND      reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    LPAREN          reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    LOOP            reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    WHILE           reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    BOX             reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    IF              reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    MATCH           reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    ID              reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    NOT             reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    AND             reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    LITDEC          reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    LITCHAR         reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    LITBOOL         reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    LITSTRING       reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    SEMICOLON       reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    RSQUIGBRACKET   reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    RPAREN          reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    COMMA           reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    RBRACKET        reduce using rule 67 (eq -> arith1 EQUALTO arith1 .)
    ADD             shift and go to state 204
    SUB             shift and go to state 195
    MUL             shift and go to state 199
    DIV             shift and go to state 197
    MODOP           shift and go to state 205
    PERIOD          reduce using rule 20 (exp -> arith1 .)
    EQU             reduce using rule 20 (exp -> arith1 .)
    PLUSEQUAL       reduce using rule 20 (exp -> arith1 .)
    SUBEQUAL        reduce using rule 20 (exp -> arith1 .)
    DIVEQUAL        reduce using rule 20 (exp -> arith1 .)
    TIMESEQUAL      reduce using rule 20 (exp -> arith1 .)
    MODEQUAL        reduce using rule 20 (exp -> arith1 .)
    ANDEQUAL        reduce using rule 20 (exp -> arith1 .)
    OREQUAL         reduce using rule 20 (exp -> arith1 .)
    LBRACKET        reduce using rule 20 (exp -> arith1 .)

  ! ADD             [ reduce using rule 67 (eq -> arith1 EQUALTO arith1 .) ]
  ! SUB             [ reduce using rule 67 (eq -> arith1 EQUALTO arith1 .) ]
  ! MUL             [ reduce using rule 67 (eq -> arith1 EQUALTO arith1 .) ]
  ! DIV             [ reduce using rule 67 (eq -> arith1 EQUALTO arith1 .) ]
  ! MODOP           [ reduce using rule 67 (eq -> arith1 EQUALTO arith1 .) ]
  ! EQU             [ reduce using rule 67 (eq -> arith1 EQUALTO arith1 .) ]
  ! PLUSEQUAL       [ reduce using rule 67 (eq -> arith1 EQUALTO arith1 .) ]
  ! SUBEQUAL        [ reduce using rule 67 (eq -> arith1 EQUALTO arith1 .) ]
  ! DIVEQUAL        [ reduce using rule 67 (eq -> arith1 EQUALTO arith1 .) ]
  ! TIMESEQUAL      [ reduce using rule 67 (eq -> arith1 EQUALTO arith1 .) ]
  ! MODEQUAL        [ reduce using rule 67 (eq -> arith1 EQUALTO arith1 .) ]
  ! ANDEQUAL        [ reduce using rule 67 (eq -> arith1 EQUALTO arith1 .) ]
  ! OREQUAL         [ reduce using rule 67 (eq -> arith1 EQUALTO arith1 .) ]
  ! LBRACKET        [ reduce using rule 67 (eq -> arith1 EQUALTO arith1 .) ]
  ! PERIOD          [ reduce using rule 67 (eq -> arith1 EQUALTO arith1 .) ]
  ! LESSTHAN        [ shift and go to state 202 ]
  ! LESSTHANOREQUAL [ shift and go to state 201 ]
  ! GREATERTHAN     [ shift and go to state 194 ]
  ! GREATERTHANOREQUAL [ shift and go to state 198 ]
  ! EQUALTO         [ shift and go to state 206 ]
  ! NOTEQUAL        [ shift and go to state 203 ]
  ! LOGICALOR       [ shift and go to state 196 ]
  ! LOGICALAND      [ shift and go to state 200 ]


state 261

    (98) if -> if ELSE block .

    ELSE            reduce using rule 98 (if -> if ELSE block .)
    RPAREN          reduce using rule 98 (if -> if ELSE block .)
    EQU             reduce using rule 98 (if -> if ELSE block .)
    PLUSEQUAL       reduce using rule 98 (if -> if ELSE block .)
    SUBEQUAL        reduce using rule 98 (if -> if ELSE block .)
    DIVEQUAL        reduce using rule 98 (if -> if ELSE block .)
    TIMESEQUAL      reduce using rule 98 (if -> if ELSE block .)
    MODEQUAL        reduce using rule 98 (if -> if ELSE block .)
    ANDEQUAL        reduce using rule 98 (if -> if ELSE block .)
    OREQUAL         reduce using rule 98 (if -> if ELSE block .)
    LBRACKET        reduce using rule 98 (if -> if ELSE block .)
    PERIOD          reduce using rule 98 (if -> if ELSE block .)
    SEMICOLON       reduce using rule 98 (if -> if ELSE block .)
    RSQUIGBRACKET   reduce using rule 98 (if -> if ELSE block .)
    LPAREN          reduce using rule 98 (if -> if ELSE block .)
    LOOP            reduce using rule 98 (if -> if ELSE block .)
    WHILE           reduce using rule 98 (if -> if ELSE block .)
    BOX             reduce using rule 98 (if -> if ELSE block .)
    IF              reduce using rule 98 (if -> if ELSE block .)
    MATCH           reduce using rule 98 (if -> if ELSE block .)
    ID              reduce using rule 98 (if -> if ELSE block .)
    SUB             reduce using rule 98 (if -> if ELSE block .)
    NOT             reduce using rule 98 (if -> if ELSE block .)
    AND             reduce using rule 98 (if -> if ELSE block .)
    MUL             reduce using rule 98 (if -> if ELSE block .)
    LITDEC          reduce using rule 98 (if -> if ELSE block .)
    LITCHAR         reduce using rule 98 (if -> if ELSE block .)
    LITBOOL         reduce using rule 98 (if -> if ELSE block .)
    LITSTRING       reduce using rule 98 (if -> if ELSE block .)
    COMMA           reduce using rule 98 (if -> if ELSE block .)
    RBRACKET        reduce using rule 98 (if -> if ELSE block .)


state 262

    (89) assign -> exp OREQUAL exp .
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

  ! shift/reduce conflict for EQU resolved as shift
  ! shift/reduce conflict for PLUSEQUAL resolved as shift
  ! shift/reduce conflict for SUBEQUAL resolved as shift
  ! shift/reduce conflict for DIVEQUAL resolved as shift
  ! shift/reduce conflict for TIMESEQUAL resolved as shift
  ! shift/reduce conflict for MODEQUAL resolved as shift
  ! shift/reduce conflict for ANDEQUAL resolved as shift
  ! shift/reduce conflict for OREQUAL resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PERIOD resolved as shift
    SEMICOLON       reduce using rule 89 (assign -> exp OREQUAL exp .)
    RSQUIGBRACKET   reduce using rule 89 (assign -> exp OREQUAL exp .)
    RPAREN          reduce using rule 89 (assign -> exp OREQUAL exp .)
    LPAREN          reduce using rule 89 (assign -> exp OREQUAL exp .)
    LOOP            reduce using rule 89 (assign -> exp OREQUAL exp .)
    WHILE           reduce using rule 89 (assign -> exp OREQUAL exp .)
    BOX             reduce using rule 89 (assign -> exp OREQUAL exp .)
    IF              reduce using rule 89 (assign -> exp OREQUAL exp .)
    MATCH           reduce using rule 89 (assign -> exp OREQUAL exp .)
    ID              reduce using rule 89 (assign -> exp OREQUAL exp .)
    SUB             reduce using rule 89 (assign -> exp OREQUAL exp .)
    NOT             reduce using rule 89 (assign -> exp OREQUAL exp .)
    AND             reduce using rule 89 (assign -> exp OREQUAL exp .)
    MUL             reduce using rule 89 (assign -> exp OREQUAL exp .)
    LITDEC          reduce using rule 89 (assign -> exp OREQUAL exp .)
    LITCHAR         reduce using rule 89 (assign -> exp OREQUAL exp .)
    LITBOOL         reduce using rule 89 (assign -> exp OREQUAL exp .)
    LITSTRING       reduce using rule 89 (assign -> exp OREQUAL exp .)
    COMMA           reduce using rule 89 (assign -> exp OREQUAL exp .)
    RBRACKET        reduce using rule 89 (assign -> exp OREQUAL exp .)
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216

  ! PERIOD          [ reduce using rule 89 (assign -> exp OREQUAL exp .) ]
  ! EQU             [ reduce using rule 89 (assign -> exp OREQUAL exp .) ]
  ! PLUSEQUAL       [ reduce using rule 89 (assign -> exp OREQUAL exp .) ]
  ! SUBEQUAL        [ reduce using rule 89 (assign -> exp OREQUAL exp .) ]
  ! DIVEQUAL        [ reduce using rule 89 (assign -> exp OREQUAL exp .) ]
  ! TIMESEQUAL      [ reduce using rule 89 (assign -> exp OREQUAL exp .) ]
  ! MODEQUAL        [ reduce using rule 89 (assign -> exp OREQUAL exp .) ]
  ! ANDEQUAL        [ reduce using rule 89 (assign -> exp OREQUAL exp .) ]
  ! OREQUAL         [ reduce using rule 89 (assign -> exp OREQUAL exp .) ]
  ! LBRACKET        [ reduce using rule 89 (assign -> exp OREQUAL exp .) ]


state 263

    (88) assign -> exp ANDEQUAL exp .
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

  ! shift/reduce conflict for EQU resolved as shift
  ! shift/reduce conflict for PLUSEQUAL resolved as shift
  ! shift/reduce conflict for SUBEQUAL resolved as shift
  ! shift/reduce conflict for DIVEQUAL resolved as shift
  ! shift/reduce conflict for TIMESEQUAL resolved as shift
  ! shift/reduce conflict for MODEQUAL resolved as shift
  ! shift/reduce conflict for ANDEQUAL resolved as shift
  ! shift/reduce conflict for OREQUAL resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PERIOD resolved as shift
    SEMICOLON       reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    RSQUIGBRACKET   reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    RPAREN          reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    LPAREN          reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    LOOP            reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    WHILE           reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    BOX             reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    IF              reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    MATCH           reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    ID              reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    SUB             reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    NOT             reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    AND             reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    MUL             reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    LITDEC          reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    LITCHAR         reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    LITBOOL         reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    LITSTRING       reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    COMMA           reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    RBRACKET        reduce using rule 88 (assign -> exp ANDEQUAL exp .)
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216

  ! PERIOD          [ reduce using rule 88 (assign -> exp ANDEQUAL exp .) ]
  ! EQU             [ reduce using rule 88 (assign -> exp ANDEQUAL exp .) ]
  ! PLUSEQUAL       [ reduce using rule 88 (assign -> exp ANDEQUAL exp .) ]
  ! SUBEQUAL        [ reduce using rule 88 (assign -> exp ANDEQUAL exp .) ]
  ! DIVEQUAL        [ reduce using rule 88 (assign -> exp ANDEQUAL exp .) ]
  ! TIMESEQUAL      [ reduce using rule 88 (assign -> exp ANDEQUAL exp .) ]
  ! MODEQUAL        [ reduce using rule 88 (assign -> exp ANDEQUAL exp .) ]
  ! ANDEQUAL        [ reduce using rule 88 (assign -> exp ANDEQUAL exp .) ]
  ! OREQUAL         [ reduce using rule 88 (assign -> exp ANDEQUAL exp .) ]
  ! LBRACKET        [ reduce using rule 88 (assign -> exp ANDEQUAL exp .) ]


state 264

    (85) assign -> exp DIVEQUAL exp .
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

  ! shift/reduce conflict for EQU resolved as shift
  ! shift/reduce conflict for PLUSEQUAL resolved as shift
  ! shift/reduce conflict for SUBEQUAL resolved as shift
  ! shift/reduce conflict for DIVEQUAL resolved as shift
  ! shift/reduce conflict for TIMESEQUAL resolved as shift
  ! shift/reduce conflict for MODEQUAL resolved as shift
  ! shift/reduce conflict for ANDEQUAL resolved as shift
  ! shift/reduce conflict for OREQUAL resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PERIOD resolved as shift
    SEMICOLON       reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    RSQUIGBRACKET   reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    RPAREN          reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    LPAREN          reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    LOOP            reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    WHILE           reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    BOX             reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    IF              reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    MATCH           reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    ID              reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    SUB             reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    NOT             reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    AND             reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    MUL             reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    LITDEC          reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    LITCHAR         reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    LITBOOL         reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    LITSTRING       reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    COMMA           reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    RBRACKET        reduce using rule 85 (assign -> exp DIVEQUAL exp .)
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216

  ! PERIOD          [ reduce using rule 85 (assign -> exp DIVEQUAL exp .) ]
  ! EQU             [ reduce using rule 85 (assign -> exp DIVEQUAL exp .) ]
  ! PLUSEQUAL       [ reduce using rule 85 (assign -> exp DIVEQUAL exp .) ]
  ! SUBEQUAL        [ reduce using rule 85 (assign -> exp DIVEQUAL exp .) ]
  ! DIVEQUAL        [ reduce using rule 85 (assign -> exp DIVEQUAL exp .) ]
  ! TIMESEQUAL      [ reduce using rule 85 (assign -> exp DIVEQUAL exp .) ]
  ! MODEQUAL        [ reduce using rule 85 (assign -> exp DIVEQUAL exp .) ]
  ! ANDEQUAL        [ reduce using rule 85 (assign -> exp DIVEQUAL exp .) ]
  ! OREQUAL         [ reduce using rule 85 (assign -> exp DIVEQUAL exp .) ]
  ! LBRACKET        [ reduce using rule 85 (assign -> exp DIVEQUAL exp .) ]


state 265

    (87) assign -> exp MODEQUAL exp .
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

  ! shift/reduce conflict for EQU resolved as shift
  ! shift/reduce conflict for PLUSEQUAL resolved as shift
  ! shift/reduce conflict for SUBEQUAL resolved as shift
  ! shift/reduce conflict for DIVEQUAL resolved as shift
  ! shift/reduce conflict for TIMESEQUAL resolved as shift
  ! shift/reduce conflict for MODEQUAL resolved as shift
  ! shift/reduce conflict for ANDEQUAL resolved as shift
  ! shift/reduce conflict for OREQUAL resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PERIOD resolved as shift
    SEMICOLON       reduce using rule 87 (assign -> exp MODEQUAL exp .)
    RSQUIGBRACKET   reduce using rule 87 (assign -> exp MODEQUAL exp .)
    RPAREN          reduce using rule 87 (assign -> exp MODEQUAL exp .)
    LPAREN          reduce using rule 87 (assign -> exp MODEQUAL exp .)
    LOOP            reduce using rule 87 (assign -> exp MODEQUAL exp .)
    WHILE           reduce using rule 87 (assign -> exp MODEQUAL exp .)
    BOX             reduce using rule 87 (assign -> exp MODEQUAL exp .)
    IF              reduce using rule 87 (assign -> exp MODEQUAL exp .)
    MATCH           reduce using rule 87 (assign -> exp MODEQUAL exp .)
    ID              reduce using rule 87 (assign -> exp MODEQUAL exp .)
    SUB             reduce using rule 87 (assign -> exp MODEQUAL exp .)
    NOT             reduce using rule 87 (assign -> exp MODEQUAL exp .)
    AND             reduce using rule 87 (assign -> exp MODEQUAL exp .)
    MUL             reduce using rule 87 (assign -> exp MODEQUAL exp .)
    LITDEC          reduce using rule 87 (assign -> exp MODEQUAL exp .)
    LITCHAR         reduce using rule 87 (assign -> exp MODEQUAL exp .)
    LITBOOL         reduce using rule 87 (assign -> exp MODEQUAL exp .)
    LITSTRING       reduce using rule 87 (assign -> exp MODEQUAL exp .)
    COMMA           reduce using rule 87 (assign -> exp MODEQUAL exp .)
    RBRACKET        reduce using rule 87 (assign -> exp MODEQUAL exp .)
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216

  ! PERIOD          [ reduce using rule 87 (assign -> exp MODEQUAL exp .) ]
  ! EQU             [ reduce using rule 87 (assign -> exp MODEQUAL exp .) ]
  ! PLUSEQUAL       [ reduce using rule 87 (assign -> exp MODEQUAL exp .) ]
  ! SUBEQUAL        [ reduce using rule 87 (assign -> exp MODEQUAL exp .) ]
  ! DIVEQUAL        [ reduce using rule 87 (assign -> exp MODEQUAL exp .) ]
  ! TIMESEQUAL      [ reduce using rule 87 (assign -> exp MODEQUAL exp .) ]
  ! MODEQUAL        [ reduce using rule 87 (assign -> exp MODEQUAL exp .) ]
  ! ANDEQUAL        [ reduce using rule 87 (assign -> exp MODEQUAL exp .) ]
  ! OREQUAL         [ reduce using rule 87 (assign -> exp MODEQUAL exp .) ]
  ! LBRACKET        [ reduce using rule 87 (assign -> exp MODEQUAL exp .) ]


state 266

    (86) assign -> exp TIMESEQUAL exp .
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

  ! shift/reduce conflict for EQU resolved as shift
  ! shift/reduce conflict for PLUSEQUAL resolved as shift
  ! shift/reduce conflict for SUBEQUAL resolved as shift
  ! shift/reduce conflict for DIVEQUAL resolved as shift
  ! shift/reduce conflict for TIMESEQUAL resolved as shift
  ! shift/reduce conflict for MODEQUAL resolved as shift
  ! shift/reduce conflict for ANDEQUAL resolved as shift
  ! shift/reduce conflict for OREQUAL resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PERIOD resolved as shift
    SEMICOLON       reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    RSQUIGBRACKET   reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    RPAREN          reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    LPAREN          reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    LOOP            reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    WHILE           reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    BOX             reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    IF              reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    MATCH           reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    ID              reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    SUB             reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    NOT             reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    AND             reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    MUL             reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    LITDEC          reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    LITCHAR         reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    LITBOOL         reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    LITSTRING       reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    COMMA           reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    RBRACKET        reduce using rule 86 (assign -> exp TIMESEQUAL exp .)
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216

  ! PERIOD          [ reduce using rule 86 (assign -> exp TIMESEQUAL exp .) ]
  ! EQU             [ reduce using rule 86 (assign -> exp TIMESEQUAL exp .) ]
  ! PLUSEQUAL       [ reduce using rule 86 (assign -> exp TIMESEQUAL exp .) ]
  ! SUBEQUAL        [ reduce using rule 86 (assign -> exp TIMESEQUAL exp .) ]
  ! DIVEQUAL        [ reduce using rule 86 (assign -> exp TIMESEQUAL exp .) ]
  ! TIMESEQUAL      [ reduce using rule 86 (assign -> exp TIMESEQUAL exp .) ]
  ! MODEQUAL        [ reduce using rule 86 (assign -> exp TIMESEQUAL exp .) ]
  ! ANDEQUAL        [ reduce using rule 86 (assign -> exp TIMESEQUAL exp .) ]
  ! OREQUAL         [ reduce using rule 86 (assign -> exp TIMESEQUAL exp .) ]
  ! LBRACKET        [ reduce using rule 86 (assign -> exp TIMESEQUAL exp .) ]


state 267

    (83) assign -> exp PLUSEQUAL exp .
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

  ! shift/reduce conflict for EQU resolved as shift
  ! shift/reduce conflict for PLUSEQUAL resolved as shift
  ! shift/reduce conflict for SUBEQUAL resolved as shift
  ! shift/reduce conflict for DIVEQUAL resolved as shift
  ! shift/reduce conflict for TIMESEQUAL resolved as shift
  ! shift/reduce conflict for MODEQUAL resolved as shift
  ! shift/reduce conflict for ANDEQUAL resolved as shift
  ! shift/reduce conflict for OREQUAL resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PERIOD resolved as shift
    SEMICOLON       reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    RSQUIGBRACKET   reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    RPAREN          reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    LPAREN          reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    LOOP            reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    WHILE           reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    BOX             reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    IF              reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    MATCH           reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    ID              reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    SUB             reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    NOT             reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    AND             reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    MUL             reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    LITDEC          reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    LITCHAR         reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    LITBOOL         reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    LITSTRING       reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    COMMA           reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    RBRACKET        reduce using rule 83 (assign -> exp PLUSEQUAL exp .)
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216

  ! PERIOD          [ reduce using rule 83 (assign -> exp PLUSEQUAL exp .) ]
  ! EQU             [ reduce using rule 83 (assign -> exp PLUSEQUAL exp .) ]
  ! PLUSEQUAL       [ reduce using rule 83 (assign -> exp PLUSEQUAL exp .) ]
  ! SUBEQUAL        [ reduce using rule 83 (assign -> exp PLUSEQUAL exp .) ]
  ! DIVEQUAL        [ reduce using rule 83 (assign -> exp PLUSEQUAL exp .) ]
  ! TIMESEQUAL      [ reduce using rule 83 (assign -> exp PLUSEQUAL exp .) ]
  ! MODEQUAL        [ reduce using rule 83 (assign -> exp PLUSEQUAL exp .) ]
  ! ANDEQUAL        [ reduce using rule 83 (assign -> exp PLUSEQUAL exp .) ]
  ! OREQUAL         [ reduce using rule 83 (assign -> exp PLUSEQUAL exp .) ]
  ! LBRACKET        [ reduce using rule 83 (assign -> exp PLUSEQUAL exp .) ]


state 268

    (82) assign -> exp EQU exp .
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

  ! shift/reduce conflict for EQU resolved as shift
  ! shift/reduce conflict for PLUSEQUAL resolved as shift
  ! shift/reduce conflict for SUBEQUAL resolved as shift
  ! shift/reduce conflict for DIVEQUAL resolved as shift
  ! shift/reduce conflict for TIMESEQUAL resolved as shift
  ! shift/reduce conflict for MODEQUAL resolved as shift
  ! shift/reduce conflict for ANDEQUAL resolved as shift
  ! shift/reduce conflict for OREQUAL resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PERIOD resolved as shift
    SEMICOLON       reduce using rule 82 (assign -> exp EQU exp .)
    RSQUIGBRACKET   reduce using rule 82 (assign -> exp EQU exp .)
    RPAREN          reduce using rule 82 (assign -> exp EQU exp .)
    LPAREN          reduce using rule 82 (assign -> exp EQU exp .)
    LOOP            reduce using rule 82 (assign -> exp EQU exp .)
    WHILE           reduce using rule 82 (assign -> exp EQU exp .)
    BOX             reduce using rule 82 (assign -> exp EQU exp .)
    IF              reduce using rule 82 (assign -> exp EQU exp .)
    MATCH           reduce using rule 82 (assign -> exp EQU exp .)
    ID              reduce using rule 82 (assign -> exp EQU exp .)
    SUB             reduce using rule 82 (assign -> exp EQU exp .)
    NOT             reduce using rule 82 (assign -> exp EQU exp .)
    AND             reduce using rule 82 (assign -> exp EQU exp .)
    MUL             reduce using rule 82 (assign -> exp EQU exp .)
    LITDEC          reduce using rule 82 (assign -> exp EQU exp .)
    LITCHAR         reduce using rule 82 (assign -> exp EQU exp .)
    LITBOOL         reduce using rule 82 (assign -> exp EQU exp .)
    LITSTRING       reduce using rule 82 (assign -> exp EQU exp .)
    COMMA           reduce using rule 82 (assign -> exp EQU exp .)
    RBRACKET        reduce using rule 82 (assign -> exp EQU exp .)
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216

  ! PERIOD          [ reduce using rule 82 (assign -> exp EQU exp .) ]
  ! EQU             [ reduce using rule 82 (assign -> exp EQU exp .) ]
  ! PLUSEQUAL       [ reduce using rule 82 (assign -> exp EQU exp .) ]
  ! SUBEQUAL        [ reduce using rule 82 (assign -> exp EQU exp .) ]
  ! DIVEQUAL        [ reduce using rule 82 (assign -> exp EQU exp .) ]
  ! TIMESEQUAL      [ reduce using rule 82 (assign -> exp EQU exp .) ]
  ! MODEQUAL        [ reduce using rule 82 (assign -> exp EQU exp .) ]
  ! ANDEQUAL        [ reduce using rule 82 (assign -> exp EQU exp .) ]
  ! OREQUAL         [ reduce using rule 82 (assign -> exp EQU exp .) ]
  ! LBRACKET        [ reduce using rule 82 (assign -> exp EQU exp .) ]


state 269

    (94) field_lookup -> exp PERIOD id .

    ADD             reduce using rule 94 (field_lookup -> exp PERIOD id .)
    SUB             reduce using rule 94 (field_lookup -> exp PERIOD id .)
    MUL             reduce using rule 94 (field_lookup -> exp PERIOD id .)
    DIV             reduce using rule 94 (field_lookup -> exp PERIOD id .)
    MODOP           reduce using rule 94 (field_lookup -> exp PERIOD id .)
    LESSTHAN        reduce using rule 94 (field_lookup -> exp PERIOD id .)
    LESSTHANOREQUAL reduce using rule 94 (field_lookup -> exp PERIOD id .)
    GREATERTHAN     reduce using rule 94 (field_lookup -> exp PERIOD id .)
    GREATERTHANOREQUAL reduce using rule 94 (field_lookup -> exp PERIOD id .)
    EQUALTO         reduce using rule 94 (field_lookup -> exp PERIOD id .)
    NOTEQUAL        reduce using rule 94 (field_lookup -> exp PERIOD id .)
    LOGICALOR       reduce using rule 94 (field_lookup -> exp PERIOD id .)
    LOGICALAND      reduce using rule 94 (field_lookup -> exp PERIOD id .)
    RPAREN          reduce using rule 94 (field_lookup -> exp PERIOD id .)
    EQU             reduce using rule 94 (field_lookup -> exp PERIOD id .)
    PLUSEQUAL       reduce using rule 94 (field_lookup -> exp PERIOD id .)
    SUBEQUAL        reduce using rule 94 (field_lookup -> exp PERIOD id .)
    DIVEQUAL        reduce using rule 94 (field_lookup -> exp PERIOD id .)
    TIMESEQUAL      reduce using rule 94 (field_lookup -> exp PERIOD id .)
    MODEQUAL        reduce using rule 94 (field_lookup -> exp PERIOD id .)
    ANDEQUAL        reduce using rule 94 (field_lookup -> exp PERIOD id .)
    OREQUAL         reduce using rule 94 (field_lookup -> exp PERIOD id .)
    LBRACKET        reduce using rule 94 (field_lookup -> exp PERIOD id .)
    PERIOD          reduce using rule 94 (field_lookup -> exp PERIOD id .)
    SEMICOLON       reduce using rule 94 (field_lookup -> exp PERIOD id .)
    RSQUIGBRACKET   reduce using rule 94 (field_lookup -> exp PERIOD id .)
    LPAREN          reduce using rule 94 (field_lookup -> exp PERIOD id .)
    LOOP            reduce using rule 94 (field_lookup -> exp PERIOD id .)
    WHILE           reduce using rule 94 (field_lookup -> exp PERIOD id .)
    BOX             reduce using rule 94 (field_lookup -> exp PERIOD id .)
    IF              reduce using rule 94 (field_lookup -> exp PERIOD id .)
    MATCH           reduce using rule 94 (field_lookup -> exp PERIOD id .)
    ID              reduce using rule 94 (field_lookup -> exp PERIOD id .)
    NOT             reduce using rule 94 (field_lookup -> exp PERIOD id .)
    AND             reduce using rule 94 (field_lookup -> exp PERIOD id .)
    LITDEC          reduce using rule 94 (field_lookup -> exp PERIOD id .)
    LITCHAR         reduce using rule 94 (field_lookup -> exp PERIOD id .)
    LITBOOL         reduce using rule 94 (field_lookup -> exp PERIOD id .)
    LITSTRING       reduce using rule 94 (field_lookup -> exp PERIOD id .)
    COMMA           reduce using rule 94 (field_lookup -> exp PERIOD id .)
    RBRACKET        reduce using rule 94 (field_lookup -> exp PERIOD id .)


state 270

    (125) arr_index -> exp LBRACKET exp . RBRACKET
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

    RBRACKET        shift and go to state 295
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216


state 271

    (84) assign -> exp SUBEQUAL exp .
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

  ! shift/reduce conflict for EQU resolved as shift
  ! shift/reduce conflict for PLUSEQUAL resolved as shift
  ! shift/reduce conflict for SUBEQUAL resolved as shift
  ! shift/reduce conflict for DIVEQUAL resolved as shift
  ! shift/reduce conflict for TIMESEQUAL resolved as shift
  ! shift/reduce conflict for MODEQUAL resolved as shift
  ! shift/reduce conflict for ANDEQUAL resolved as shift
  ! shift/reduce conflict for OREQUAL resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PERIOD resolved as shift
    SEMICOLON       reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    RSQUIGBRACKET   reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    RPAREN          reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    LPAREN          reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    LOOP            reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    WHILE           reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    BOX             reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    IF              reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    MATCH           reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    ID              reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    SUB             reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    NOT             reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    AND             reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    MUL             reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    LITDEC          reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    LITCHAR         reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    LITBOOL         reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    LITSTRING       reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    COMMA           reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    RBRACKET        reduce using rule 84 (assign -> exp SUBEQUAL exp .)
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216

  ! PERIOD          [ reduce using rule 84 (assign -> exp SUBEQUAL exp .) ]
  ! EQU             [ reduce using rule 84 (assign -> exp SUBEQUAL exp .) ]
  ! PLUSEQUAL       [ reduce using rule 84 (assign -> exp SUBEQUAL exp .) ]
  ! SUBEQUAL        [ reduce using rule 84 (assign -> exp SUBEQUAL exp .) ]
  ! DIVEQUAL        [ reduce using rule 84 (assign -> exp SUBEQUAL exp .) ]
  ! TIMESEQUAL      [ reduce using rule 84 (assign -> exp SUBEQUAL exp .) ]
  ! MODEQUAL        [ reduce using rule 84 (assign -> exp SUBEQUAL exp .) ]
  ! ANDEQUAL        [ reduce using rule 84 (assign -> exp SUBEQUAL exp .) ]
  ! OREQUAL         [ reduce using rule 84 (assign -> exp SUBEQUAL exp .) ]
  ! LBRACKET        [ reduce using rule 84 (assign -> exp SUBEQUAL exp .) ]


state 272

    (79) addr_of_mut -> AND MUT arith4 .

    ADD             reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    SUB             reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    MUL             reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    DIV             reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    MODOP           reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    LESSTHAN        reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    LESSTHANOREQUAL reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    GREATERTHAN     reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    GREATERTHANOREQUAL reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    EQUALTO         reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    NOTEQUAL        reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    LOGICALOR       reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    LOGICALAND      reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    EQU             reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    PLUSEQUAL       reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    SUBEQUAL        reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    DIVEQUAL        reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    TIMESEQUAL      reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    MODEQUAL        reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    ANDEQUAL        reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    OREQUAL         reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    LBRACKET        reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    PERIOD          reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    SEMICOLON       reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    RSQUIGBRACKET   reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    RPAREN          reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    LPAREN          reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    LOOP            reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    WHILE           reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    BOX             reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    IF              reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    MATCH           reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    ID              reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    NOT             reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    AND             reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    LITDEC          reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    LITCHAR         reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    LITBOOL         reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    LITSTRING       reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    COMMA           reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)
    RBRACKET        reduce using rule 79 (addr_of_mut -> AND MUT arith4 .)


state 273

    (80) addr_of_mut -> AND MUT neg .

    ADD             reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    SUB             reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    MUL             reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    DIV             reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    MODOP           reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    LESSTHAN        reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    LESSTHANOREQUAL reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    GREATERTHAN     reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    GREATERTHANOREQUAL reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    EQUALTO         reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    NOTEQUAL        reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    LOGICALOR       reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    LOGICALAND      reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    EQU             reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    PLUSEQUAL       reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    SUBEQUAL        reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    DIVEQUAL        reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    TIMESEQUAL      reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    MODEQUAL        reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    ANDEQUAL        reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    OREQUAL         reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    LBRACKET        reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    PERIOD          reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    SEMICOLON       reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    RSQUIGBRACKET   reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    RPAREN          reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    LPAREN          reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    LOOP            reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    WHILE           reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    BOX             reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    IF              reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    MATCH           reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    ID              reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    NOT             reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    AND             reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    LITDEC          reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    LITCHAR         reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    LITBOOL         reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    LITSTRING       reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    COMMA           reduce using rule 80 (addr_of_mut -> AND MUT neg .)
    RBRACKET        reduce using rule 80 (addr_of_mut -> AND MUT neg .)


state 274

    (124) arr -> LBRACKET exps RBRACKET .

    PERIOD          reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    EQU             reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    PLUSEQUAL       reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    SUBEQUAL        reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    DIVEQUAL        reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    TIMESEQUAL      reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    MODEQUAL        reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    ANDEQUAL        reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    OREQUAL         reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    LBRACKET        reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    SEMICOLON       reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    RSQUIGBRACKET   reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    RPAREN          reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    LPAREN          reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    LOOP            reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    WHILE           reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    BOX             reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    IF              reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    MATCH           reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    ID              reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    SUB             reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    NOT             reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    AND             reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    MUL             reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    LITDEC          reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    LITCHAR         reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    LITBOOL         reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    LITSTRING       reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    COMMA           reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)
    RBRACKET        reduce using rule 124 (arr -> LBRACKET exps RBRACKET .)


state 275

    (17) exps -> exp COMMA . exps
    (15) exps -> . exps
    (16) exps -> .
    (17) exps -> . exp COMMA exps
    (18) exps -> . exp
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! reduce/reduce conflict for RBRACKET resolved using rule 16 (exps -> .)
  ! reduce/reduce conflict for RPAREN resolved using rule 16 (exps -> .)
  ! shift/reduce conflict for LBRACKET resolved as shift
    RBRACKET        reduce using rule 16 (exps -> .)
    RPAREN          reduce using rule 16 (exps -> .)
    LPAREN          shift and go to state 121
    COMMA           reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]
  ! RBRACKET        [ reduce using rule 31 (exp -> .) ]
  ! RPAREN          [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 228
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    mul                            shift and go to state 143
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    loop                           shift and go to state 126
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168
    exps                           shift and go to state 296

state 276

    (95) while -> WHILE LPAREN exp . RPAREN block
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

    RPAREN          shift and go to state 297
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216


state 277

    (186) arg_struct -> id LSQUIGBRACKET body . RSQUIGBRACKET

    RSQUIGBRACKET   shift and go to state 298


state 278

    (187) body -> param_arg . body
    (188) body -> param_arg .
    (189) param_arg -> param_arg . COMMA
    (187) body -> . param_arg body
    (188) body -> . param_arg
    (189) param_arg -> . param_arg COMMA
    (190) param_arg -> . id COLON exp
    (143) id -> . ID

    RSQUIGBRACKET   reduce using rule 188 (body -> param_arg .)
    COMMA           shift and go to state 300
    ID              shift and go to state 10

    body                           shift and go to state 299
    param_arg                      shift and go to state 278
    id                             shift and go to state 279

state 279

    (190) param_arg -> id . COLON exp

    COLON           shift and go to state 301


state 280

    (136) fn_arg -> arg_struct .

    COMMA           reduce using rule 136 (fn_arg -> arg_struct .)
    ID              reduce using rule 136 (fn_arg -> arg_struct .)
    BOX             reduce using rule 136 (fn_arg -> arg_struct .)
    LITDEC          reduce using rule 136 (fn_arg -> arg_struct .)
    LITCHAR         reduce using rule 136 (fn_arg -> arg_struct .)
    LITBOOL         reduce using rule 136 (fn_arg -> arg_struct .)
    LITSTRING       reduce using rule 136 (fn_arg -> arg_struct .)
    RPAREN          reduce using rule 136 (fn_arg -> arg_struct .)


state 281

    (128) fn_call -> id LPAREN fn_args . RPAREN

    RPAREN          shift and go to state 302


state 282

    (134) fn_arg -> box_new .

    COMMA           reduce using rule 134 (fn_arg -> box_new .)
    ID              reduce using rule 134 (fn_arg -> box_new .)
    BOX             reduce using rule 134 (fn_arg -> box_new .)
    LITDEC          reduce using rule 134 (fn_arg -> box_new .)
    LITCHAR         reduce using rule 134 (fn_arg -> box_new .)
    LITBOOL         reduce using rule 134 (fn_arg -> box_new .)
    LITSTRING       reduce using rule 134 (fn_arg -> box_new .)
    RPAREN          reduce using rule 134 (fn_arg -> box_new .)


state 283

    (133) fn_arg -> id .
    (128) fn_call -> id . LPAREN fn_args RPAREN
    (186) arg_struct -> id . LSQUIGBRACKET body RSQUIGBRACKET
    (192) enum_con -> id . CLASSACCESS id

    COMMA           reduce using rule 133 (fn_arg -> id .)
    ID              reduce using rule 133 (fn_arg -> id .)
    BOX             reduce using rule 133 (fn_arg -> id .)
    LITDEC          reduce using rule 133 (fn_arg -> id .)
    LITCHAR         reduce using rule 133 (fn_arg -> id .)
    LITBOOL         reduce using rule 133 (fn_arg -> id .)
    LITSTRING       reduce using rule 133 (fn_arg -> id .)
    RPAREN          reduce using rule 133 (fn_arg -> id .)
    LPAREN          shift and go to state 231
    LSQUIGBRACKET   shift and go to state 230
    CLASSACCESS     shift and go to state 232


state 284

    (132) fn_arg -> lit .

    COMMA           reduce using rule 132 (fn_arg -> lit .)
    ID              reduce using rule 132 (fn_arg -> lit .)
    BOX             reduce using rule 132 (fn_arg -> lit .)
    LITDEC          reduce using rule 132 (fn_arg -> lit .)
    LITCHAR         reduce using rule 132 (fn_arg -> lit .)
    LITBOOL         reduce using rule 132 (fn_arg -> lit .)
    LITSTRING       reduce using rule 132 (fn_arg -> lit .)
    RPAREN          reduce using rule 132 (fn_arg -> lit .)


state 285

    (135) fn_arg -> fn_call .

    COMMA           reduce using rule 135 (fn_arg -> fn_call .)
    ID              reduce using rule 135 (fn_arg -> fn_call .)
    BOX             reduce using rule 135 (fn_arg -> fn_call .)
    LITDEC          reduce using rule 135 (fn_arg -> fn_call .)
    LITCHAR         reduce using rule 135 (fn_arg -> fn_call .)
    LITBOOL         reduce using rule 135 (fn_arg -> fn_call .)
    LITSTRING       reduce using rule 135 (fn_arg -> fn_call .)
    RPAREN          reduce using rule 135 (fn_arg -> fn_call .)


state 286

    (129) fn_args -> fn_arg . fn_args
    (131) fn_arg -> fn_arg . COMMA
    (129) fn_args -> . fn_arg fn_args
    (130) fn_args -> .
    (131) fn_arg -> . fn_arg COMMA
    (132) fn_arg -> . lit
    (133) fn_arg -> . id
    (134) fn_arg -> . box_new
    (135) fn_arg -> . fn_call
    (136) fn_arg -> . arg_struct
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (143) id -> . ID
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

    COMMA           shift and go to state 304
    RPAREN          reduce using rule 130 (fn_args -> .)
    ID              shift and go to state 10
    BOX             shift and go to state 117
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

    arg_struct                     shift and go to state 280
    fn_args                        shift and go to state 303
    box_new                        shift and go to state 282
    id                             shift and go to state 283
    p_lit                          shift and go to state 116
    fn_call                        shift and go to state 285
    lit                            shift and go to state 284
    enum_con                       shift and go to state 133
    fn_arg                         shift and go to state 286

state 287

    (192) enum_con -> id CLASSACCESS id .

    LPAREN          reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    ADD             reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    SUB             reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    MUL             reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    DIV             reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    MODOP           reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    LESSTHAN        reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    LESSTHANOREQUAL reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    GREATERTHAN     reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    GREATERTHANOREQUAL reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    EQUALTO         reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    NOTEQUAL        reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    LOGICALOR       reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    LOGICALAND      reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    EQU             reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    PLUSEQUAL       reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    SUBEQUAL        reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    DIVEQUAL        reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    TIMESEQUAL      reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    MODEQUAL        reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    ANDEQUAL        reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    OREQUAL         reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    LBRACKET        reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    PERIOD          reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    SEMICOLON       reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    RSQUIGBRACKET   reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    RPAREN          reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    LOOP            reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    WHILE           reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    BOX             reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    IF              reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    MATCH           reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    ID              reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    NOT             reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    AND             reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    LITDEC          reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    LITCHAR         reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    LITBOOL         reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    LITSTRING       reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    COMMA           reduce using rule 192 (enum_con -> id CLASSACCESS id .)
    RBRACKET        reduce using rule 192 (enum_con -> id CLASSACCESS id .)


state 288

    (97) if -> IF LPAREN exp . RPAREN block
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

    RPAREN          shift and go to state 305
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216


state 289

    (174) type_arr -> LBRACKET type SEMICOLON p_lit RBRACKET .

    EQU             reduce using rule 174 (type_arr -> LBRACKET type SEMICOLON p_lit RBRACKET .)
    SEMICOLON       reduce using rule 174 (type_arr -> LBRACKET type SEMICOLON p_lit RBRACKET .)
    RSQUIGBRACKET   reduce using rule 174 (type_arr -> LBRACKET type SEMICOLON p_lit RBRACKET .)
    RBRACKET        reduce using rule 174 (type_arr -> LBRACKET type SEMICOLON p_lit RBRACKET .)
    COMMA           reduce using rule 174 (type_arr -> LBRACKET type SEMICOLON p_lit RBRACKET .)
    ID              reduce using rule 174 (type_arr -> LBRACKET type SEMICOLON p_lit RBRACKET .)
    RPAREN          reduce using rule 174 (type_arr -> LBRACKET type SEMICOLON p_lit RBRACKET .)
    LSQUIGBRACKET   reduce using rule 174 (type_arr -> LBRACKET type SEMICOLON p_lit RBRACKET .)
    GREATERTHAN     reduce using rule 174 (type_arr -> LBRACKET type SEMICOLON p_lit RBRACKET .)


state 290

    (177) box_new -> BOX CLASSACCESS NEW LPAREN . exp RPAREN
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    LPAREN          shift and go to state 121
    RPAREN          reduce using rule 31 (exp -> .)
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 306
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    loop                           shift and go to state 126
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    mul                            shift and go to state 143
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 291

    (92) let -> LET pat EQU exp .
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

    SEMICOLON       reduce using rule 92 (let -> LET pat EQU exp .)
    RSQUIGBRACKET   reduce using rule 92 (let -> LET pat EQU exp .)
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216


state 292

    (90) let -> LET pat COLON type . EQU exp
    (91) let -> LET pat COLON type .

    EQU             shift and go to state 307
    SEMICOLON       reduce using rule 91 (let -> LET pat COLON type .)
    RSQUIGBRACKET   reduce using rule 91 (let -> LET pat COLON type .)


state 293

    (191) enum_con -> enum_con LPAREN exps RPAREN .

    LPAREN          reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    ADD             reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    SUB             reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    MUL             reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    DIV             reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    MODOP           reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    LESSTHAN        reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    LESSTHANOREQUAL reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    GREATERTHAN     reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    GREATERTHANOREQUAL reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    EQUALTO         reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    NOTEQUAL        reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    LOGICALOR       reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    LOGICALAND      reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    EQU             reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    PLUSEQUAL       reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    SUBEQUAL        reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    DIVEQUAL        reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    TIMESEQUAL      reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    MODEQUAL        reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    ANDEQUAL        reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    OREQUAL         reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    LBRACKET        reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    PERIOD          reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    SEMICOLON       reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    RSQUIGBRACKET   reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    RPAREN          reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    LOOP            reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    WHILE           reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    BOX             reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    IF              reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    MATCH           reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    ID              reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    NOT             reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    AND             reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    LITDEC          reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    LITCHAR         reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    LITBOOL         reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    LITSTRING       reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    COMMA           reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)
    RBRACKET        reduce using rule 191 (enum_con -> enum_con LPAREN exps RPAREN .)


state 294

    (99) match -> MATCH LPAREN exp RPAREN . LSQUIGBRACKET match_arms RSQUIGBRACKET

    LSQUIGBRACKET   shift and go to state 308


state 295

    (125) arr_index -> exp LBRACKET exp RBRACKET .

    EQU             reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    PLUSEQUAL       reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    SUBEQUAL        reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    DIVEQUAL        reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    TIMESEQUAL      reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    MODEQUAL        reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    ANDEQUAL        reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    OREQUAL         reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    LBRACKET        reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    PERIOD          reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    SEMICOLON       reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    RSQUIGBRACKET   reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    COMMA           reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    RBRACKET        reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    RPAREN          reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    ID              reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    LPAREN          reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    LOOP            reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    WHILE           reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    BOX             reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    IF              reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    MATCH           reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    SUB             reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    NOT             reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    AND             reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    MUL             reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    LITDEC          reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    LITCHAR         reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    LITBOOL         reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)
    LITSTRING       reduce using rule 125 (arr_index -> exp LBRACKET exp RBRACKET .)


state 296

    (17) exps -> exp COMMA exps .
    (15) exps -> exps .

  ! reduce/reduce conflict for RBRACKET resolved using rule 15 (exps -> exps .)
  ! reduce/reduce conflict for RPAREN resolved using rule 15 (exps -> exps .)
    RBRACKET        reduce using rule 15 (exps -> exps .)
    RPAREN          reduce using rule 15 (exps -> exps .)

  ! RBRACKET        [ reduce using rule 17 (exps -> exp COMMA exps .) ]
  ! RPAREN          [ reduce using rule 17 (exps -> exp COMMA exps .) ]


state 297

    (95) while -> WHILE LPAREN exp RPAREN . block
    (183) block -> . LSQUIGBRACKET stmts RSQUIGBRACKET

    LSQUIGBRACKET   shift and go to state 91

    block                          shift and go to state 309

state 298

    (186) arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .

    EQU             reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    PLUSEQUAL       reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    SUBEQUAL        reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    DIVEQUAL        reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    TIMESEQUAL      reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    MODEQUAL        reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    ANDEQUAL        reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    OREQUAL         reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    LBRACKET        reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    PERIOD          reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    SEMICOLON       reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    RSQUIGBRACKET   reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    RPAREN          reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    LPAREN          reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    LOOP            reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    WHILE           reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    BOX             reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    IF              reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    MATCH           reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    ID              reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    SUB             reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    NOT             reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    AND             reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    MUL             reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    LITDEC          reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    LITCHAR         reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    LITBOOL         reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    LITSTRING       reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    COMMA           reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)
    RBRACKET        reduce using rule 186 (arg_struct -> id LSQUIGBRACKET body RSQUIGBRACKET .)


state 299

    (187) body -> param_arg body .

    RSQUIGBRACKET   reduce using rule 187 (body -> param_arg body .)


state 300

    (189) param_arg -> param_arg COMMA .

    COMMA           reduce using rule 189 (param_arg -> param_arg COMMA .)
    ID              reduce using rule 189 (param_arg -> param_arg COMMA .)
    RSQUIGBRACKET   reduce using rule 189 (param_arg -> param_arg COMMA .)


state 301

    (190) param_arg -> id COLON . exp
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    LPAREN          shift and go to state 121
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    COMMA           reduce using rule 31 (exp -> .)
    RSQUIGBRACKET   reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]
  ! ID              [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 310
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    mul                            shift and go to state 143
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    loop                           shift and go to state 126
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 302

    (128) fn_call -> id LPAREN fn_args RPAREN .

    ADD             reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    SUB             reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    MUL             reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    DIV             reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    MODOP           reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    LESSTHAN        reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    LESSTHANOREQUAL reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    GREATERTHAN     reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    GREATERTHANOREQUAL reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    EQUALTO         reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    NOTEQUAL        reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    LOGICALOR       reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    LOGICALAND      reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    EQU             reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    PLUSEQUAL       reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    SUBEQUAL        reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    DIVEQUAL        reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    TIMESEQUAL      reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    MODEQUAL        reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    ANDEQUAL        reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    OREQUAL         reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    LBRACKET        reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    PERIOD          reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    SEMICOLON       reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    RSQUIGBRACKET   reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    RPAREN          reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    LPAREN          reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    LOOP            reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    WHILE           reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    BOX             reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    IF              reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    MATCH           reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    ID              reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    NOT             reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    AND             reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    LITDEC          reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    LITCHAR         reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    LITBOOL         reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    LITSTRING       reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    COMMA           reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)
    RBRACKET        reduce using rule 128 (fn_call -> id LPAREN fn_args RPAREN .)


state 303

    (129) fn_args -> fn_arg fn_args .

    RPAREN          reduce using rule 129 (fn_args -> fn_arg fn_args .)


state 304

    (131) fn_arg -> fn_arg COMMA .

    COMMA           reduce using rule 131 (fn_arg -> fn_arg COMMA .)
    ID              reduce using rule 131 (fn_arg -> fn_arg COMMA .)
    BOX             reduce using rule 131 (fn_arg -> fn_arg COMMA .)
    LITDEC          reduce using rule 131 (fn_arg -> fn_arg COMMA .)
    LITCHAR         reduce using rule 131 (fn_arg -> fn_arg COMMA .)
    LITBOOL         reduce using rule 131 (fn_arg -> fn_arg COMMA .)
    LITSTRING       reduce using rule 131 (fn_arg -> fn_arg COMMA .)
    RPAREN          reduce using rule 131 (fn_arg -> fn_arg COMMA .)


state 305

    (97) if -> IF LPAREN exp RPAREN . block
    (183) block -> . LSQUIGBRACKET stmts RSQUIGBRACKET

    LSQUIGBRACKET   shift and go to state 91

    block                          shift and go to state 311

state 306

    (177) box_new -> BOX CLASSACCESS NEW LPAREN exp . RPAREN
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

    RPAREN          shift and go to state 312
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216


state 307

    (90) let -> LET pat COLON type EQU . exp
    (19) exp -> . LPAREN exp RPAREN
    (20) exp -> . arith1
    (21) exp -> . loop
    (22) exp -> . while
    (23) exp -> . box_new
    (24) exp -> . if
    (25) exp -> . match
    (26) exp -> . arg_struct
    (27) exp -> . assign
    (28) exp -> . arr
    (29) exp -> . arr_index
    (30) exp -> . unit
    (31) exp -> .
    (32) arith1 -> . add
    (33) arith1 -> . sub
    (34) arith1 -> . arith2
    (96) loop -> . LOOP block
    (95) while -> . WHILE LPAREN exp RPAREN block
    (177) box_new -> . BOX CLASSACCESS NEW LPAREN exp RPAREN
    (97) if -> . IF LPAREN exp RPAREN block
    (98) if -> . if ELSE block
    (99) match -> . MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET
    (186) arg_struct -> . id LSQUIGBRACKET body RSQUIGBRACKET
    (82) assign -> . exp EQU exp
    (83) assign -> . exp PLUSEQUAL exp
    (84) assign -> . exp SUBEQUAL exp
    (85) assign -> . exp DIVEQUAL exp
    (86) assign -> . exp TIMESEQUAL exp
    (87) assign -> . exp MODEQUAL exp
    (88) assign -> . exp ANDEQUAL exp
    (89) assign -> . exp OREQUAL exp
    (124) arr -> . LBRACKET exps RBRACKET
    (125) arr_index -> . exp LBRACKET exp RBRACKET
    (81) unit -> . LPAREN RPAREN
    (48) add -> . arith1 ADD arith1
    (49) sub -> . arith1 SUB arith1
    (35) arith2 -> . mul
    (36) arith2 -> . div
    (37) arith2 -> . mod
    (38) arith2 -> . neg
    (39) arith2 -> . arith3
    (143) id -> . ID
    (50) mul -> . arith1 MUL arith1
    (51) div -> . arith1 DIV arith1
    (52) mod -> . arith1 MODOP arith1
    (53) neg -> . SUB arith4
    (40) arith3 -> . LPAREN arith1 RPAREN
    (41) arith3 -> . fn_call
    (42) arith3 -> . comp
    (43) arith3 -> . field_lookup
    (44) arith3 -> . arith4
    (128) fn_call -> . id LPAREN fn_args RPAREN
    (54) comp -> . lt
    (55) comp -> . leq
    (56) comp -> . gt
    (57) comp -> . geq
    (58) comp -> . eq
    (59) comp -> . neq
    (60) comp -> . or
    (61) comp -> . and
    (62) comp -> . not
    (94) field_lookup -> . exp PERIOD id
    (45) arith4 -> . id
    (46) arith4 -> . ptr
    (47) arith4 -> . lit
    (63) lt -> . arith1 LESSTHAN arith1
    (64) leq -> . arith1 LESSTHANOREQUAL arith1
    (65) gt -> . arith1 GREATERTHAN arith1
    (66) geq -> . arith1 GREATERTHANOREQUAL arith1
    (67) eq -> . arith1 EQUALTO arith1
    (68) neq -> . arith1 NOTEQUAL arith1
    (69) or -> . arith1 LOGICALOR arith1
    (70) and -> . arith1 LOGICALAND arith1
    (71) not -> . NOT arith1
    (72) ptr -> . addr
    (73) ptr -> . deref
    (74) ptr -> . addr_of_mut
    (137) lit -> . p_lit
    (138) lit -> . enum_con
    (75) addr -> . AND arith4
    (76) addr -> . AND neg
    (77) deref -> . MUL arith4
    (78) deref -> . MUL neg
    (79) addr_of_mut -> . AND MUT arith4
    (80) addr_of_mut -> . AND MUT neg
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (191) enum_con -> . enum_con LPAREN exps RPAREN
    (192) enum_con -> . id CLASSACCESS id

  ! shift/reduce conflict for LBRACKET resolved as shift
    LPAREN          shift and go to state 121
    EQU             reduce using rule 31 (exp -> .)
    PLUSEQUAL       reduce using rule 31 (exp -> .)
    SUBEQUAL        reduce using rule 31 (exp -> .)
    DIVEQUAL        reduce using rule 31 (exp -> .)
    TIMESEQUAL      reduce using rule 31 (exp -> .)
    MODEQUAL        reduce using rule 31 (exp -> .)
    ANDEQUAL        reduce using rule 31 (exp -> .)
    OREQUAL         reduce using rule 31 (exp -> .)
    PERIOD          reduce using rule 31 (exp -> .)
    SEMICOLON       reduce using rule 31 (exp -> .)
    RSQUIGBRACKET   reduce using rule 31 (exp -> .)
    LOOP            shift and go to state 166
    WHILE           shift and go to state 162
    BOX             shift and go to state 117
    IF              shift and go to state 169
    MATCH           shift and go to state 136
    LBRACKET        shift and go to state 159
    ID              shift and go to state 10
    SUB             shift and go to state 156
    NOT             shift and go to state 158
    AND             shift and go to state 154
    MUL             shift and go to state 137
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40

  ! LBRACKET        [ reduce using rule 31 (exp -> .) ]

    arg_struct                     shift and go to state 112
    div                            shift and go to state 113
    box_new                        shift and go to state 146
    comp                           shift and go to state 147
    p_lit                          shift and go to state 116
    leq                            shift and go to state 148
    not                            shift and go to state 134
    arith4                         shift and go to state 119
    neg                            shift and go to state 122
    arr                            shift and go to state 149
    match                          shift and go to state 124
    exp                            shift and go to state 313
    arr_index                      shift and go to state 152
    geq                            shift and go to state 153
    neq                            shift and go to state 155
    addr                           shift and go to state 127
    lt                             shift and go to state 128
    ptr                            shift and go to state 145
    assign                         shift and go to state 129
    fn_call                        shift and go to state 130
    add                            shift and go to state 131
    field_lookup                   shift and go to state 150
    eq                             shift and go to state 157
    enum_con                       shift and go to state 133
    arith2                         shift and go to state 160
    mul                            shift and go to state 143
    arith3                         shift and go to state 161
    id                             shift and go to state 163
    mod                            shift and go to state 164
    arith1                         shift and go to state 138
    lit                            shift and go to state 139
    unit                           shift and go to state 114
    and                            shift and go to state 165
    while                          shift and go to state 140
    if                             shift and go to state 141
    deref                          shift and go to state 167
    sub                            shift and go to state 142
    loop                           shift and go to state 126
    gt                             shift and go to state 125
    or                             shift and go to state 170
    addr_of_mut                    shift and go to state 168

state 308

    (99) match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET . match_arms RSQUIGBRACKET
    (100) match_arms -> . match_arm COMMA match_arms
    (101) match_arms -> . match_arm
    (102) match_arm -> . match_pats PIPE block
    (103) match_pats -> . pat OR match_pats
    (104) match_pats -> . pat
    (107) pat -> . p_lit
    (108) pat -> . LPAREN RPAREN
    (109) pat -> . WC
    (110) pat -> . SUB p_lit
    (111) pat -> . id
    (112) pat -> . REF id
    (113) pat -> . REF MUT id
    (114) pat -> . MUT id
    (115) pat -> . AND pat
    (116) pat -> . pat_arr
    (117) pat -> . pat_enum
    (118) pat -> . pat_struct
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (143) id -> . ID
    (119) pat_arr -> . LBRACKET pats RBRACKET
    (193) pat_enum -> . pat_enum LPAREN pats RPAREN
    (194) pat_enum -> . id CLASSACCESS id
    (120) pat_struct -> . id LSQUIGBRACKET pat_fields RSQUIGBRACKET

    LPAREN          shift and go to state 29
    WC              shift and go to state 36
    SUB             shift and go to state 34
    REF             shift and go to state 32
    MUT             shift and go to state 33
    AND             shift and go to state 30
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40
    ID              shift and go to state 10
    LBRACKET        shift and go to state 41

    match_pats                     shift and go to state 314
    p_lit                          shift and go to state 26
    pat_enum                       shift and go to state 35
    match_arms                     shift and go to state 316
    pat_arr                        shift and go to state 37
    pat                            shift and go to state 317
    match_arm                      shift and go to state 315
    pat_struct                     shift and go to state 42
    id                             shift and go to state 43

state 309

    (95) while -> WHILE LPAREN exp RPAREN block .

    RPAREN          reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    EQU             reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    PLUSEQUAL       reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    SUBEQUAL        reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    DIVEQUAL        reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    TIMESEQUAL      reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    MODEQUAL        reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    ANDEQUAL        reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    OREQUAL         reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    LBRACKET        reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    PERIOD          reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    LPAREN          reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    LOOP            reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    WHILE           reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    BOX             reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    IF              reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    MATCH           reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    ID              reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    SUB             reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    NOT             reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    AND             reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    MUL             reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    LITDEC          reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    LITCHAR         reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    LITBOOL         reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    LITSTRING       reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    SEMICOLON       reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    RSQUIGBRACKET   reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    COMMA           reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)
    RBRACKET        reduce using rule 95 (while -> WHILE LPAREN exp RPAREN block .)


state 310

    (190) param_arg -> id COLON exp .
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

    COMMA           reduce using rule 190 (param_arg -> id COLON exp .)
    ID              reduce using rule 190 (param_arg -> id COLON exp .)
    RSQUIGBRACKET   reduce using rule 190 (param_arg -> id COLON exp .)
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216


state 311

    (97) if -> IF LPAREN exp RPAREN block .

    ELSE            reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    RPAREN          reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    EQU             reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    PLUSEQUAL       reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    SUBEQUAL        reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    DIVEQUAL        reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    TIMESEQUAL      reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    MODEQUAL        reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    ANDEQUAL        reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    OREQUAL         reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    LBRACKET        reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    PERIOD          reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    SEMICOLON       reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    RSQUIGBRACKET   reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    LPAREN          reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    LOOP            reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    WHILE           reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    BOX             reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    IF              reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    MATCH           reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    ID              reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    SUB             reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    NOT             reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    AND             reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    MUL             reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    LITDEC          reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    LITCHAR         reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    LITBOOL         reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    LITSTRING       reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    COMMA           reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)
    RBRACKET        reduce using rule 97 (if -> IF LPAREN exp RPAREN block .)


state 312

    (177) box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .

    PERIOD          reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    EQU             reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    PLUSEQUAL       reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    SUBEQUAL        reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    DIVEQUAL        reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    TIMESEQUAL      reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    MODEQUAL        reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    ANDEQUAL        reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    OREQUAL         reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    LBRACKET        reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    SEMICOLON       reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    RSQUIGBRACKET   reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    RPAREN          reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    LPAREN          reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    LOOP            reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    WHILE           reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    BOX             reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    IF              reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    MATCH           reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    ID              reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    SUB             reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    NOT             reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    AND             reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    MUL             reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    LITDEC          reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    LITCHAR         reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    LITBOOL         reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    LITSTRING       reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    COMMA           reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)
    RBRACKET        reduce using rule 177 (box_new -> BOX CLASSACCESS NEW LPAREN exp RPAREN .)


state 313

    (90) let -> LET pat COLON type EQU exp .
    (82) assign -> exp . EQU exp
    (83) assign -> exp . PLUSEQUAL exp
    (84) assign -> exp . SUBEQUAL exp
    (85) assign -> exp . DIVEQUAL exp
    (86) assign -> exp . TIMESEQUAL exp
    (87) assign -> exp . MODEQUAL exp
    (88) assign -> exp . ANDEQUAL exp
    (89) assign -> exp . OREQUAL exp
    (125) arr_index -> exp . LBRACKET exp RBRACKET
    (94) field_lookup -> exp . PERIOD id

    SEMICOLON       reduce using rule 90 (let -> LET pat COLON type EQU exp .)
    RSQUIGBRACKET   reduce using rule 90 (let -> LET pat COLON type EQU exp .)
    EQU             shift and go to state 215
    PLUSEQUAL       shift and go to state 214
    SUBEQUAL        shift and go to state 218
    DIVEQUAL        shift and go to state 211
    TIMESEQUAL      shift and go to state 213
    MODEQUAL        shift and go to state 212
    ANDEQUAL        shift and go to state 210
    OREQUAL         shift and go to state 209
    LBRACKET        shift and go to state 217
    PERIOD          shift and go to state 216


state 314

    (102) match_arm -> match_pats . PIPE block

    PIPE            shift and go to state 318


state 315

    (100) match_arms -> match_arm . COMMA match_arms
    (101) match_arms -> match_arm .

    COMMA           shift and go to state 319
    RSQUIGBRACKET   reduce using rule 101 (match_arms -> match_arm .)


state 316

    (99) match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms . RSQUIGBRACKET

    RSQUIGBRACKET   shift and go to state 320


state 317

    (103) match_pats -> pat . OR match_pats
    (104) match_pats -> pat .

    OR              shift and go to state 321
    PIPE            reduce using rule 104 (match_pats -> pat .)


state 318

    (102) match_arm -> match_pats PIPE . block
    (183) block -> . LSQUIGBRACKET stmts RSQUIGBRACKET

    LSQUIGBRACKET   shift and go to state 91

    block                          shift and go to state 322

state 319

    (100) match_arms -> match_arm COMMA . match_arms
    (100) match_arms -> . match_arm COMMA match_arms
    (101) match_arms -> . match_arm
    (102) match_arm -> . match_pats PIPE block
    (103) match_pats -> . pat OR match_pats
    (104) match_pats -> . pat
    (107) pat -> . p_lit
    (108) pat -> . LPAREN RPAREN
    (109) pat -> . WC
    (110) pat -> . SUB p_lit
    (111) pat -> . id
    (112) pat -> . REF id
    (113) pat -> . REF MUT id
    (114) pat -> . MUT id
    (115) pat -> . AND pat
    (116) pat -> . pat_arr
    (117) pat -> . pat_enum
    (118) pat -> . pat_struct
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (143) id -> . ID
    (119) pat_arr -> . LBRACKET pats RBRACKET
    (193) pat_enum -> . pat_enum LPAREN pats RPAREN
    (194) pat_enum -> . id CLASSACCESS id
    (120) pat_struct -> . id LSQUIGBRACKET pat_fields RSQUIGBRACKET

    LPAREN          shift and go to state 29
    WC              shift and go to state 36
    SUB             shift and go to state 34
    REF             shift and go to state 32
    MUT             shift and go to state 33
    AND             shift and go to state 30
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40
    ID              shift and go to state 10
    LBRACKET        shift and go to state 41

    match_pats                     shift and go to state 314
    p_lit                          shift and go to state 26
    pat_enum                       shift and go to state 35
    match_arms                     shift and go to state 323
    pat_arr                        shift and go to state 37
    pat                            shift and go to state 317
    match_arm                      shift and go to state 315
    pat_struct                     shift and go to state 42
    id                             shift and go to state 43

state 320

    (99) match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .

    EQU             reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    PLUSEQUAL       reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    SUBEQUAL        reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    DIVEQUAL        reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    TIMESEQUAL      reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    MODEQUAL        reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    ANDEQUAL        reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    OREQUAL         reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    LBRACKET        reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    PERIOD          reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    SEMICOLON       reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    RSQUIGBRACKET   reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    LPAREN          reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    LOOP            reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    WHILE           reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    BOX             reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    IF              reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    MATCH           reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    ID              reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    SUB             reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    NOT             reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    AND             reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    MUL             reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    LITDEC          reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    LITCHAR         reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    LITBOOL         reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    LITSTRING       reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    RPAREN          reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    COMMA           reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)
    RBRACKET        reduce using rule 99 (match -> MATCH LPAREN exp RPAREN LSQUIGBRACKET match_arms RSQUIGBRACKET .)


state 321

    (103) match_pats -> pat OR . match_pats
    (103) match_pats -> . pat OR match_pats
    (104) match_pats -> . pat
    (107) pat -> . p_lit
    (108) pat -> . LPAREN RPAREN
    (109) pat -> . WC
    (110) pat -> . SUB p_lit
    (111) pat -> . id
    (112) pat -> . REF id
    (113) pat -> . REF MUT id
    (114) pat -> . MUT id
    (115) pat -> . AND pat
    (116) pat -> . pat_arr
    (117) pat -> . pat_enum
    (118) pat -> . pat_struct
    (139) p_lit -> . LITDEC
    (140) p_lit -> . LITCHAR
    (141) p_lit -> . LITBOOL
    (142) p_lit -> . LITSTRING
    (143) id -> . ID
    (119) pat_arr -> . LBRACKET pats RBRACKET
    (193) pat_enum -> . pat_enum LPAREN pats RPAREN
    (194) pat_enum -> . id CLASSACCESS id
    (120) pat_struct -> . id LSQUIGBRACKET pat_fields RSQUIGBRACKET

    LPAREN          shift and go to state 29
    WC              shift and go to state 36
    SUB             shift and go to state 34
    REF             shift and go to state 32
    MUT             shift and go to state 33
    AND             shift and go to state 30
    LITDEC          shift and go to state 31
    LITCHAR         shift and go to state 39
    LITBOOL         shift and go to state 25
    LITSTRING       shift and go to state 40
    ID              shift and go to state 10
    LBRACKET        shift and go to state 41

    pat_arr                        shift and go to state 37
    pat                            shift and go to state 317
    match_pats                     shift and go to state 324
    id                             shift and go to state 43
    pat_struct                     shift and go to state 42
    p_lit                          shift and go to state 26
    pat_enum                       shift and go to state 35

state 322

    (102) match_arm -> match_pats PIPE block .

    COMMA           reduce using rule 102 (match_arm -> match_pats PIPE block .)
    RSQUIGBRACKET   reduce using rule 102 (match_arm -> match_pats PIPE block .)


state 323

    (100) match_arms -> match_arm COMMA match_arms .

    RSQUIGBRACKET   reduce using rule 100 (match_arms -> match_arm COMMA match_arms .)


state 324

    (103) match_pats -> pat OR match_pats .

    PIPE            reduce using rule 103 (match_pats -> pat OR match_pats .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 46 resolved as shift
WARNING: shift/reduce conflict for ID in state 71 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 91 resolved as shift
WARNING: shift/reduce conflict for ID in state 106 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 121 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 121 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 132 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 132 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 132 resolved as shift
WARNING: shift/reduce conflict for BOX in state 132 resolved as shift
WARNING: shift/reduce conflict for IF in state 132 resolved as shift
WARNING: shift/reduce conflict for MATCH in state 132 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 132 resolved as shift
WARNING: shift/reduce conflict for ID in state 132 resolved as shift
WARNING: shift/reduce conflict for SUB in state 132 resolved as shift
WARNING: shift/reduce conflict for NOT in state 132 resolved as shift
WARNING: shift/reduce conflict for AND in state 132 resolved as shift
WARNING: shift/reduce conflict for MUL in state 132 resolved as shift
WARNING: shift/reduce conflict for LITDEC in state 132 resolved as shift
WARNING: shift/reduce conflict for LITCHAR in state 132 resolved as shift
WARNING: shift/reduce conflict for LITBOOL in state 132 resolved as shift
WARNING: shift/reduce conflict for LITSTRING in state 132 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 133 resolved as shift
WARNING: shift/reduce conflict for SUB in state 138 resolved as shift
WARNING: shift/reduce conflict for MUL in state 138 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 158 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 159 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 163 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 184 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 187 resolved as shift
WARNING: shift/reduce conflict for EQU in state 188 resolved as shift
WARNING: shift/reduce conflict for PLUSEQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for SUBEQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for DIVEQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for TIMESEQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for MODEQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for ANDEQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for OREQUAL in state 188 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 188 resolved as shift
WARNING: shift/reduce conflict for PERIOD in state 188 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 189 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 190 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 194 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 195 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 196 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 197 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 198 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 199 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 200 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 201 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 202 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 203 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 204 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 205 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 206 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 209 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 209 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 209 resolved as shift
WARNING: shift/reduce conflict for BOX in state 209 resolved as shift
WARNING: shift/reduce conflict for IF in state 209 resolved as shift
WARNING: shift/reduce conflict for MATCH in state 209 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 209 resolved as shift
WARNING: shift/reduce conflict for ID in state 209 resolved as shift
WARNING: shift/reduce conflict for SUB in state 209 resolved as shift
WARNING: shift/reduce conflict for NOT in state 209 resolved as shift
WARNING: shift/reduce conflict for AND in state 209 resolved as shift
WARNING: shift/reduce conflict for MUL in state 209 resolved as shift
WARNING: shift/reduce conflict for LITDEC in state 209 resolved as shift
WARNING: shift/reduce conflict for LITCHAR in state 209 resolved as shift
WARNING: shift/reduce conflict for LITBOOL in state 209 resolved as shift
WARNING: shift/reduce conflict for LITSTRING in state 209 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 210 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 210 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 210 resolved as shift
WARNING: shift/reduce conflict for BOX in state 210 resolved as shift
WARNING: shift/reduce conflict for IF in state 210 resolved as shift
WARNING: shift/reduce conflict for MATCH in state 210 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 210 resolved as shift
WARNING: shift/reduce conflict for ID in state 210 resolved as shift
WARNING: shift/reduce conflict for SUB in state 210 resolved as shift
WARNING: shift/reduce conflict for NOT in state 210 resolved as shift
WARNING: shift/reduce conflict for AND in state 210 resolved as shift
WARNING: shift/reduce conflict for MUL in state 210 resolved as shift
WARNING: shift/reduce conflict for LITDEC in state 210 resolved as shift
WARNING: shift/reduce conflict for LITCHAR in state 210 resolved as shift
WARNING: shift/reduce conflict for LITBOOL in state 210 resolved as shift
WARNING: shift/reduce conflict for LITSTRING in state 210 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 211 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 211 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 211 resolved as shift
WARNING: shift/reduce conflict for BOX in state 211 resolved as shift
WARNING: shift/reduce conflict for IF in state 211 resolved as shift
WARNING: shift/reduce conflict for MATCH in state 211 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 211 resolved as shift
WARNING: shift/reduce conflict for ID in state 211 resolved as shift
WARNING: shift/reduce conflict for SUB in state 211 resolved as shift
WARNING: shift/reduce conflict for NOT in state 211 resolved as shift
WARNING: shift/reduce conflict for AND in state 211 resolved as shift
WARNING: shift/reduce conflict for MUL in state 211 resolved as shift
WARNING: shift/reduce conflict for LITDEC in state 211 resolved as shift
WARNING: shift/reduce conflict for LITCHAR in state 211 resolved as shift
WARNING: shift/reduce conflict for LITBOOL in state 211 resolved as shift
WARNING: shift/reduce conflict for LITSTRING in state 211 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 212 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 212 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 212 resolved as shift
WARNING: shift/reduce conflict for BOX in state 212 resolved as shift
WARNING: shift/reduce conflict for IF in state 212 resolved as shift
WARNING: shift/reduce conflict for MATCH in state 212 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 212 resolved as shift
WARNING: shift/reduce conflict for ID in state 212 resolved as shift
WARNING: shift/reduce conflict for SUB in state 212 resolved as shift
WARNING: shift/reduce conflict for NOT in state 212 resolved as shift
WARNING: shift/reduce conflict for AND in state 212 resolved as shift
WARNING: shift/reduce conflict for MUL in state 212 resolved as shift
WARNING: shift/reduce conflict for LITDEC in state 212 resolved as shift
WARNING: shift/reduce conflict for LITCHAR in state 212 resolved as shift
WARNING: shift/reduce conflict for LITBOOL in state 212 resolved as shift
WARNING: shift/reduce conflict for LITSTRING in state 212 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 213 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 213 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 213 resolved as shift
WARNING: shift/reduce conflict for BOX in state 213 resolved as shift
WARNING: shift/reduce conflict for IF in state 213 resolved as shift
WARNING: shift/reduce conflict for MATCH in state 213 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 213 resolved as shift
WARNING: shift/reduce conflict for ID in state 213 resolved as shift
WARNING: shift/reduce conflict for SUB in state 213 resolved as shift
WARNING: shift/reduce conflict for NOT in state 213 resolved as shift
WARNING: shift/reduce conflict for AND in state 213 resolved as shift
WARNING: shift/reduce conflict for MUL in state 213 resolved as shift
WARNING: shift/reduce conflict for LITDEC in state 213 resolved as shift
WARNING: shift/reduce conflict for LITCHAR in state 213 resolved as shift
WARNING: shift/reduce conflict for LITBOOL in state 213 resolved as shift
WARNING: shift/reduce conflict for LITSTRING in state 213 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 214 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 214 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 214 resolved as shift
WARNING: shift/reduce conflict for BOX in state 214 resolved as shift
WARNING: shift/reduce conflict for IF in state 214 resolved as shift
WARNING: shift/reduce conflict for MATCH in state 214 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 214 resolved as shift
WARNING: shift/reduce conflict for ID in state 214 resolved as shift
WARNING: shift/reduce conflict for SUB in state 214 resolved as shift
WARNING: shift/reduce conflict for NOT in state 214 resolved as shift
WARNING: shift/reduce conflict for AND in state 214 resolved as shift
WARNING: shift/reduce conflict for MUL in state 214 resolved as shift
WARNING: shift/reduce conflict for LITDEC in state 214 resolved as shift
WARNING: shift/reduce conflict for LITCHAR in state 214 resolved as shift
WARNING: shift/reduce conflict for LITBOOL in state 214 resolved as shift
WARNING: shift/reduce conflict for LITSTRING in state 214 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 215 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 215 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 215 resolved as shift
WARNING: shift/reduce conflict for BOX in state 215 resolved as shift
WARNING: shift/reduce conflict for IF in state 215 resolved as shift
WARNING: shift/reduce conflict for MATCH in state 215 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 215 resolved as shift
WARNING: shift/reduce conflict for ID in state 215 resolved as shift
WARNING: shift/reduce conflict for SUB in state 215 resolved as shift
WARNING: shift/reduce conflict for NOT in state 215 resolved as shift
WARNING: shift/reduce conflict for AND in state 215 resolved as shift
WARNING: shift/reduce conflict for MUL in state 215 resolved as shift
WARNING: shift/reduce conflict for LITDEC in state 215 resolved as shift
WARNING: shift/reduce conflict for LITCHAR in state 215 resolved as shift
WARNING: shift/reduce conflict for LITBOOL in state 215 resolved as shift
WARNING: shift/reduce conflict for LITSTRING in state 215 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 217 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 218 resolved as shift
WARNING: shift/reduce conflict for LOOP in state 218 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 218 resolved as shift
WARNING: shift/reduce conflict for BOX in state 218 resolved as shift
WARNING: shift/reduce conflict for IF in state 218 resolved as shift
WARNING: shift/reduce conflict for MATCH in state 218 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 218 resolved as shift
WARNING: shift/reduce conflict for ID in state 218 resolved as shift
WARNING: shift/reduce conflict for SUB in state 218 resolved as shift
WARNING: shift/reduce conflict for NOT in state 218 resolved as shift
WARNING: shift/reduce conflict for AND in state 218 resolved as shift
WARNING: shift/reduce conflict for MUL in state 218 resolved as shift
WARNING: shift/reduce conflict for LITDEC in state 218 resolved as shift
WARNING: shift/reduce conflict for LITCHAR in state 218 resolved as shift
WARNING: shift/reduce conflict for LITBOOL in state 218 resolved as shift
WARNING: shift/reduce conflict for LITSTRING in state 218 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 223 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 223 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 226 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 227 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 229 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 234 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 241 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 246 resolved as shift
WARNING: shift/reduce conflict for EQU in state 262 resolved as shift
WARNING: shift/reduce conflict for PLUSEQUAL in state 262 resolved as shift
WARNING: shift/reduce conflict for SUBEQUAL in state 262 resolved as shift
WARNING: shift/reduce conflict for DIVEQUAL in state 262 resolved as shift
WARNING: shift/reduce conflict for TIMESEQUAL in state 262 resolved as shift
WARNING: shift/reduce conflict for MODEQUAL in state 262 resolved as shift
WARNING: shift/reduce conflict for ANDEQUAL in state 262 resolved as shift
WARNING: shift/reduce conflict for OREQUAL in state 262 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 262 resolved as shift
WARNING: shift/reduce conflict for PERIOD in state 262 resolved as shift
WARNING: shift/reduce conflict for EQU in state 263 resolved as shift
WARNING: shift/reduce conflict for PLUSEQUAL in state 263 resolved as shift
WARNING: shift/reduce conflict for SUBEQUAL in state 263 resolved as shift
WARNING: shift/reduce conflict for DIVEQUAL in state 263 resolved as shift
WARNING: shift/reduce conflict for TIMESEQUAL in state 263 resolved as shift
WARNING: shift/reduce conflict for MODEQUAL in state 263 resolved as shift
WARNING: shift/reduce conflict for ANDEQUAL in state 263 resolved as shift
WARNING: shift/reduce conflict for OREQUAL in state 263 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 263 resolved as shift
WARNING: shift/reduce conflict for PERIOD in state 263 resolved as shift
WARNING: shift/reduce conflict for EQU in state 264 resolved as shift
WARNING: shift/reduce conflict for PLUSEQUAL in state 264 resolved as shift
WARNING: shift/reduce conflict for SUBEQUAL in state 264 resolved as shift
WARNING: shift/reduce conflict for DIVEQUAL in state 264 resolved as shift
WARNING: shift/reduce conflict for TIMESEQUAL in state 264 resolved as shift
WARNING: shift/reduce conflict for MODEQUAL in state 264 resolved as shift
WARNING: shift/reduce conflict for ANDEQUAL in state 264 resolved as shift
WARNING: shift/reduce conflict for OREQUAL in state 264 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 264 resolved as shift
WARNING: shift/reduce conflict for PERIOD in state 264 resolved as shift
WARNING: shift/reduce conflict for EQU in state 265 resolved as shift
WARNING: shift/reduce conflict for PLUSEQUAL in state 265 resolved as shift
WARNING: shift/reduce conflict for SUBEQUAL in state 265 resolved as shift
WARNING: shift/reduce conflict for DIVEQUAL in state 265 resolved as shift
WARNING: shift/reduce conflict for TIMESEQUAL in state 265 resolved as shift
WARNING: shift/reduce conflict for MODEQUAL in state 265 resolved as shift
WARNING: shift/reduce conflict for ANDEQUAL in state 265 resolved as shift
WARNING: shift/reduce conflict for OREQUAL in state 265 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 265 resolved as shift
WARNING: shift/reduce conflict for PERIOD in state 265 resolved as shift
WARNING: shift/reduce conflict for EQU in state 266 resolved as shift
WARNING: shift/reduce conflict for PLUSEQUAL in state 266 resolved as shift
WARNING: shift/reduce conflict for SUBEQUAL in state 266 resolved as shift
WARNING: shift/reduce conflict for DIVEQUAL in state 266 resolved as shift
WARNING: shift/reduce conflict for TIMESEQUAL in state 266 resolved as shift
WARNING: shift/reduce conflict for MODEQUAL in state 266 resolved as shift
WARNING: shift/reduce conflict for ANDEQUAL in state 266 resolved as shift
WARNING: shift/reduce conflict for OREQUAL in state 266 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 266 resolved as shift
WARNING: shift/reduce conflict for PERIOD in state 266 resolved as shift
WARNING: shift/reduce conflict for EQU in state 267 resolved as shift
WARNING: shift/reduce conflict for PLUSEQUAL in state 267 resolved as shift
WARNING: shift/reduce conflict for SUBEQUAL in state 267 resolved as shift
WARNING: shift/reduce conflict for DIVEQUAL in state 267 resolved as shift
WARNING: shift/reduce conflict for TIMESEQUAL in state 267 resolved as shift
WARNING: shift/reduce conflict for MODEQUAL in state 267 resolved as shift
WARNING: shift/reduce conflict for ANDEQUAL in state 267 resolved as shift
WARNING: shift/reduce conflict for OREQUAL in state 267 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 267 resolved as shift
WARNING: shift/reduce conflict for PERIOD in state 267 resolved as shift
WARNING: shift/reduce conflict for EQU in state 268 resolved as shift
WARNING: shift/reduce conflict for PLUSEQUAL in state 268 resolved as shift
WARNING: shift/reduce conflict for SUBEQUAL in state 268 resolved as shift
WARNING: shift/reduce conflict for DIVEQUAL in state 268 resolved as shift
WARNING: shift/reduce conflict for TIMESEQUAL in state 268 resolved as shift
WARNING: shift/reduce conflict for MODEQUAL in state 268 resolved as shift
WARNING: shift/reduce conflict for ANDEQUAL in state 268 resolved as shift
WARNING: shift/reduce conflict for OREQUAL in state 268 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 268 resolved as shift
WARNING: shift/reduce conflict for PERIOD in state 268 resolved as shift
WARNING: shift/reduce conflict for EQU in state 271 resolved as shift
WARNING: shift/reduce conflict for PLUSEQUAL in state 271 resolved as shift
WARNING: shift/reduce conflict for SUBEQUAL in state 271 resolved as shift
WARNING: shift/reduce conflict for DIVEQUAL in state 271 resolved as shift
WARNING: shift/reduce conflict for TIMESEQUAL in state 271 resolved as shift
WARNING: shift/reduce conflict for MODEQUAL in state 271 resolved as shift
WARNING: shift/reduce conflict for ANDEQUAL in state 271 resolved as shift
WARNING: shift/reduce conflict for OREQUAL in state 271 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 271 resolved as shift
WARNING: shift/reduce conflict for PERIOD in state 271 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 275 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 290 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 301 resolved as shift
WARNING: shift/reduce conflict for ID in state 301 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 307 resolved as shift
WARNING: reduce/reduce conflict in state 9 resolved using rule (items -> item)
WARNING: rejected rule (items -> <empty>) in state 9
WARNING: reduce/reduce conflict in state 91 resolved using rule (stmts -> <empty>)
WARNING: rejected rule (exp -> <empty>) in state 91
WARNING: reduce/reduce conflict in state 97 resolved using rule (fn_param -> pat COLON id)
WARNING: rejected rule (type -> id) in state 97
WARNING: reduce/reduce conflict in state 132 resolved using rule (stmt -> return)
WARNING: rejected rule (exp -> <empty>) in state 132
WARNING: reduce/reduce conflict in state 159 resolved using rule (exps -> <empty>)
WARNING: rejected rule (exp -> <empty>) in state 159
WARNING: reduce/reduce conflict in state 187 resolved using rule (stmts -> <empty>)
WARNING: rejected rule (exp -> <empty>) in state 187
WARNING: reduce/reduce conflict in state 189 resolved using rule (exps -> <empty>)
WARNING: rejected rule (exp -> <empty>) in state 189
WARNING: reduce/reduce conflict in state 224 resolved using rule (exp -> arith1)
WARNING: rejected rule (not -> NOT arith1) in state 224
WARNING: reduce/reduce conflict in state 248 resolved using rule (exp -> arith1)
WARNING: rejected rule (gt -> arith1 GREATERTHAN arith1) in state 248
WARNING: reduce/reduce conflict in state 249 resolved using rule (exp -> arith1)
WARNING: rejected rule (sub -> arith1 SUB arith1) in state 249
WARNING: reduce/reduce conflict in state 250 resolved using rule (exp -> arith1)
WARNING: rejected rule (or -> arith1 LOGICALOR arith1) in state 250
WARNING: reduce/reduce conflict in state 251 resolved using rule (exp -> arith1)
WARNING: rejected rule (div -> arith1 DIV arith1) in state 251
WARNING: reduce/reduce conflict in state 252 resolved using rule (exp -> arith1)
WARNING: rejected rule (geq -> arith1 GREATERTHANOREQUAL arith1) in state 252
WARNING: reduce/reduce conflict in state 253 resolved using rule (exp -> arith1)
WARNING: rejected rule (mul -> arith1 MUL arith1) in state 253
WARNING: reduce/reduce conflict in state 254 resolved using rule (exp -> arith1)
WARNING: rejected rule (and -> arith1 LOGICALAND arith1) in state 254
WARNING: reduce/reduce conflict in state 255 resolved using rule (exp -> arith1)
WARNING: rejected rule (leq -> arith1 LESSTHANOREQUAL arith1) in state 255
WARNING: reduce/reduce conflict in state 256 resolved using rule (exp -> arith1)
WARNING: rejected rule (lt -> arith1 LESSTHAN arith1) in state 256
WARNING: reduce/reduce conflict in state 257 resolved using rule (exp -> arith1)
WARNING: rejected rule (neq -> arith1 NOTEQUAL arith1) in state 257
WARNING: reduce/reduce conflict in state 258 resolved using rule (exp -> arith1)
WARNING: rejected rule (add -> arith1 ADD arith1) in state 258
WARNING: reduce/reduce conflict in state 259 resolved using rule (exp -> arith1)
WARNING: rejected rule (mod -> arith1 MODOP arith1) in state 259
WARNING: reduce/reduce conflict in state 260 resolved using rule (exp -> arith1)
WARNING: rejected rule (eq -> arith1 EQUALTO arith1) in state 260
WARNING: reduce/reduce conflict in state 275 resolved using rule (exps -> <empty>)
WARNING: rejected rule (exp -> <empty>) in state 275
WARNING: reduce/reduce conflict in state 296 resolved using rule (exps -> exps)
WARNING: rejected rule (exps -> exp COMMA exps) in state 296
WARNING: Rule (exps -> exp COMMA exps) is never reduced
